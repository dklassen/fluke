// Code generated from ClickHouseParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // ClickHouseParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type ClickHouseParser struct {
	*antlr.BaseParser
}

var ClickHouseParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func clickhouseparserParserInit() {
	staticData := &ClickHouseParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "'->'", "'*'", "'`'", "'\\'", "'::'",
		"':'", "','", "'||'", "'-'", "'.'", "'=='", "'='", "'>='", "'>'", "'{'",
		"'['", "'<='", "'('", "'<'", "", "'%'", "'+'", "'?'", "'\"'", "'''",
		"'}'", "']'", "')'", "';'", "'/'", "'_'",
	}
	staticData.SymbolicNames = []string{
		"", "ACCESS", "ADD", "AFTER", "ALIAS", "ALL", "ALTER", "AND", "ANTI",
		"ANY", "ARRAY", "AS", "ASCENDING", "ASOF", "AST", "ASYNC", "ATTACH",
		"BETWEEN", "BOTH", "BY", "CACHES", "CASE", "CAST", "CHECK", "CLEAR",
		"CLUSTER", "CLUSTERS", "CODEC", "COLLATE", "COLUMN", "COLUMNS", "COMMENT",
		"CONSTRAINT", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_USER",
		"CHANGED", "DATABASE", "DATABASES", "DATE", "DAY", "DEDUPLICATE", "DEFAULT",
		"DELAY", "DELETE", "DESC", "DESCENDING", "DESCRIBE", "DETACH", "DICTIONARIES",
		"DICTIONARY", "DISK", "DISTINCT", "DISTRIBUTED", "DROP", "ELSE", "ENABLED",
		"END", "ENGINE", "ENGINES", "ESTIMATE", "EVENTS", "EXCEPT", "EXISTS",
		"EXPLAIN", "EXPRESSION", "EXTENDED", "EXTRACT", "FETCHES", "FIELDS",
		"FILESYSTEM", "FILL", "FINAL", "FIRST", "FLUSH", "FOLLOWING", "FOR",
		"FORMAT", "FREEZE", "FROM", "FULL", "FUNCTION", "FUNCTIONS", "GLOBAL",
		"GRANULARITY", "GRANTS", "GROUP", "GROUPING", "HAVING", "HIERARCHICAL",
		"HOUR", "ID", "IF", "ILIKE", "IMPLICIT", "IN", "INDEX", "INDEXES", "INDICES",
		"INF", "INJECTIVE", "INNER", "INSERT", "INTERPOLATE", "INTERVAL", "INTO",
		"IS", "IS_OBJECT_ID", "JOIN", "KEY", "KEYS", "KILL", "LAST", "LAYOUT",
		"LEADING", "LEFT", "LIFETIME", "LIKE", "LIMIT", "LIVE", "LOCAL", "LOGS",
		"MATERIALIZE", "MATERIALIZED", "MAX", "MERGES", "MICROSECOND", "MILLISECOND",
		"MIN", "MINUTE", "MODIFY", "MONTH", "MOVE", "MUTATION", "NAN_SQL", "NANOSECOND",
		"NO", "NOT", "NULL_SQL", "NULLS", "OFFSET", "ON", "OPTIMIZE", "OR",
		"ORDER", "OUTER", "OUTFILE", "OVER", "OVERRIDE", "PARTITION", "PIPELINE",
		"PLAN", "POLICY", "POLICIES", "POPULATE", "PRECEDING", "PREWHERE", "PRIMARY",
		"PRIVILEGES", "PROCESSLIST", "PROFILE", "PROFILES", "PROJECTION", "QUARTER",
		"QUOTA", "QUOTAS", "RANGE", "RECURSIVE", "RELOAD", "REMOVE", "RENAME",
		"REPLACE", "REPLICA", "REPLICATED", "RIGHT", "ROLE", "ROLES", "ROLLUP",
		"ROW", "ROWS", "SAMPLE", "SECOND", "SELECT", "SEMI", "SENDS", "SET",
		"SETS", "SETTING", "SETTINGS", "SHOW", "SOURCE", "START", "STOP", "SUBSTRING",
		"SYNC", "SYNTAX", "SYSTEM", "STEP", "TABLE", "TABLES", "TEMPORARY",
		"TEST", "THEN", "TIES", "TIMEOUT", "TIMESTAMP", "TO", "TOP", "TOTALS",
		"TRAILING", "TREE", "TRIM", "TRUNCATE", "TTL", "TYPE", "UNBOUNDED",
		"UNION", "UPDATE", "USE", "USER", "USERS", "USING", "UUID", "VALUES",
		"VIEW", "VOLUME", "WATCH", "WEEK", "WHEN", "WHERE", "WINDOW", "WITH",
		"YEAR", "JSON_FALSE", "JSON_TRUE", "HEXADECIMAL_STRING_LITERAL", "BINARY_STRING_LITERAL",
		"IDENTIFIER", "FLOATING_LITERAL", "OCTAL_LITERAL", "DECIMAL_LITERAL",
		"HEXADECIMAL_NUMERIC_LITERAL", "BINARY_NUMERIC_LITERAL", "STRING_LITERAL",
		"ARROW", "ASTERISK", "BACKQUOTE", "BACKSLASH", "DOUBLE_COLON", "COLON",
		"COMMA", "CONCAT", "DASH", "DOT", "EQ_DOUBLE", "EQ_SINGLE", "GE", "GT",
		"LBRACE", "LBRACKET", "LE", "LPAREN", "LT", "NOT_EQ", "PERCENT", "PLUS",
		"QUERY", "QUOTE_DOUBLE", "QUOTE_SINGLE", "RBRACE", "RBRACKET", "RPAREN",
		"SEMICOLON", "SLASH", "UNDERSCORE", "MULTI_LINE_COMMENT", "SINGLE_LINE_COMMENT",
		"WHITESPACE",
	}
	staticData.RuleNames = []string{
		"queryStmt", "query", "alterStmt", "alterTableClause", "assignmentExprList",
		"assignmentExpr", "tableColumnPropertyType", "partitionClause", "attachStmt",
		"checkStmt", "createStmt", "dictionarySchemaClause", "dictionaryAttrDfnt",
		"dictionaryEngineClause", "dictionaryPrimaryKeyClause", "dictionaryArgExpr",
		"sourceClause", "lifetimeClause", "layoutClause", "rangeClause", "dictionarySettingsClause",
		"clusterClause", "uuidClause", "destinationClause", "subqueryClause",
		"tableSchemaClause", "engineClause", "partitionByClause", "primaryKeyClause",
		"sampleByClause", "ttlClause", "engineExpr", "tableElementExpr", "tableColumnDfnt",
		"tableColumnPropertyExpr", "tableIndexDfnt", "tableProjectionDfnt",
		"codecExpr", "codecArgExpr", "ttlExpr", "ttlSetExpr", "describeStmt",
		"dropStmt", "existsStmt", "explainStmt", "insertStmt", "columnsClause",
		"dataClause", "assignmentValues", "assignmentValue", "killStmt", "optimizeStmt",
		"renameStmt", "projectionSelectStmt", "selectUnionStmt", "selectStmtWithParens",
		"selectStmt", "withClause", "withExprList", "withExpr", "topClause",
		"fromClause", "arrayJoinClause", "windowClause", "prewhereClause", "whereClause",
		"groupByClause", "havingClause", "orderByClause", "interpolateClause",
		"projectionOrderByClause", "limitByClause", "limitClause", "settingsClause",
		"joinExpr", "joinOp", "joinOpCross", "joinConstraintClause", "sampleClause",
		"limitExpr", "orderExprList", "orderExpr", "ratioExpr", "settingExprList",
		"settingExpr", "windowExpr", "winPartitionByClause", "winOrderByClause",
		"winFrameClause", "winFrameExtend", "winFrameBound", "setStmt", "showStmt",
		"systemStmt", "truncateStmt", "useStmt", "watchStmt", "columnTypeExpr",
		"columnExprList", "columnsExpr", "columnExpr", "columnArgList", "columnArgExpr",
		"columnLambdaExpr", "columnIdentifier", "nestedIdentifier", "columnExceptExpr",
		"tableExpr", "tableFunctionExpr", "tableIdentifier", "tableArgList",
		"tableArgExpr", "databaseIdentifier", "floatingLiteral", "numberLiteral",
		"stringLiteral", "literal", "interval", "keyword", "keywordForAlias",
		"alias", "identifier", "identifierOrNull", "enumValue",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 279, 2461, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0, 253, 8, 0, 1,
		0, 1, 0, 3, 0, 257, 8, 0, 1, 0, 3, 0, 260, 8, 0, 1, 0, 3, 0, 263, 8, 0,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 283, 8, 1, 1, 2, 1, 2, 1, 2,
		1, 2, 3, 2, 289, 8, 2, 1, 2, 1, 2, 1, 2, 5, 2, 294, 8, 2, 10, 2, 12, 2,
		297, 9, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 304, 8, 3, 1, 3, 1, 3, 1,
		3, 3, 3, 309, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 316, 8, 3, 1, 3,
		1, 3, 1, 3, 3, 3, 321, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 328, 8,
		3, 1, 3, 1, 3, 1, 3, 3, 3, 333, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 339,
		8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 345, 8, 3, 1, 3, 1, 3, 1, 3, 3, 3,
		350, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 356, 8, 3, 1, 3, 1, 3, 1, 3, 3,
		3, 361, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 367, 8, 3, 1, 3, 1, 3, 1, 3,
		3, 3, 372, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 378, 8, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 392, 8,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 399, 8, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 3, 3, 406, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 413, 8, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 419, 8, 3, 1, 3, 1, 3, 1, 3, 3, 3, 424, 8,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 430, 8, 3, 1, 3, 1, 3, 1, 3, 3, 3, 435,
		8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 441, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 3, 3, 450, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 3, 3, 460, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 3, 3, 470, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 490,
		8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 498, 8, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3,
		513, 8, 3, 1, 4, 1, 4, 1, 4, 5, 4, 518, 8, 4, 10, 4, 12, 4, 521, 9, 4,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7,
		534, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 540, 8, 8, 1, 9, 1, 9, 1, 9, 1,
		9, 3, 9, 546, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 553, 8, 10,
		1, 10, 1, 10, 3, 10, 557, 8, 10, 1, 10, 3, 10, 560, 8, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 3, 10, 566, 8, 10, 1, 10, 3, 10, 569, 8, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 3, 10, 575, 8, 10, 1, 10, 1, 10, 3, 10, 579, 8, 10, 1, 10,
		3, 10, 582, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 3, 10, 593, 8, 10, 1, 10, 1, 10, 3, 10, 597, 8, 10, 1, 10, 3,
		10, 600, 8, 10, 1, 10, 1, 10, 1, 10, 3, 10, 605, 8, 10, 3, 10, 607, 8,
		10, 1, 10, 3, 10, 610, 8, 10, 1, 10, 3, 10, 613, 8, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 623, 8, 10, 1, 10, 1, 10,
		3, 10, 627, 8, 10, 1, 10, 3, 10, 630, 8, 10, 1, 10, 3, 10, 633, 8, 10,
		1, 10, 1, 10, 1, 10, 3, 10, 638, 8, 10, 3, 10, 640, 8, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 648, 8, 10, 1, 10, 3, 10, 651, 8, 10,
		1, 10, 3, 10, 654, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 660, 8, 10,
		1, 10, 1, 10, 3, 10, 664, 8, 10, 1, 10, 3, 10, 667, 8, 10, 1, 10, 3, 10,
		670, 8, 10, 1, 10, 3, 10, 673, 8, 10, 1, 10, 3, 10, 676, 8, 10, 1, 10,
		1, 10, 1, 10, 3, 10, 681, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 687,
		8, 10, 1, 10, 1, 10, 3, 10, 691, 8, 10, 1, 10, 3, 10, 694, 8, 10, 1, 10,
		3, 10, 697, 8, 10, 1, 10, 1, 10, 3, 10, 701, 8, 10, 1, 11, 1, 11, 1, 11,
		1, 11, 5, 11, 707, 8, 11, 10, 11, 12, 11, 710, 9, 11, 1, 11, 1, 11, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 5, 12, 736, 8, 12, 10, 12, 12, 12, 739, 9, 12, 1, 13, 1, 13, 3, 13,
		743, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 5, 13, 765, 8, 13, 10, 13, 12, 13, 768, 9, 13, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 778, 8, 15, 1, 15, 3, 15,
		781, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 788, 8, 16, 10, 16,
		12, 16, 791, 9, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 807, 8, 17, 1, 17,
		1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 816, 8, 18, 10, 18, 12,
		18, 819, 9, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 836, 8, 19, 1,
		19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21,
		3, 21, 849, 8, 21, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 24, 1,
		24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 864, 8, 25, 10, 25, 12, 25,
		867, 9, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 875, 8, 25,
		1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26,
		1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26, 903, 8, 26, 10, 26, 12, 26, 906,
		9, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1,
		29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 924, 8, 30, 10, 30,
		12, 30, 927, 9, 30, 1, 31, 1, 31, 3, 31, 931, 8, 31, 1, 31, 1, 31, 1, 31,
		3, 31, 936, 8, 31, 1, 31, 3, 31, 939, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32,
		1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 951, 8, 32, 1, 33, 1,
		33, 1, 33, 3, 33, 956, 8, 33, 1, 33, 1, 33, 3, 33, 960, 8, 33, 1, 33, 3,
		33, 963, 8, 33, 1, 33, 1, 33, 3, 33, 967, 8, 33, 1, 33, 1, 33, 3, 33, 971,
		8, 33, 1, 33, 1, 33, 1, 33, 3, 33, 976, 8, 33, 1, 33, 3, 33, 979, 8, 33,
		1, 33, 1, 33, 3, 33, 983, 8, 33, 3, 33, 985, 8, 33, 1, 34, 1, 34, 1, 34,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1,
		37, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 1005, 8, 37, 10, 37, 12, 37, 1008,
		9, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 3, 38, 1015, 8, 38, 1, 38, 3,
		38, 1018, 8, 38, 1, 39, 1, 39, 1, 39, 3, 39, 1023, 8, 39, 1, 39, 1, 39,
		1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 1031, 8, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 5, 39, 1039, 8, 39, 10, 39, 12, 39, 1042, 9, 39, 3, 39,
		1044, 8, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 3, 41, 1052, 8,
		41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1060, 8, 42, 1, 42,
		1, 42, 3, 42, 1064, 8, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1069, 8, 42, 1,
		42, 1, 42, 3, 42, 1073, 8, 42, 1, 42, 1, 42, 3, 42, 1077, 8, 42, 1, 42,
		1, 42, 3, 42, 1081, 8, 42, 1, 42, 1, 42, 3, 42, 1085, 8, 42, 3, 42, 1087,
		8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1095, 8, 43, 1,
		43, 1, 43, 3, 43, 1099, 8, 43, 1, 43, 3, 43, 1102, 8, 43, 1, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1114, 8,
		44, 1, 44, 3, 44, 1117, 8, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 3, 45,
		1124, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1129, 8, 45, 1, 45, 3, 45, 1132,
		8, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 1140, 8, 46, 10,
		46, 12, 46, 1143, 9, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 5, 47, 1153, 8, 47, 10, 47, 12, 47, 1156, 9, 47, 1, 47, 1, 47, 3,
		47, 1160, 8, 47, 1, 47, 1, 47, 3, 47, 1164, 8, 47, 1, 48, 1, 48, 1, 48,
		1, 48, 5, 48, 1170, 8, 48, 10, 48, 12, 48, 1173, 9, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 3, 48, 1179, 8, 48, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 3, 50,
		1186, 8, 50, 1, 50, 1, 50, 3, 50, 1190, 8, 50, 1, 51, 1, 51, 1, 51, 1,
		51, 3, 51, 1196, 8, 51, 1, 51, 3, 51, 1199, 8, 51, 1, 51, 3, 51, 1202,
		8, 51, 1, 51, 3, 51, 1205, 8, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 5, 52, 1217, 8, 52, 10, 52, 12, 52, 1220,
		9, 52, 1, 52, 3, 52, 1223, 8, 52, 1, 53, 1, 53, 3, 53, 1227, 8, 53, 1,
		53, 1, 53, 1, 53, 3, 53, 1232, 8, 53, 1, 53, 3, 53, 1235, 8, 53, 1, 53,
		1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 5, 54, 1243, 8, 54, 10, 54, 12, 54,
		1246, 9, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1253, 8, 55, 1,
		56, 3, 56, 1256, 8, 56, 1, 56, 1, 56, 3, 56, 1260, 8, 56, 1, 56, 3, 56,
		1263, 8, 56, 1, 56, 1, 56, 3, 56, 1267, 8, 56, 1, 56, 3, 56, 1270, 8, 56,
		1, 56, 3, 56, 1273, 8, 56, 1, 56, 3, 56, 1276, 8, 56, 1, 56, 3, 56, 1279,
		8, 56, 1, 56, 3, 56, 1282, 8, 56, 1, 56, 1, 56, 3, 56, 1286, 8, 56, 1,
		56, 1, 56, 3, 56, 1290, 8, 56, 1, 56, 3, 56, 1293, 8, 56, 1, 56, 3, 56,
		1296, 8, 56, 1, 56, 3, 56, 1299, 8, 56, 1, 56, 3, 56, 1302, 8, 56, 1, 56,
		3, 56, 1305, 8, 56, 1, 56, 3, 56, 1308, 8, 56, 1, 57, 1, 57, 1, 57, 1,
		58, 1, 58, 1, 58, 5, 58, 1316, 8, 58, 10, 58, 12, 58, 1319, 9, 58, 1, 59,
		3, 59, 1322, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 3, 59, 1334, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60,
		1340, 8, 60, 1, 61, 1, 61, 1, 61, 1, 62, 3, 62, 1346, 8, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64,
		1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1,
		66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66,
		1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1386, 8, 66, 1, 67, 1, 67, 1,
		67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 70,
		1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1,
		72, 1, 72, 3, 72, 1413, 8, 72, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74,
		3, 74, 1421, 8, 74, 1, 74, 3, 74, 1424, 8, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 3, 74, 1430, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74,
		1438, 8, 74, 1, 74, 3, 74, 1441, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 5,
		74, 1447, 8, 74, 10, 74, 12, 74, 1450, 9, 74, 1, 75, 3, 75, 1453, 8, 75,
		1, 75, 1, 75, 1, 75, 3, 75, 1458, 8, 75, 1, 75, 3, 75, 1461, 8, 75, 1,
		75, 3, 75, 1464, 8, 75, 1, 75, 1, 75, 3, 75, 1468, 8, 75, 1, 75, 1, 75,
		3, 75, 1472, 8, 75, 1, 75, 3, 75, 1475, 8, 75, 3, 75, 1477, 8, 75, 1, 75,
		3, 75, 1480, 8, 75, 1, 75, 1, 75, 3, 75, 1484, 8, 75, 1, 75, 1, 75, 3,
		75, 1488, 8, 75, 1, 75, 3, 75, 1491, 8, 75, 3, 75, 1493, 8, 75, 3, 75,
		1495, 8, 75, 1, 76, 3, 76, 1498, 8, 76, 1, 76, 1, 76, 1, 76, 3, 76, 1503,
		8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3,
		77, 1514, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1520, 8, 78, 1, 79,
		1, 79, 1, 79, 3, 79, 1525, 8, 79, 1, 80, 1, 80, 1, 80, 5, 80, 1530, 8,
		80, 10, 80, 12, 80, 1533, 9, 80, 1, 81, 1, 81, 3, 81, 1537, 8, 81, 1, 81,
		1, 81, 3, 81, 1541, 8, 81, 1, 81, 1, 81, 3, 81, 1545, 8, 81, 1, 81, 1,
		81, 1, 81, 1, 81, 3, 81, 1551, 8, 81, 1, 81, 1, 81, 3, 81, 1555, 8, 81,
		1, 81, 1, 81, 3, 81, 1559, 8, 81, 3, 81, 1561, 8, 81, 1, 82, 1, 82, 1,
		82, 3, 82, 1566, 8, 82, 1, 83, 1, 83, 1, 83, 5, 83, 1571, 8, 83, 10, 83,
		12, 83, 1574, 9, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 3, 85, 1581, 8,
		85, 1, 85, 3, 85, 1584, 8, 85, 1, 85, 3, 85, 1587, 8, 85, 1, 86, 1, 86,
		1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 89, 1,
		89, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1606, 8, 89, 1, 90, 1, 90, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1620,
		8, 90, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 3, 92, 1627, 8, 92, 1, 92, 1,
		92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1637, 8, 92, 1, 92,
		1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1644, 8, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 3, 92, 1650, 8, 92, 1, 92, 1, 92, 3, 92, 1654, 8, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 3, 92, 1660, 8, 92, 1, 92, 3, 92, 1663, 8, 92, 1, 92, 1,
		92, 1, 92, 1, 92, 3, 92, 1669, 8, 92, 1, 92, 1, 92, 3, 92, 1673, 8, 92,
		1, 92, 1, 92, 3, 92, 1677, 8, 92, 1, 92, 3, 92, 1680, 8, 92, 1, 92, 1,
		92, 1, 92, 3, 92, 1685, 8, 92, 1, 92, 3, 92, 1688, 8, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 3, 92, 1694, 8, 92, 1, 92, 1, 92, 3, 92, 1698, 8, 92, 1,
		92, 1, 92, 3, 92, 1702, 8, 92, 1, 92, 3, 92, 1705, 8, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1714, 8, 92, 1, 92, 3, 92, 1717,
		8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1723, 8, 92, 1, 92, 1, 92, 3,
		92, 1727, 8, 92, 1, 92, 1, 92, 3, 92, 1731, 8, 92, 1, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1740, 8, 92, 1, 92, 1, 92, 3, 92, 1744,
		8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 5, 92, 1754,
		8, 92, 10, 92, 12, 92, 1757, 9, 92, 3, 92, 1759, 8, 92, 1, 92, 1, 92, 3,
		92, 1763, 8, 92, 1, 92, 3, 92, 1766, 8, 92, 1, 92, 1, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 5, 92, 1774, 8, 92, 10, 92, 12, 92, 1777, 9, 92, 1, 92, 3,
		92, 1780, 8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 5, 92, 1788,
		8, 92, 10, 92, 12, 92, 1791, 9, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1796, 8,
		92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 5, 92, 1804, 8, 92, 10, 92,
		12, 92, 1807, 9, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 5, 92, 1815,
		8, 92, 10, 92, 12, 92, 1818, 9, 92, 1, 92, 3, 92, 1821, 8, 92, 1, 92, 1,
		92, 1, 92, 3, 92, 1826, 8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 5, 92, 1832,
		8, 92, 10, 92, 12, 92, 1835, 9, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92,
		1841, 8, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1846, 8, 92, 1, 92, 1, 92, 1,
		92, 3, 92, 1851, 8, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1856, 8, 92, 1, 92,
		1, 92, 1, 92, 1, 92, 3, 92, 1862, 8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1873, 8, 92, 1, 92, 1, 92, 3, 92,
		1877, 8, 92, 1, 92, 1, 92, 3, 92, 1881, 8, 92, 1, 92, 1, 92, 3, 92, 1885,
		8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1902, 8, 92, 1, 92, 1, 92,
		1, 92, 3, 92, 1907, 8, 92, 1, 92, 1, 92, 3, 92, 1911, 8, 92, 1, 92, 1,
		92, 3, 92, 1915, 8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92,
		1923, 8, 92, 1, 92, 3, 92, 1926, 8, 92, 3, 92, 1928, 8, 92, 1, 92, 3, 92,
		1931, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1,
		93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93,
		1, 93, 3, 93, 1953, 8, 93, 1, 93, 3, 93, 1956, 8, 93, 1, 93, 1, 93, 1,
		93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1967, 8, 93, 1, 94,
		1, 94, 3, 94, 1971, 8, 94, 1, 94, 3, 94, 1974, 8, 94, 1, 94, 1, 94, 3,
		94, 1978, 8, 94, 1, 94, 1, 94, 3, 94, 1982, 8, 94, 1, 95, 1, 95, 1, 95,
		1, 96, 1, 96, 1, 96, 3, 96, 1990, 8, 96, 1, 96, 1, 96, 3, 96, 1994, 8,
		96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 5, 97,
		2005, 8, 97, 10, 97, 12, 97, 2008, 9, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1,
		97, 1, 97, 1, 97, 5, 97, 2017, 8, 97, 10, 97, 12, 97, 2020, 9, 97, 1, 97,
		1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 5, 97, 2029, 8, 97, 10, 97, 12,
		97, 2032, 9, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 3, 97, 2039, 8, 97,
		1, 97, 1, 97, 3, 97, 2043, 8, 97, 1, 98, 1, 98, 1, 98, 5, 98, 2048, 8,
		98, 10, 98, 12, 98, 2051, 9, 98, 1, 99, 1, 99, 1, 99, 3, 99, 2056, 8, 99,
		1, 99, 1, 99, 3, 99, 2060, 8, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3,
		99, 2067, 8, 99, 1, 100, 1, 100, 1, 100, 3, 100, 2072, 8, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 4, 100, 2079, 8, 100, 11, 100, 12, 100,
		2080, 1, 100, 1, 100, 3, 100, 2085, 8, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2116,
		8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		3, 100, 2135, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 3, 100, 2147, 8, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2157, 8, 100, 1, 100, 3,
		100, 2160, 8, 100, 1, 100, 1, 100, 3, 100, 2164, 8, 100, 1, 100, 3, 100,
		2167, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 3, 100, 2177, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2190, 8, 100, 1, 100, 1,
		100, 1, 100, 3, 100, 2195, 8, 100, 1, 100, 1, 100, 3, 100, 2199, 8, 100,
		1, 100, 1, 100, 3, 100, 2203, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2225, 8, 100,
		1, 100, 3, 100, 2228, 8, 100, 1, 100, 1, 100, 3, 100, 2232, 8, 100, 1,
		100, 3, 100, 2235, 8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100,
		1, 100, 1, 100, 3, 100, 2263, 8, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2268,
		8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2275, 8, 100, 5,
		100, 2277, 8, 100, 10, 100, 12, 100, 2280, 9, 100, 1, 101, 1, 101, 1, 101,
		5, 101, 2285, 8, 101, 10, 101, 12, 101, 2288, 9, 101, 1, 102, 1, 102, 3,
		102, 2292, 8, 102, 1, 103, 1, 103, 1, 103, 1, 103, 5, 103, 2298, 8, 103,
		10, 103, 12, 103, 2301, 9, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103,
		5, 103, 2308, 8, 103, 10, 103, 12, 103, 2311, 9, 103, 3, 103, 2313, 8,
		103, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 3, 104, 2321, 8, 104,
		1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 5, 105, 2328, 8, 105, 10, 105,
		12, 105, 2331, 9, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106,
		3, 106, 2339, 8, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 5,
		106, 2347, 8, 106, 10, 106, 12, 106, 2350, 9, 106, 1, 106, 1, 106, 3, 106,
		2354, 8, 106, 3, 106, 2356, 8, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 1, 107, 3, 107, 2365, 8, 107, 1, 107, 1, 107, 1, 107, 1, 107,
		3, 107, 2371, 8, 107, 5, 107, 2373, 8, 107, 10, 107, 12, 107, 2376, 9,
		107, 1, 108, 1, 108, 1, 108, 3, 108, 2381, 8, 108, 1, 108, 1, 108, 1, 109,
		1, 109, 1, 109, 3, 109, 2388, 8, 109, 1, 109, 1, 109, 1, 110, 1, 110, 1,
		110, 5, 110, 2395, 8, 110, 10, 110, 12, 110, 2398, 9, 110, 1, 111, 1, 111,
		1, 111, 3, 111, 2403, 8, 111, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1,
		113, 1, 113, 1, 113, 3, 113, 2413, 8, 113, 3, 113, 2415, 8, 113, 1, 114,
		3, 114, 2418, 8, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1,
		114, 3, 114, 2427, 8, 114, 1, 115, 1, 115, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 3, 116, 2436, 8, 116, 1, 117, 1, 117, 1, 118, 1, 118, 1, 119, 1,
		119, 1, 120, 1, 120, 3, 120, 2446, 8, 120, 1, 121, 1, 121, 1, 121, 3, 121,
		2451, 8, 121, 1, 122, 1, 122, 3, 122, 2455, 8, 122, 1, 123, 1, 123, 1,
		123, 1, 123, 1, 123, 0, 3, 148, 200, 214, 124, 0, 2, 4, 6, 8, 10, 12, 14,
		16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
		52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86,
		88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118,
		120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148,
		150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178,
		180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208,
		210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238,
		240, 242, 244, 246, 0, 33, 6, 0, 4, 4, 27, 27, 31, 31, 44, 44, 125, 125,
		215, 215, 2, 0, 16, 16, 33, 33, 3, 0, 4, 4, 44, 44, 125, 125, 2, 0, 47,
		47, 49, 49, 2, 0, 50, 50, 56, 56, 3, 0, 15, 15, 196, 196, 203, 203, 2,
		0, 5, 5, 54, 54, 2, 0, 35, 35, 179, 179, 2, 0, 103, 103, 117, 117, 2, 0,
		85, 85, 122, 122, 3, 0, 5, 5, 9, 9, 13, 13, 4, 0, 5, 5, 8, 9, 13, 13, 185,
		185, 2, 0, 117, 117, 176, 176, 2, 0, 5, 5, 9, 9, 2, 0, 142, 142, 252, 252,
		2, 0, 12, 12, 47, 48, 2, 0, 75, 75, 114, 114, 2, 0, 168, 168, 181, 181,
		2, 0, 95, 95, 119, 119, 2, 0, 81, 81, 97, 97, 2, 0, 30, 30, 71, 71, 2,
		0, 98, 100, 112, 112, 2, 0, 36, 36, 58, 58, 1, 0, 193, 194, 3, 0, 18, 18,
		116, 116, 211, 211, 3, 0, 247, 247, 266, 266, 275, 275, 2, 0, 253, 254,
		267, 267, 1, 0, 241, 242, 2, 0, 254, 254, 267, 267, 2, 0, 237, 238, 245,
		245, 10, 0, 42, 42, 92, 92, 128, 129, 131, 131, 133, 133, 137, 137, 165,
		165, 183, 183, 229, 229, 234, 234, 6, 0, 1, 100, 102, 132, 134, 135, 138,
		139, 141, 187, 189, 236, 54, 0, 3, 4, 6, 6, 14, 16, 18, 18, 21, 25, 27,
		27, 29, 29, 31, 33, 35, 36, 39, 41, 43, 45, 49, 53, 55, 56, 60, 60, 63,
		63, 65, 67, 69, 70, 76, 77, 80, 80, 83, 83, 86, 86, 91, 91, 93, 94, 98,
		98, 102, 102, 104, 104, 109, 109, 111, 111, 113, 113, 115, 116, 118, 118,
		121, 121, 123, 127, 130, 130, 132, 132, 134, 135, 138, 138, 144, 144, 148,
		149, 151, 151, 156, 157, 159, 159, 168, 168, 170, 175, 179, 180, 184, 184,
		186, 187, 191, 198, 200, 203, 205, 207, 210, 211, 213, 217, 219, 220, 224,
		228, 2850, 0, 262, 1, 0, 0, 0, 2, 282, 1, 0, 0, 0, 4, 284, 1, 0, 0, 0,
		6, 512, 1, 0, 0, 0, 8, 514, 1, 0, 0, 0, 10, 522, 1, 0, 0, 0, 12, 526, 1,
		0, 0, 0, 14, 533, 1, 0, 0, 0, 16, 535, 1, 0, 0, 0, 18, 541, 1, 0, 0, 0,
		20, 700, 1, 0, 0, 0, 22, 702, 1, 0, 0, 0, 24, 713, 1, 0, 0, 0, 26, 740,
		1, 0, 0, 0, 28, 769, 1, 0, 0, 0, 30, 773, 1, 0, 0, 0, 32, 782, 1, 0, 0,
		0, 34, 795, 1, 0, 0, 0, 36, 810, 1, 0, 0, 0, 38, 823, 1, 0, 0, 0, 40, 839,
		1, 0, 0, 0, 42, 844, 1, 0, 0, 0, 44, 850, 1, 0, 0, 0, 46, 853, 1, 0, 0,
		0, 48, 856, 1, 0, 0, 0, 50, 874, 1, 0, 0, 0, 52, 876, 1, 0, 0, 0, 54, 907,
		1, 0, 0, 0, 56, 911, 1, 0, 0, 0, 58, 915, 1, 0, 0, 0, 60, 919, 1, 0, 0,
		0, 62, 928, 1, 0, 0, 0, 64, 950, 1, 0, 0, 0, 66, 984, 1, 0, 0, 0, 68, 986,
		1, 0, 0, 0, 70, 989, 1, 0, 0, 0, 72, 996, 1, 0, 0, 0, 74, 999, 1, 0, 0,
		0, 76, 1011, 1, 0, 0, 0, 78, 1043, 1, 0, 0, 0, 80, 1045, 1, 0, 0, 0, 82,
		1049, 1, 0, 0, 0, 84, 1086, 1, 0, 0, 0, 86, 1101, 1, 0, 0, 0, 88, 1103,
		1, 0, 0, 0, 90, 1120, 1, 0, 0, 0, 92, 1135, 1, 0, 0, 0, 94, 1163, 1, 0,
		0, 0, 96, 1178, 1, 0, 0, 0, 98, 1180, 1, 0, 0, 0, 100, 1182, 1, 0, 0, 0,
		102, 1191, 1, 0, 0, 0, 104, 1206, 1, 0, 0, 0, 106, 1224, 1, 0, 0, 0, 108,
		1238, 1, 0, 0, 0, 110, 1252, 1, 0, 0, 0, 112, 1255, 1, 0, 0, 0, 114, 1309,
		1, 0, 0, 0, 116, 1312, 1, 0, 0, 0, 118, 1333, 1, 0, 0, 0, 120, 1335, 1,
		0, 0, 0, 122, 1341, 1, 0, 0, 0, 124, 1345, 1, 0, 0, 0, 126, 1351, 1, 0,
		0, 0, 128, 1358, 1, 0, 0, 0, 130, 1361, 1, 0, 0, 0, 132, 1385, 1, 0, 0,
		0, 134, 1387, 1, 0, 0, 0, 136, 1390, 1, 0, 0, 0, 138, 1394, 1, 0, 0, 0,
		140, 1399, 1, 0, 0, 0, 142, 1403, 1, 0, 0, 0, 144, 1408, 1, 0, 0, 0, 146,
		1414, 1, 0, 0, 0, 148, 1429, 1, 0, 0, 0, 150, 1494, 1, 0, 0, 0, 152, 1502,
		1, 0, 0, 0, 154, 1513, 1, 0, 0, 0, 156, 1515, 1, 0, 0, 0, 158, 1521, 1,
		0, 0, 0, 160, 1526, 1, 0, 0, 0, 162, 1534, 1, 0, 0, 0, 164, 1562, 1, 0,
		0, 0, 166, 1567, 1, 0, 0, 0, 168, 1575, 1, 0, 0, 0, 170, 1580, 1, 0, 0,
		0, 172, 1588, 1, 0, 0, 0, 174, 1592, 1, 0, 0, 0, 176, 1596, 1, 0, 0, 0,
		178, 1605, 1, 0, 0, 0, 180, 1619, 1, 0, 0, 0, 182, 1621, 1, 0, 0, 0, 184,
		1930, 1, 0, 0, 0, 186, 1966, 1, 0, 0, 0, 188, 1968, 1, 0, 0, 0, 190, 1983,
		1, 0, 0, 0, 192, 1986, 1, 0, 0, 0, 194, 2042, 1, 0, 0, 0, 196, 2044, 1,
		0, 0, 0, 198, 2066, 1, 0, 0, 0, 200, 2198, 1, 0, 0, 0, 202, 2281, 1, 0,
		0, 0, 204, 2291, 1, 0, 0, 0, 206, 2312, 1, 0, 0, 0, 208, 2320, 1, 0, 0,
		0, 210, 2324, 1, 0, 0, 0, 212, 2355, 1, 0, 0, 0, 214, 2364, 1, 0, 0, 0,
		216, 2377, 1, 0, 0, 0, 218, 2387, 1, 0, 0, 0, 220, 2391, 1, 0, 0, 0, 222,
		2402, 1, 0, 0, 0, 224, 2404, 1, 0, 0, 0, 226, 2414, 1, 0, 0, 0, 228, 2417,
		1, 0, 0, 0, 230, 2428, 1, 0, 0, 0, 232, 2435, 1, 0, 0, 0, 234, 2437, 1,
		0, 0, 0, 236, 2439, 1, 0, 0, 0, 238, 2441, 1, 0, 0, 0, 240, 2445, 1, 0,
		0, 0, 242, 2450, 1, 0, 0, 0, 244, 2454, 1, 0, 0, 0, 246, 2456, 1, 0, 0,
		0, 248, 252, 3, 2, 1, 0, 249, 250, 5, 107, 0, 0, 250, 251, 5, 148, 0, 0,
		251, 253, 3, 230, 115, 0, 252, 249, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253,
		256, 1, 0, 0, 0, 254, 255, 5, 79, 0, 0, 255, 257, 3, 244, 122, 0, 256,
		254, 1, 0, 0, 0, 256, 257, 1, 0, 0, 0, 257, 259, 1, 0, 0, 0, 258, 260,
		5, 274, 0, 0, 259, 258, 1, 0, 0, 0, 259, 260, 1, 0, 0, 0, 260, 263, 1,
		0, 0, 0, 261, 263, 3, 90, 45, 0, 262, 248, 1, 0, 0, 0, 262, 261, 1, 0,
		0, 0, 263, 1, 1, 0, 0, 0, 264, 283, 3, 4, 2, 0, 265, 283, 3, 16, 8, 0,
		266, 283, 3, 18, 9, 0, 267, 283, 3, 20, 10, 0, 268, 283, 3, 82, 41, 0,
		269, 283, 3, 84, 42, 0, 270, 283, 3, 86, 43, 0, 271, 283, 3, 88, 44, 0,
		272, 283, 3, 100, 50, 0, 273, 283, 3, 102, 51, 0, 274, 283, 3, 104, 52,
		0, 275, 283, 3, 108, 54, 0, 276, 283, 3, 182, 91, 0, 277, 283, 3, 184,
		92, 0, 278, 283, 3, 186, 93, 0, 279, 283, 3, 188, 94, 0, 280, 283, 3, 190,
		95, 0, 281, 283, 3, 192, 96, 0, 282, 264, 1, 0, 0, 0, 282, 265, 1, 0, 0,
		0, 282, 266, 1, 0, 0, 0, 282, 267, 1, 0, 0, 0, 282, 268, 1, 0, 0, 0, 282,
		269, 1, 0, 0, 0, 282, 270, 1, 0, 0, 0, 282, 271, 1, 0, 0, 0, 282, 272,
		1, 0, 0, 0, 282, 273, 1, 0, 0, 0, 282, 274, 1, 0, 0, 0, 282, 275, 1, 0,
		0, 0, 282, 276, 1, 0, 0, 0, 282, 277, 1, 0, 0, 0, 282, 278, 1, 0, 0, 0,
		282, 279, 1, 0, 0, 0, 282, 280, 1, 0, 0, 0, 282, 281, 1, 0, 0, 0, 283,
		3, 1, 0, 0, 0, 284, 285, 5, 6, 0, 0, 285, 286, 5, 200, 0, 0, 286, 288,
		3, 218, 109, 0, 287, 289, 3, 42, 21, 0, 288, 287, 1, 0, 0, 0, 288, 289,
		1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290, 295, 3, 6, 3, 0, 291, 292, 5, 252,
		0, 0, 292, 294, 3, 6, 3, 0, 293, 291, 1, 0, 0, 0, 294, 297, 1, 0, 0, 0,
		295, 293, 1, 0, 0, 0, 295, 296, 1, 0, 0, 0, 296, 5, 1, 0, 0, 0, 297, 295,
		1, 0, 0, 0, 298, 299, 5, 2, 0, 0, 299, 303, 5, 29, 0, 0, 300, 301, 5, 94,
		0, 0, 301, 302, 5, 139, 0, 0, 302, 304, 5, 65, 0, 0, 303, 300, 1, 0, 0,
		0, 303, 304, 1, 0, 0, 0, 304, 305, 1, 0, 0, 0, 305, 308, 3, 66, 33, 0,
		306, 307, 5, 3, 0, 0, 307, 309, 3, 210, 105, 0, 308, 306, 1, 0, 0, 0, 308,
		309, 1, 0, 0, 0, 309, 513, 1, 0, 0, 0, 310, 311, 5, 2, 0, 0, 311, 315,
		5, 98, 0, 0, 312, 313, 5, 94, 0, 0, 313, 314, 5, 139, 0, 0, 314, 316, 5,
		65, 0, 0, 315, 312, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316, 317, 1, 0, 0,
		0, 317, 320, 3, 70, 35, 0, 318, 319, 5, 3, 0, 0, 319, 321, 3, 210, 105,
		0, 320, 318, 1, 0, 0, 0, 320, 321, 1, 0, 0, 0, 321, 513, 1, 0, 0, 0, 322,
		323, 5, 2, 0, 0, 323, 327, 5, 164, 0, 0, 324, 325, 5, 94, 0, 0, 325, 326,
		5, 139, 0, 0, 326, 328, 5, 65, 0, 0, 327, 324, 1, 0, 0, 0, 327, 328, 1,
		0, 0, 0, 328, 329, 1, 0, 0, 0, 329, 332, 3, 72, 36, 0, 330, 331, 5, 3,
		0, 0, 331, 333, 3, 210, 105, 0, 332, 330, 1, 0, 0, 0, 332, 333, 1, 0, 0,
		0, 333, 513, 1, 0, 0, 0, 334, 335, 5, 16, 0, 0, 335, 338, 3, 14, 7, 0,
		336, 337, 5, 81, 0, 0, 337, 339, 3, 218, 109, 0, 338, 336, 1, 0, 0, 0,
		338, 339, 1, 0, 0, 0, 339, 513, 1, 0, 0, 0, 340, 341, 5, 24, 0, 0, 341,
		344, 5, 29, 0, 0, 342, 343, 5, 94, 0, 0, 343, 345, 5, 65, 0, 0, 344, 342,
		1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 349, 3, 210,
		105, 0, 347, 348, 5, 97, 0, 0, 348, 350, 3, 14, 7, 0, 349, 347, 1, 0, 0,
		0, 349, 350, 1, 0, 0, 0, 350, 513, 1, 0, 0, 0, 351, 352, 5, 24, 0, 0, 352,
		355, 5, 98, 0, 0, 353, 354, 5, 94, 0, 0, 354, 356, 5, 65, 0, 0, 355, 353,
		1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 360, 3, 210,
		105, 0, 358, 359, 5, 97, 0, 0, 359, 361, 3, 14, 7, 0, 360, 358, 1, 0, 0,
		0, 360, 361, 1, 0, 0, 0, 361, 513, 1, 0, 0, 0, 362, 363, 5, 24, 0, 0, 363,
		366, 5, 164, 0, 0, 364, 365, 5, 94, 0, 0, 365, 367, 5, 65, 0, 0, 366, 364,
		1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367, 368, 1, 0, 0, 0, 368, 371, 3, 210,
		105, 0, 369, 370, 5, 97, 0, 0, 370, 372, 3, 14, 7, 0, 371, 369, 1, 0, 0,
		0, 371, 372, 1, 0, 0, 0, 372, 513, 1, 0, 0, 0, 373, 374, 5, 31, 0, 0, 374,
		377, 5, 29, 0, 0, 375, 376, 5, 94, 0, 0, 376, 378, 5, 65, 0, 0, 377, 375,
		1, 0, 0, 0, 377, 378, 1, 0, 0, 0, 378, 379, 1, 0, 0, 0, 379, 380, 3, 210,
		105, 0, 380, 381, 3, 230, 115, 0, 381, 513, 1, 0, 0, 0, 382, 383, 5, 46,
		0, 0, 383, 384, 5, 231, 0, 0, 384, 513, 3, 200, 100, 0, 385, 386, 5, 50,
		0, 0, 386, 513, 3, 14, 7, 0, 387, 388, 5, 56, 0, 0, 388, 391, 5, 29, 0,
		0, 389, 390, 5, 94, 0, 0, 390, 392, 5, 65, 0, 0, 391, 389, 1, 0, 0, 0,
		391, 392, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 513, 3, 210, 105, 0, 394,
		395, 5, 56, 0, 0, 395, 398, 5, 98, 0, 0, 396, 397, 5, 94, 0, 0, 397, 399,
		5, 65, 0, 0, 398, 396, 1, 0, 0, 0, 398, 399, 1, 0, 0, 0, 399, 400, 1, 0,
		0, 0, 400, 513, 3, 210, 105, 0, 401, 402, 5, 56, 0, 0, 402, 405, 5, 164,
		0, 0, 403, 404, 5, 94, 0, 0, 404, 406, 5, 65, 0, 0, 405, 403, 1, 0, 0,
		0, 405, 406, 1, 0, 0, 0, 406, 407, 1, 0, 0, 0, 407, 513, 3, 210, 105, 0,
		408, 409, 5, 56, 0, 0, 409, 513, 3, 14, 7, 0, 410, 412, 5, 80, 0, 0, 411,
		413, 3, 14, 7, 0, 412, 411, 1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 513,
		1, 0, 0, 0, 414, 415, 5, 124, 0, 0, 415, 418, 5, 98, 0, 0, 416, 417, 5,
		94, 0, 0, 417, 419, 5, 65, 0, 0, 418, 416, 1, 0, 0, 0, 418, 419, 1, 0,
		0, 0, 419, 420, 1, 0, 0, 0, 420, 423, 3, 210, 105, 0, 421, 422, 5, 97,
		0, 0, 422, 424, 3, 14, 7, 0, 423, 421, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0,
		424, 513, 1, 0, 0, 0, 425, 426, 5, 124, 0, 0, 426, 429, 5, 164, 0, 0, 427,
		428, 5, 94, 0, 0, 428, 430, 5, 65, 0, 0, 429, 427, 1, 0, 0, 0, 429, 430,
		1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 434, 3, 210, 105, 0, 432, 433, 5,
		97, 0, 0, 433, 435, 3, 14, 7, 0, 434, 432, 1, 0, 0, 0, 434, 435, 1, 0,
		0, 0, 435, 513, 1, 0, 0, 0, 436, 437, 5, 132, 0, 0, 437, 440, 5, 29, 0,
		0, 438, 439, 5, 94, 0, 0, 439, 441, 5, 65, 0, 0, 440, 438, 1, 0, 0, 0,
		440, 441, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 443, 3, 210, 105, 0, 443,
		444, 3, 74, 37, 0, 444, 513, 1, 0, 0, 0, 445, 446, 5, 132, 0, 0, 446, 449,
		5, 29, 0, 0, 447, 448, 5, 94, 0, 0, 448, 450, 5, 65, 0, 0, 449, 447, 1,
		0, 0, 0, 449, 450, 1, 0, 0, 0, 450, 451, 1, 0, 0, 0, 451, 452, 3, 210,
		105, 0, 452, 453, 5, 31, 0, 0, 453, 454, 3, 230, 115, 0, 454, 513, 1, 0,
		0, 0, 455, 456, 5, 132, 0, 0, 456, 459, 5, 29, 0, 0, 457, 458, 5, 94, 0,
		0, 458, 460, 5, 65, 0, 0, 459, 457, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460,
		461, 1, 0, 0, 0, 461, 462, 3, 210, 105, 0, 462, 463, 5, 171, 0, 0, 463,
		464, 3, 12, 6, 0, 464, 513, 1, 0, 0, 0, 465, 466, 5, 132, 0, 0, 466, 469,
		5, 29, 0, 0, 467, 468, 5, 94, 0, 0, 468, 470, 5, 65, 0, 0, 469, 467, 1,
		0, 0, 0, 469, 470, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0, 471, 513, 3, 66, 33,
		0, 472, 473, 5, 132, 0, 0, 473, 474, 5, 146, 0, 0, 474, 475, 5, 19, 0,
		0, 475, 513, 3, 200, 100, 0, 476, 477, 5, 132, 0, 0, 477, 513, 3, 60, 30,
		0, 478, 479, 5, 134, 0, 0, 479, 489, 3, 14, 7, 0, 480, 481, 5, 208, 0,
		0, 481, 482, 5, 53, 0, 0, 482, 490, 3, 230, 115, 0, 483, 484, 5, 208, 0,
		0, 484, 485, 5, 227, 0, 0, 485, 490, 3, 230, 115, 0, 486, 487, 5, 208,
		0, 0, 487, 488, 5, 200, 0, 0, 488, 490, 3, 218, 109, 0, 489, 480, 1, 0,
		0, 0, 489, 483, 1, 0, 0, 0, 489, 486, 1, 0, 0, 0, 490, 513, 1, 0, 0, 0,
		491, 492, 5, 171, 0, 0, 492, 513, 5, 215, 0, 0, 493, 494, 5, 172, 0, 0,
		494, 497, 5, 29, 0, 0, 495, 496, 5, 94, 0, 0, 496, 498, 5, 65, 0, 0, 497,
		495, 1, 0, 0, 0, 497, 498, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499, 500,
		3, 210, 105, 0, 500, 501, 5, 208, 0, 0, 501, 502, 3, 210, 105, 0, 502,
		513, 1, 0, 0, 0, 503, 504, 5, 173, 0, 0, 504, 505, 3, 14, 7, 0, 505, 506,
		5, 81, 0, 0, 506, 507, 3, 218, 109, 0, 507, 513, 1, 0, 0, 0, 508, 509,
		5, 219, 0, 0, 509, 510, 3, 8, 4, 0, 510, 511, 3, 130, 65, 0, 511, 513,
		1, 0, 0, 0, 512, 298, 1, 0, 0, 0, 512, 310, 1, 0, 0, 0, 512, 322, 1, 0,
		0, 0, 512, 334, 1, 0, 0, 0, 512, 340, 1, 0, 0, 0, 512, 351, 1, 0, 0, 0,
		512, 362, 1, 0, 0, 0, 512, 373, 1, 0, 0, 0, 512, 382, 1, 0, 0, 0, 512,
		385, 1, 0, 0, 0, 512, 387, 1, 0, 0, 0, 512, 394, 1, 0, 0, 0, 512, 401,
		1, 0, 0, 0, 512, 408, 1, 0, 0, 0, 512, 410, 1, 0, 0, 0, 512, 414, 1, 0,
		0, 0, 512, 425, 1, 0, 0, 0, 512, 436, 1, 0, 0, 0, 512, 445, 1, 0, 0, 0,
		512, 455, 1, 0, 0, 0, 512, 465, 1, 0, 0, 0, 512, 472, 1, 0, 0, 0, 512,
		476, 1, 0, 0, 0, 512, 478, 1, 0, 0, 0, 512, 491, 1, 0, 0, 0, 512, 493,
		1, 0, 0, 0, 512, 503, 1, 0, 0, 0, 512, 508, 1, 0, 0, 0, 513, 7, 1, 0, 0,
		0, 514, 519, 3, 10, 5, 0, 515, 516, 5, 252, 0, 0, 516, 518, 3, 10, 5, 0,
		517, 515, 1, 0, 0, 0, 518, 521, 1, 0, 0, 0, 519, 517, 1, 0, 0, 0, 519,
		520, 1, 0, 0, 0, 520, 9, 1, 0, 0, 0, 521, 519, 1, 0, 0, 0, 522, 523, 3,
		210, 105, 0, 523, 524, 5, 257, 0, 0, 524, 525, 3, 200, 100, 0, 525, 11,
		1, 0, 0, 0, 526, 527, 7, 0, 0, 0, 527, 13, 1, 0, 0, 0, 528, 529, 5, 151,
		0, 0, 529, 534, 3, 200, 100, 0, 530, 531, 5, 151, 0, 0, 531, 532, 5, 93,
		0, 0, 532, 534, 3, 230, 115, 0, 533, 528, 1, 0, 0, 0, 533, 530, 1, 0, 0,
		0, 534, 15, 1, 0, 0, 0, 535, 536, 5, 16, 0, 0, 536, 537, 5, 52, 0, 0, 537,
		539, 3, 218, 109, 0, 538, 540, 3, 42, 21, 0, 539, 538, 1, 0, 0, 0, 539,
		540, 1, 0, 0, 0, 540, 17, 1, 0, 0, 0, 541, 542, 5, 23, 0, 0, 542, 543,
		5, 200, 0, 0, 543, 545, 3, 218, 109, 0, 544, 546, 3, 14, 7, 0, 545, 544,
		1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 19, 1, 0, 0, 0, 547, 548, 7, 1,
		0, 0, 548, 552, 5, 39, 0, 0, 549, 550, 5, 94, 0, 0, 550, 551, 5, 139, 0,
		0, 551, 553, 5, 65, 0, 0, 552, 549, 1, 0, 0, 0, 552, 553, 1, 0, 0, 0, 553,
		554, 1, 0, 0, 0, 554, 556, 3, 224, 112, 0, 555, 557, 3, 42, 21, 0, 556,
		555, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 559, 1, 0, 0, 0, 558, 560,
		3, 62, 31, 0, 559, 558, 1, 0, 0, 0, 559, 560, 1, 0, 0, 0, 560, 701, 1,
		0, 0, 0, 561, 569, 5, 16, 0, 0, 562, 565, 5, 33, 0, 0, 563, 564, 5, 145,
		0, 0, 564, 566, 5, 173, 0, 0, 565, 563, 1, 0, 0, 0, 565, 566, 1, 0, 0,
		0, 566, 569, 1, 0, 0, 0, 567, 569, 5, 173, 0, 0, 568, 561, 1, 0, 0, 0,
		568, 562, 1, 0, 0, 0, 568, 567, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570,
		574, 5, 52, 0, 0, 571, 572, 5, 94, 0, 0, 572, 573, 5, 139, 0, 0, 573, 575,
		5, 65, 0, 0, 574, 571, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 576, 1, 0,
		0, 0, 576, 578, 3, 218, 109, 0, 577, 579, 3, 44, 22, 0, 578, 577, 1, 0,
		0, 0, 578, 579, 1, 0, 0, 0, 579, 581, 1, 0, 0, 0, 580, 582, 3, 42, 21,
		0, 581, 580, 1, 0, 0, 0, 581, 582, 1, 0, 0, 0, 582, 583, 1, 0, 0, 0, 583,
		584, 3, 22, 11, 0, 584, 585, 3, 26, 13, 0, 585, 701, 1, 0, 0, 0, 586, 587,
		7, 1, 0, 0, 587, 588, 5, 121, 0, 0, 588, 592, 5, 226, 0, 0, 589, 590, 5,
		94, 0, 0, 590, 591, 5, 139, 0, 0, 591, 593, 5, 65, 0, 0, 592, 589, 1, 0,
		0, 0, 592, 593, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 596, 3, 218, 109,
		0, 595, 597, 3, 44, 22, 0, 596, 595, 1, 0, 0, 0, 596, 597, 1, 0, 0, 0,
		597, 599, 1, 0, 0, 0, 598, 600, 3, 42, 21, 0, 599, 598, 1, 0, 0, 0, 599,
		600, 1, 0, 0, 0, 600, 606, 1, 0, 0, 0, 601, 602, 5, 233, 0, 0, 602, 604,
		5, 206, 0, 0, 603, 605, 5, 242, 0, 0, 604, 603, 1, 0, 0, 0, 604, 605, 1,
		0, 0, 0, 605, 607, 1, 0, 0, 0, 606, 601, 1, 0, 0, 0, 606, 607, 1, 0, 0,
		0, 607, 609, 1, 0, 0, 0, 608, 610, 3, 46, 23, 0, 609, 608, 1, 0, 0, 0,
		609, 610, 1, 0, 0, 0, 610, 612, 1, 0, 0, 0, 611, 613, 3, 50, 25, 0, 612,
		611, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614, 615,
		3, 48, 24, 0, 615, 701, 1, 0, 0, 0, 616, 617, 7, 1, 0, 0, 617, 618, 5,
		125, 0, 0, 618, 622, 5, 226, 0, 0, 619, 620, 5, 94, 0, 0, 620, 621, 5,
		139, 0, 0, 621, 623, 5, 65, 0, 0, 622, 619, 1, 0, 0, 0, 622, 623, 1, 0,
		0, 0, 623, 624, 1, 0, 0, 0, 624, 626, 3, 218, 109, 0, 625, 627, 3, 44,
		22, 0, 626, 625, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0, 627, 629, 1, 0, 0, 0,
		628, 630, 3, 42, 21, 0, 629, 628, 1, 0, 0, 0, 629, 630, 1, 0, 0, 0, 630,
		632, 1, 0, 0, 0, 631, 633, 3, 50, 25, 0, 632, 631, 1, 0, 0, 0, 632, 633,
		1, 0, 0, 0, 633, 639, 1, 0, 0, 0, 634, 640, 3, 46, 23, 0, 635, 637, 3,
		52, 26, 0, 636, 638, 5, 156, 0, 0, 637, 636, 1, 0, 0, 0, 637, 638, 1, 0,
		0, 0, 638, 640, 1, 0, 0, 0, 639, 634, 1, 0, 0, 0, 639, 635, 1, 0, 0, 0,
		640, 641, 1, 0, 0, 0, 641, 642, 3, 48, 24, 0, 642, 701, 1, 0, 0, 0, 643,
		651, 5, 16, 0, 0, 644, 647, 5, 33, 0, 0, 645, 646, 5, 145, 0, 0, 646, 648,
		5, 173, 0, 0, 647, 645, 1, 0, 0, 0, 647, 648, 1, 0, 0, 0, 648, 651, 1,
		0, 0, 0, 649, 651, 5, 173, 0, 0, 650, 643, 1, 0, 0, 0, 650, 644, 1, 0,
		0, 0, 650, 649, 1, 0, 0, 0, 651, 653, 1, 0, 0, 0, 652, 654, 5, 202, 0,
		0, 653, 652, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655,
		659, 5, 200, 0, 0, 656, 657, 5, 94, 0, 0, 657, 658, 5, 139, 0, 0, 658,
		660, 5, 65, 0, 0, 659, 656, 1, 0, 0, 0, 659, 660, 1, 0, 0, 0, 660, 661,
		1, 0, 0, 0, 661, 663, 3, 218, 109, 0, 662, 664, 3, 44, 22, 0, 663, 662,
		1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664, 666, 1, 0, 0, 0, 665, 667, 3, 42,
		21, 0, 666, 665, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 669, 1, 0, 0, 0,
		668, 670, 3, 50, 25, 0, 669, 668, 1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670,
		672, 1, 0, 0, 0, 671, 673, 3, 52, 26, 0, 672, 671, 1, 0, 0, 0, 672, 673,
		1, 0, 0, 0, 673, 675, 1, 0, 0, 0, 674, 676, 3, 48, 24, 0, 675, 674, 1,
		0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 701, 1, 0, 0, 0, 677, 680, 7, 1, 0,
		0, 678, 679, 5, 145, 0, 0, 679, 681, 5, 173, 0, 0, 680, 678, 1, 0, 0, 0,
		680, 681, 1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 686, 5, 226, 0, 0, 683,
		684, 5, 94, 0, 0, 684, 685, 5, 139, 0, 0, 685, 687, 5, 65, 0, 0, 686, 683,
		1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 690, 3, 218,
		109, 0, 689, 691, 3, 44, 22, 0, 690, 689, 1, 0, 0, 0, 690, 691, 1, 0, 0,
		0, 691, 693, 1, 0, 0, 0, 692, 694, 3, 42, 21, 0, 693, 692, 1, 0, 0, 0,
		693, 694, 1, 0, 0, 0, 694, 696, 1, 0, 0, 0, 695, 697, 3, 50, 25, 0, 696,
		695, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 698, 1, 0, 0, 0, 698, 699,
		3, 48, 24, 0, 699, 701, 1, 0, 0, 0, 700, 547, 1, 0, 0, 0, 700, 568, 1,
		0, 0, 0, 700, 586, 1, 0, 0, 0, 700, 616, 1, 0, 0, 0, 700, 650, 1, 0, 0,
		0, 700, 677, 1, 0, 0, 0, 701, 21, 1, 0, 0, 0, 702, 703, 5, 263, 0, 0, 703,
		708, 3, 24, 12, 0, 704, 705, 5, 252, 0, 0, 705, 707, 3, 24, 12, 0, 706,
		704, 1, 0, 0, 0, 707, 710, 1, 0, 0, 0, 708, 706, 1, 0, 0, 0, 708, 709,
		1, 0, 0, 0, 709, 711, 1, 0, 0, 0, 710, 708, 1, 0, 0, 0, 711, 712, 5, 273,
		0, 0, 712, 23, 1, 0, 0, 0, 713, 714, 6, 12, -1, 0, 714, 715, 3, 242, 121,
		0, 715, 737, 3, 194, 97, 0, 716, 717, 4, 12, 0, 1, 717, 718, 5, 44, 0,
		0, 718, 719, 3, 232, 116, 0, 719, 720, 6, 12, -1, 0, 720, 736, 1, 0, 0,
		0, 721, 722, 4, 12, 1, 1, 722, 723, 5, 67, 0, 0, 723, 724, 3, 200, 100,
		0, 724, 725, 6, 12, -1, 0, 725, 736, 1, 0, 0, 0, 726, 727, 4, 12, 2, 1,
		727, 728, 5, 91, 0, 0, 728, 736, 6, 12, -1, 0, 729, 730, 4, 12, 3, 1, 730,
		731, 5, 102, 0, 0, 731, 736, 6, 12, -1, 0, 732, 733, 4, 12, 4, 1, 733,
		734, 5, 109, 0, 0, 734, 736, 6, 12, -1, 0, 735, 716, 1, 0, 0, 0, 735, 721,
		1, 0, 0, 0, 735, 726, 1, 0, 0, 0, 735, 729, 1, 0, 0, 0, 735, 732, 1, 0,
		0, 0, 736, 739, 1, 0, 0, 0, 737, 735, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0,
		738, 25, 1, 0, 0, 0, 739, 737, 1, 0, 0, 0, 740, 742, 6, 13, -1, 0, 741,
		743, 3, 28, 14, 0, 742, 741, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 766,
		1, 0, 0, 0, 744, 745, 4, 13, 5, 1, 745, 746, 3, 32, 16, 0, 746, 747, 6,
		13, -1, 0, 747, 765, 1, 0, 0, 0, 748, 749, 4, 13, 6, 1, 749, 750, 3, 34,
		17, 0, 750, 751, 6, 13, -1, 0, 751, 765, 1, 0, 0, 0, 752, 753, 4, 13, 7,
		1, 753, 754, 3, 36, 18, 0, 754, 755, 6, 13, -1, 0, 755, 765, 1, 0, 0, 0,
		756, 757, 4, 13, 8, 1, 757, 758, 3, 38, 19, 0, 758, 759, 6, 13, -1, 0,
		759, 765, 1, 0, 0, 0, 760, 761, 4, 13, 9, 1, 761, 762, 3, 40, 20, 0, 762,
		763, 6, 13, -1, 0, 763, 765, 1, 0, 0, 0, 764, 744, 1, 0, 0, 0, 764, 748,
		1, 0, 0, 0, 764, 752, 1, 0, 0, 0, 764, 756, 1, 0, 0, 0, 764, 760, 1, 0,
		0, 0, 765, 768, 1, 0, 0, 0, 766, 764, 1, 0, 0, 0, 766, 767, 1, 0, 0, 0,
		767, 27, 1, 0, 0, 0, 768, 766, 1, 0, 0, 0, 769, 770, 5, 159, 0, 0, 770,
		771, 5, 111, 0, 0, 771, 772, 3, 196, 98, 0, 772, 29, 1, 0, 0, 0, 773, 780,
		3, 242, 121, 0, 774, 777, 3, 242, 121, 0, 775, 776, 5, 263, 0, 0, 776,
		778, 5, 273, 0, 0, 777, 775, 1, 0, 0, 0, 777, 778, 1, 0, 0, 0, 778, 781,
		1, 0, 0, 0, 779, 781, 3, 232, 116, 0, 780, 774, 1, 0, 0, 0, 780, 779, 1,
		0, 0, 0, 781, 31, 1, 0, 0, 0, 782, 783, 5, 192, 0, 0, 783, 784, 5, 263,
		0, 0, 784, 785, 3, 242, 121, 0, 785, 789, 5, 263, 0, 0, 786, 788, 3, 30,
		15, 0, 787, 786, 1, 0, 0, 0, 788, 791, 1, 0, 0, 0, 789, 787, 1, 0, 0, 0,
		789, 790, 1, 0, 0, 0, 790, 792, 1, 0, 0, 0, 791, 789, 1, 0, 0, 0, 792,
		793, 5, 273, 0, 0, 793, 794, 5, 273, 0, 0, 794, 33, 1, 0, 0, 0, 795, 796,
		5, 118, 0, 0, 796, 806, 5, 263, 0, 0, 797, 807, 5, 242, 0, 0, 798, 799,
		5, 130, 0, 0, 799, 800, 5, 242, 0, 0, 800, 801, 5, 126, 0, 0, 801, 807,
		5, 242, 0, 0, 802, 803, 5, 126, 0, 0, 803, 804, 5, 242, 0, 0, 804, 805,
		5, 130, 0, 0, 805, 807, 5, 242, 0, 0, 806, 797, 1, 0, 0, 0, 806, 798, 1,
		0, 0, 0, 806, 802, 1, 0, 0, 0, 807, 808, 1, 0, 0, 0, 808, 809, 5, 273,
		0, 0, 809, 35, 1, 0, 0, 0, 810, 811, 5, 115, 0, 0, 811, 812, 5, 263, 0,
		0, 812, 813, 3, 242, 121, 0, 813, 817, 5, 263, 0, 0, 814, 816, 3, 30, 15,
		0, 815, 814, 1, 0, 0, 0, 816, 819, 1, 0, 0, 0, 817, 815, 1, 0, 0, 0, 817,
		818, 1, 0, 0, 0, 818, 820, 1, 0, 0, 0, 819, 817, 1, 0, 0, 0, 820, 821,
		5, 273, 0, 0, 821, 822, 5, 273, 0, 0, 822, 37, 1, 0, 0, 0, 823, 824, 5,
		168, 0, 0, 824, 835, 5, 263, 0, 0, 825, 826, 5, 130, 0, 0, 826, 827, 3,
		242, 121, 0, 827, 828, 5, 126, 0, 0, 828, 829, 3, 242, 121, 0, 829, 836,
		1, 0, 0, 0, 830, 831, 5, 126, 0, 0, 831, 832, 3, 242, 121, 0, 832, 833,
		5, 130, 0, 0, 833, 834, 3, 242, 121, 0, 834, 836, 1, 0, 0, 0, 835, 825,
		1, 0, 0, 0, 835, 830, 1, 0, 0, 0, 836, 837, 1, 0, 0, 0, 837, 838, 5, 273,
		0, 0, 838, 39, 1, 0, 0, 0, 839, 840, 5, 190, 0, 0, 840, 841, 5, 263, 0,
		0, 841, 842, 3, 166, 83, 0, 842, 843, 5, 273, 0, 0, 843, 41, 1, 0, 0, 0,
		844, 845, 5, 143, 0, 0, 845, 848, 5, 25, 0, 0, 846, 849, 3, 242, 121, 0,
		847, 849, 3, 230, 115, 0, 848, 846, 1, 0, 0, 0, 848, 847, 1, 0, 0, 0, 849,
		43, 1, 0, 0, 0, 850, 851, 5, 224, 0, 0, 851, 852, 3, 230, 115, 0, 852,
		45, 1, 0, 0, 0, 853, 854, 5, 208, 0, 0, 854, 855, 3, 218, 109, 0, 855,
		47, 1, 0, 0, 0, 856, 857, 5, 11, 0, 0, 857, 858, 3, 108, 54, 0, 858, 49,
		1, 0, 0, 0, 859, 860, 5, 263, 0, 0, 860, 865, 3, 64, 32, 0, 861, 862, 5,
		252, 0, 0, 862, 864, 3, 64, 32, 0, 863, 861, 1, 0, 0, 0, 864, 867, 1, 0,
		0, 0, 865, 863, 1, 0, 0, 0, 865, 866, 1, 0, 0, 0, 866, 868, 1, 0, 0, 0,
		867, 865, 1, 0, 0, 0, 868, 869, 5, 273, 0, 0, 869, 875, 1, 0, 0, 0, 870,
		871, 5, 11, 0, 0, 871, 875, 3, 218, 109, 0, 872, 873, 5, 11, 0, 0, 873,
		875, 3, 216, 108, 0, 874, 859, 1, 0, 0, 0, 874, 870, 1, 0, 0, 0, 874, 872,
		1, 0, 0, 0, 875, 51, 1, 0, 0, 0, 876, 877, 6, 26, -1, 0, 877, 904, 3, 62,
		31, 0, 878, 879, 4, 26, 10, 1, 879, 880, 3, 136, 68, 0, 880, 881, 6, 26,
		-1, 0, 881, 903, 1, 0, 0, 0, 882, 883, 4, 26, 11, 1, 883, 884, 3, 54, 27,
		0, 884, 885, 6, 26, -1, 0, 885, 903, 1, 0, 0, 0, 886, 887, 4, 26, 12, 1,
		887, 888, 3, 56, 28, 0, 888, 889, 6, 26, -1, 0, 889, 903, 1, 0, 0, 0, 890,
		891, 4, 26, 13, 1, 891, 892, 3, 58, 29, 0, 892, 893, 6, 26, -1, 0, 893,
		903, 1, 0, 0, 0, 894, 895, 4, 26, 14, 1, 895, 896, 3, 60, 30, 0, 896, 897,
		6, 26, -1, 0, 897, 903, 1, 0, 0, 0, 898, 899, 4, 26, 15, 1, 899, 900, 3,
		146, 73, 0, 900, 901, 6, 26, -1, 0, 901, 903, 1, 0, 0, 0, 902, 878, 1,
		0, 0, 0, 902, 882, 1, 0, 0, 0, 902, 886, 1, 0, 0, 0, 902, 890, 1, 0, 0,
		0, 902, 894, 1, 0, 0, 0, 902, 898, 1, 0, 0, 0, 903, 906, 1, 0, 0, 0, 904,
		902, 1, 0, 0, 0, 904, 905, 1, 0, 0, 0, 905, 53, 1, 0, 0, 0, 906, 904, 1,
		0, 0, 0, 907, 908, 5, 151, 0, 0, 908, 909, 5, 19, 0, 0, 909, 910, 3, 200,
		100, 0, 910, 55, 1, 0, 0, 0, 911, 912, 5, 159, 0, 0, 912, 913, 5, 111,
		0, 0, 913, 914, 3, 200, 100, 0, 914, 57, 1, 0, 0, 0, 915, 916, 5, 182,
		0, 0, 916, 917, 5, 19, 0, 0, 917, 918, 3, 200, 100, 0, 918, 59, 1, 0, 0,
		0, 919, 920, 5, 215, 0, 0, 920, 925, 3, 78, 39, 0, 921, 922, 5, 252, 0,
		0, 922, 924, 3, 78, 39, 0, 923, 921, 1, 0, 0, 0, 924, 927, 1, 0, 0, 0,
		925, 923, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 61, 1, 0, 0, 0, 927, 925,
		1, 0, 0, 0, 928, 930, 5, 60, 0, 0, 929, 931, 5, 257, 0, 0, 930, 929, 1,
		0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 932, 1, 0, 0, 0, 932, 938, 3, 244,
		122, 0, 933, 935, 5, 263, 0, 0, 934, 936, 3, 196, 98, 0, 935, 934, 1, 0,
		0, 0, 935, 936, 1, 0, 0, 0, 936, 937, 1, 0, 0, 0, 937, 939, 5, 273, 0,
		0, 938, 933, 1, 0, 0, 0, 938, 939, 1, 0, 0, 0, 939, 63, 1, 0, 0, 0, 940,
		951, 3, 66, 33, 0, 941, 942, 5, 32, 0, 0, 942, 943, 3, 242, 121, 0, 943,
		944, 5, 23, 0, 0, 944, 945, 3, 200, 100, 0, 945, 951, 1, 0, 0, 0, 946,
		947, 5, 98, 0, 0, 947, 951, 3, 70, 35, 0, 948, 949, 5, 164, 0, 0, 949,
		951, 3, 72, 36, 0, 950, 940, 1, 0, 0, 0, 950, 941, 1, 0, 0, 0, 950, 946,
		1, 0, 0, 0, 950, 948, 1, 0, 0, 0, 951, 65, 1, 0, 0, 0, 952, 953, 3, 210,
		105, 0, 953, 955, 3, 194, 97, 0, 954, 956, 3, 68, 34, 0, 955, 954, 1, 0,
		0, 0, 955, 956, 1, 0, 0, 0, 956, 959, 1, 0, 0, 0, 957, 958, 5, 31, 0, 0,
		958, 960, 3, 230, 115, 0, 959, 957, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960,
		962, 1, 0, 0, 0, 961, 963, 3, 74, 37, 0, 962, 961, 1, 0, 0, 0, 962, 963,
		1, 0, 0, 0, 963, 966, 1, 0, 0, 0, 964, 965, 5, 215, 0, 0, 965, 967, 3,
		200, 100, 0, 966, 964, 1, 0, 0, 0, 966, 967, 1, 0, 0, 0, 967, 985, 1, 0,
		0, 0, 968, 970, 3, 210, 105, 0, 969, 971, 3, 194, 97, 0, 970, 969, 1, 0,
		0, 0, 970, 971, 1, 0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 975, 3, 68, 34,
		0, 973, 974, 5, 31, 0, 0, 974, 976, 3, 230, 115, 0, 975, 973, 1, 0, 0,
		0, 975, 976, 1, 0, 0, 0, 976, 978, 1, 0, 0, 0, 977, 979, 3, 74, 37, 0,
		978, 977, 1, 0, 0, 0, 978, 979, 1, 0, 0, 0, 979, 982, 1, 0, 0, 0, 980,
		981, 5, 215, 0, 0, 981, 983, 3, 200, 100, 0, 982, 980, 1, 0, 0, 0, 982,
		983, 1, 0, 0, 0, 983, 985, 1, 0, 0, 0, 984, 952, 1, 0, 0, 0, 984, 968,
		1, 0, 0, 0, 985, 67, 1, 0, 0, 0, 986, 987, 7, 2, 0, 0, 987, 988, 3, 200,
		100, 0, 988, 69, 1, 0, 0, 0, 989, 990, 3, 210, 105, 0, 990, 991, 3, 200,
		100, 0, 991, 992, 5, 216, 0, 0, 992, 993, 3, 194, 97, 0, 993, 994, 5, 86,
		0, 0, 994, 995, 5, 242, 0, 0, 995, 71, 1, 0, 0, 0, 996, 997, 3, 210, 105,
		0, 997, 998, 3, 106, 53, 0, 998, 73, 1, 0, 0, 0, 999, 1000, 5, 27, 0, 0,
		1000, 1001, 5, 263, 0, 0, 1001, 1006, 3, 76, 38, 0, 1002, 1003, 5, 252,
		0, 0, 1003, 1005, 3, 76, 38, 0, 1004, 1002, 1, 0, 0, 0, 1005, 1008, 1,
		0, 0, 0, 1006, 1004, 1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 1009, 1,
		0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1009, 1010, 5, 273, 0, 0, 1010, 75, 1,
		0, 0, 0, 1011, 1017, 3, 242, 121, 0, 1012, 1014, 5, 263, 0, 0, 1013, 1015,
		3, 196, 98, 0, 1014, 1013, 1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015, 1016,
		1, 0, 0, 0, 1016, 1018, 5, 273, 0, 0, 1017, 1012, 1, 0, 0, 0, 1017, 1018,
		1, 0, 0, 0, 1018, 77, 1, 0, 0, 0, 1019, 1030, 3, 200, 100, 0, 1020, 1022,
		5, 46, 0, 0, 1021, 1023, 3, 130, 65, 0, 1022, 1021, 1, 0, 0, 0, 1022, 1023,
		1, 0, 0, 0, 1023, 1031, 1, 0, 0, 0, 1024, 1025, 5, 208, 0, 0, 1025, 1026,
		5, 53, 0, 0, 1026, 1031, 3, 230, 115, 0, 1027, 1028, 5, 208, 0, 0, 1028,
		1029, 5, 227, 0, 0, 1029, 1031, 3, 230, 115, 0, 1030, 1020, 1, 0, 0, 0,
		1030, 1024, 1, 0, 0, 0, 1030, 1027, 1, 0, 0, 0, 1030, 1031, 1, 0, 0, 0,
		1031, 1044, 1, 0, 0, 0, 1032, 1033, 3, 200, 100, 0, 1033, 1034, 3, 132,
		66, 0, 1034, 1035, 5, 187, 0, 0, 1035, 1040, 3, 80, 40, 0, 1036, 1037,
		5, 252, 0, 0, 1037, 1039, 3, 80, 40, 0, 1038, 1036, 1, 0, 0, 0, 1039, 1042,
		1, 0, 0, 0, 1040, 1038, 1, 0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1044,
		1, 0, 0, 0, 1042, 1040, 1, 0, 0, 0, 1043, 1019, 1, 0, 0, 0, 1043, 1032,
		1, 0, 0, 0, 1044, 79, 1, 0, 0, 0, 1045, 1046, 3, 200, 100, 0, 1046, 1047,
		5, 257, 0, 0, 1047, 1048, 3, 200, 100, 0, 1048, 81, 1, 0, 0, 0, 1049, 1051,
		7, 3, 0, 0, 1050, 1052, 5, 200, 0, 0, 1051, 1050, 1, 0, 0, 0, 1051, 1052,
		1, 0, 0, 0, 1052, 1053, 1, 0, 0, 0, 1053, 1054, 3, 214, 107, 0, 1054, 83,
		1, 0, 0, 0, 1055, 1056, 7, 4, 0, 0, 1056, 1059, 5, 39, 0, 0, 1057, 1058,
		5, 94, 0, 0, 1058, 1060, 5, 65, 0, 0, 1059, 1057, 1, 0, 0, 0, 1059, 1060,
		1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 1063, 3, 224, 112, 0, 1062, 1064,
		3, 42, 21, 0, 1063, 1062, 1, 0, 0, 0, 1063, 1064, 1, 0, 0, 0, 1064, 1087,
		1, 0, 0, 0, 1065, 1072, 7, 4, 0, 0, 1066, 1073, 5, 52, 0, 0, 1067, 1069,
		5, 202, 0, 0, 1068, 1067, 1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069, 1070,
		1, 0, 0, 0, 1070, 1073, 5, 200, 0, 0, 1071, 1073, 5, 226, 0, 0, 1072, 1066,
		1, 0, 0, 0, 1072, 1068, 1, 0, 0, 0, 1072, 1071, 1, 0, 0, 0, 1073, 1076,
		1, 0, 0, 0, 1074, 1075, 5, 94, 0, 0, 1075, 1077, 5, 65, 0, 0, 1076, 1074,
		1, 0, 0, 0, 1076, 1077, 1, 0, 0, 0, 1077, 1078, 1, 0, 0, 0, 1078, 1080,
		3, 218, 109, 0, 1079, 1081, 3, 42, 21, 0, 1080, 1079, 1, 0, 0, 0, 1080,
		1081, 1, 0, 0, 0, 1081, 1084, 1, 0, 0, 0, 1082, 1083, 5, 138, 0, 0, 1083,
		1085, 5, 45, 0, 0, 1084, 1082, 1, 0, 0, 0, 1084, 1085, 1, 0, 0, 0, 1085,
		1087, 1, 0, 0, 0, 1086, 1055, 1, 0, 0, 0, 1086, 1065, 1, 0, 0, 0, 1087,
		85, 1, 0, 0, 0, 1088, 1089, 5, 65, 0, 0, 1089, 1090, 5, 39, 0, 0, 1090,
		1102, 3, 224, 112, 0, 1091, 1098, 5, 65, 0, 0, 1092, 1099, 5, 52, 0, 0,
		1093, 1095, 5, 202, 0, 0, 1094, 1093, 1, 0, 0, 0, 1094, 1095, 1, 0, 0,
		0, 1095, 1096, 1, 0, 0, 0, 1096, 1099, 5, 200, 0, 0, 1097, 1099, 5, 226,
		0, 0, 1098, 1092, 1, 0, 0, 0, 1098, 1094, 1, 0, 0, 0, 1098, 1097, 1, 0,
		0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 1100, 1, 0, 0, 0, 1100, 1102, 3, 218,
		109, 0, 1101, 1088, 1, 0, 0, 0, 1101, 1091, 1, 0, 0, 0, 1102, 87, 1, 0,
		0, 0, 1103, 1113, 5, 66, 0, 0, 1104, 1114, 5, 14, 0, 0, 1105, 1114, 5,
		197, 0, 0, 1106, 1107, 5, 268, 0, 0, 1107, 1114, 5, 212, 0, 0, 1108, 1114,
		5, 153, 0, 0, 1109, 1114, 5, 152, 0, 0, 1110, 1114, 5, 62, 0, 0, 1111,
		1112, 5, 200, 0, 0, 1112, 1114, 5, 150, 0, 0, 1113, 1104, 1, 0, 0, 0, 1113,
		1105, 1, 0, 0, 0, 1113, 1106, 1, 0, 0, 0, 1113, 1108, 1, 0, 0, 0, 1113,
		1109, 1, 0, 0, 0, 1113, 1110, 1, 0, 0, 0, 1113, 1111, 1, 0, 0, 0, 1113,
		1114, 1, 0, 0, 0, 1114, 1116, 1, 0, 0, 0, 1115, 1117, 3, 166, 83, 0, 1116,
		1115, 1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0, 1117, 1118, 1, 0, 0, 0, 1118,
		1119, 3, 108, 54, 0, 1119, 89, 1, 0, 0, 0, 1120, 1121, 5, 104, 0, 0, 1121,
		1123, 5, 107, 0, 0, 1122, 1124, 5, 200, 0, 0, 1123, 1122, 1, 0, 0, 0, 1123,
		1124, 1, 0, 0, 0, 1124, 1128, 1, 0, 0, 0, 1125, 1129, 3, 218, 109, 0, 1126,
		1127, 5, 83, 0, 0, 1127, 1129, 3, 216, 108, 0, 1128, 1125, 1, 0, 0, 0,
		1128, 1126, 1, 0, 0, 0, 1129, 1131, 1, 0, 0, 0, 1130, 1132, 3, 92, 46,
		0, 1131, 1130, 1, 0, 0, 0, 1131, 1132, 1, 0, 0, 0, 1132, 1133, 1, 0, 0,
		0, 1133, 1134, 3, 94, 47, 0, 1134, 91, 1, 0, 0, 0, 1135, 1136, 5, 263,
		0, 0, 1136, 1141, 3, 210, 105, 0, 1137, 1138, 5, 252, 0, 0, 1138, 1140,
		3, 210, 105, 0, 1139, 1137, 1, 0, 0, 0, 1140, 1143, 1, 0, 0, 0, 1141, 1139,
		1, 0, 0, 0, 1141, 1142, 1, 0, 0, 0, 1142, 1144, 1, 0, 0, 0, 1143, 1141,
		1, 0, 0, 0, 1144, 1145, 5, 273, 0, 0, 1145, 93, 1, 0, 0, 0, 1146, 1147,
		5, 79, 0, 0, 1147, 1164, 3, 242, 121, 0, 1148, 1149, 5, 225, 0, 0, 1149,
		1154, 3, 96, 48, 0, 1150, 1151, 5, 252, 0, 0, 1151, 1153, 3, 96, 48, 0,
		1152, 1150, 1, 0, 0, 0, 1153, 1156, 1, 0, 0, 0, 1154, 1152, 1, 0, 0, 0,
		1154, 1155, 1, 0, 0, 0, 1155, 1164, 1, 0, 0, 0, 1156, 1154, 1, 0, 0, 0,
		1157, 1159, 3, 108, 54, 0, 1158, 1160, 5, 274, 0, 0, 1159, 1158, 1, 0,
		0, 0, 1159, 1160, 1, 0, 0, 0, 1160, 1161, 1, 0, 0, 0, 1161, 1162, 5, 0,
		0, 1, 1162, 1164, 1, 0, 0, 0, 1163, 1146, 1, 0, 0, 0, 1163, 1148, 1, 0,
		0, 0, 1163, 1157, 1, 0, 0, 0, 1164, 95, 1, 0, 0, 0, 1165, 1166, 5, 263,
		0, 0, 1166, 1171, 3, 98, 49, 0, 1167, 1168, 5, 252, 0, 0, 1168, 1170, 3,
		98, 49, 0, 1169, 1167, 1, 0, 0, 0, 1170, 1173, 1, 0, 0, 0, 1171, 1169,
		1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1174, 1, 0, 0, 0, 1173, 1171,
		1, 0, 0, 0, 1174, 1175, 5, 273, 0, 0, 1175, 1179, 1, 0, 0, 0, 1176, 1177,
		5, 263, 0, 0, 1177, 1179, 5, 273, 0, 0, 1178, 1165, 1, 0, 0, 0, 1178, 1176,
		1, 0, 0, 0, 1179, 97, 1, 0, 0, 0, 1180, 1181, 3, 232, 116, 0, 1181, 99,
		1, 0, 0, 0, 1182, 1183, 5, 113, 0, 0, 1183, 1185, 5, 135, 0, 0, 1184, 1186,
		3, 42, 21, 0, 1185, 1184, 1, 0, 0, 0, 1185, 1186, 1, 0, 0, 0, 1186, 1187,
		1, 0, 0, 0, 1187, 1189, 3, 130, 65, 0, 1188, 1190, 7, 5, 0, 0, 1189, 1188,
		1, 0, 0, 0, 1189, 1190, 1, 0, 0, 0, 1190, 101, 1, 0, 0, 0, 1191, 1192,
		5, 144, 0, 0, 1192, 1193, 5, 200, 0, 0, 1193, 1195, 3, 218, 109, 0, 1194,
		1196, 3, 42, 21, 0, 1195, 1194, 1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196,
		1198, 1, 0, 0, 0, 1197, 1199, 3, 14, 7, 0, 1198, 1197, 1, 0, 0, 0, 1198,
		1199, 1, 0, 0, 0, 1199, 1201, 1, 0, 0, 0, 1200, 1202, 5, 74, 0, 0, 1201,
		1200, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 1204, 1, 0, 0, 0, 1203,
		1205, 5, 43, 0, 0, 1204, 1203, 1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205,
		103, 1, 0, 0, 0, 1206, 1207, 5, 172, 0, 0, 1207, 1208, 5, 200, 0, 0, 1208,
		1209, 3, 218, 109, 0, 1209, 1210, 5, 208, 0, 0, 1210, 1218, 3, 218, 109,
		0, 1211, 1212, 5, 252, 0, 0, 1212, 1213, 3, 218, 109, 0, 1213, 1214, 5,
		208, 0, 0, 1214, 1215, 3, 218, 109, 0, 1215, 1217, 1, 0, 0, 0, 1216, 1211,
		1, 0, 0, 0, 1217, 1220, 1, 0, 0, 0, 1218, 1216, 1, 0, 0, 0, 1218, 1219,
		1, 0, 0, 0, 1219, 1222, 1, 0, 0, 0, 1220, 1218, 1, 0, 0, 0, 1221, 1223,
		3, 42, 21, 0, 1222, 1221, 1, 0, 0, 0, 1222, 1223, 1, 0, 0, 0, 1223, 105,
		1, 0, 0, 0, 1224, 1226, 5, 263, 0, 0, 1225, 1227, 3, 114, 57, 0, 1226,
		1225, 1, 0, 0, 0, 1226, 1227, 1, 0, 0, 0, 1227, 1228, 1, 0, 0, 0, 1228,
		1229, 5, 184, 0, 0, 1229, 1231, 3, 196, 98, 0, 1230, 1232, 3, 132, 66,
		0, 1231, 1230, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 1234, 1, 0, 0,
		0, 1233, 1235, 3, 140, 70, 0, 1234, 1233, 1, 0, 0, 0, 1234, 1235, 1, 0,
		0, 0, 1235, 1236, 1, 0, 0, 0, 1236, 1237, 5, 273, 0, 0, 1237, 107, 1, 0,
		0, 0, 1238, 1244, 3, 110, 55, 0, 1239, 1240, 5, 218, 0, 0, 1240, 1241,
		7, 6, 0, 0, 1241, 1243, 3, 110, 55, 0, 1242, 1239, 1, 0, 0, 0, 1243, 1246,
		1, 0, 0, 0, 1244, 1242, 1, 0, 0, 0, 1244, 1245, 1, 0, 0, 0, 1245, 109,
		1, 0, 0, 0, 1246, 1244, 1, 0, 0, 0, 1247, 1253, 3, 112, 56, 0, 1248, 1249,
		5, 263, 0, 0, 1249, 1250, 3, 108, 54, 0, 1250, 1251, 5, 273, 0, 0, 1251,
		1253, 1, 0, 0, 0, 1252, 1247, 1, 0, 0, 0, 1252, 1248, 1, 0, 0, 0, 1253,
		111, 1, 0, 0, 0, 1254, 1256, 3, 114, 57, 0, 1255, 1254, 1, 0, 0, 0, 1255,
		1256, 1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 1259, 5, 184, 0, 0, 1258,
		1260, 5, 54, 0, 0, 1259, 1258, 1, 0, 0, 0, 1259, 1260, 1, 0, 0, 0, 1260,
		1262, 1, 0, 0, 0, 1261, 1263, 3, 120, 60, 0, 1262, 1261, 1, 0, 0, 0, 1262,
		1263, 1, 0, 0, 0, 1263, 1264, 1, 0, 0, 0, 1264, 1266, 3, 196, 98, 0, 1265,
		1267, 3, 122, 61, 0, 1266, 1265, 1, 0, 0, 0, 1266, 1267, 1, 0, 0, 0, 1267,
		1269, 1, 0, 0, 0, 1268, 1270, 3, 124, 62, 0, 1269, 1268, 1, 0, 0, 0, 1269,
		1270, 1, 0, 0, 0, 1270, 1272, 1, 0, 0, 0, 1271, 1273, 3, 126, 63, 0, 1272,
		1271, 1, 0, 0, 0, 1272, 1273, 1, 0, 0, 0, 1273, 1275, 1, 0, 0, 0, 1274,
		1276, 3, 128, 64, 0, 1275, 1274, 1, 0, 0, 0, 1275, 1276, 1, 0, 0, 0, 1276,
		1278, 1, 0, 0, 0, 1277, 1279, 3, 130, 65, 0, 1278, 1277, 1, 0, 0, 0, 1278,
		1279, 1, 0, 0, 0, 1279, 1281, 1, 0, 0, 0, 1280, 1282, 3, 132, 66, 0, 1281,
		1280, 1, 0, 0, 0, 1281, 1282, 1, 0, 0, 0, 1282, 1285, 1, 0, 0, 0, 1283,
		1284, 5, 233, 0, 0, 1284, 1286, 7, 7, 0, 0, 1285, 1283, 1, 0, 0, 0, 1285,
		1286, 1, 0, 0, 0, 1286, 1289, 1, 0, 0, 0, 1287, 1288, 5, 233, 0, 0, 1288,
		1290, 5, 210, 0, 0, 1289, 1287, 1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290,
		1292, 1, 0, 0, 0, 1291, 1293, 3, 134, 67, 0, 1292, 1291, 1, 0, 0, 0, 1292,
		1293, 1, 0, 0, 0, 1293, 1295, 1, 0, 0, 0, 1294, 1296, 3, 136, 68, 0, 1295,
		1294, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296, 1298, 1, 0, 0, 0, 1297,
		1299, 3, 138, 69, 0, 1298, 1297, 1, 0, 0, 0, 1298, 1299, 1, 0, 0, 0, 1299,
		1301, 1, 0, 0, 0, 1300, 1302, 3, 142, 71, 0, 1301, 1300, 1, 0, 0, 0, 1301,
		1302, 1, 0, 0, 0, 1302, 1304, 1, 0, 0, 0, 1303, 1305, 3, 144, 72, 0, 1304,
		1303, 1, 0, 0, 0, 1304, 1305, 1, 0, 0, 0, 1305, 1307, 1, 0, 0, 0, 1306,
		1308, 3, 146, 73, 0, 1307, 1306, 1, 0, 0, 0, 1307, 1308, 1, 0, 0, 0, 1308,
		113, 1, 0, 0, 0, 1309, 1310, 5, 233, 0, 0, 1310, 1311, 3, 116, 58, 0, 1311,
		115, 1, 0, 0, 0, 1312, 1317, 3, 118, 59, 0, 1313, 1314, 5, 252, 0, 0, 1314,
		1316, 3, 118, 59, 0, 1315, 1313, 1, 0, 0, 0, 1316, 1319, 1, 0, 0, 0, 1317,
		1315, 1, 0, 0, 0, 1317, 1318, 1, 0, 0, 0, 1318, 117, 1, 0, 0, 0, 1319,
		1317, 1, 0, 0, 0, 1320, 1322, 5, 169, 0, 0, 1321, 1320, 1, 0, 0, 0, 1321,
		1322, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1324, 3, 242, 121, 0, 1324,
		1325, 5, 11, 0, 0, 1325, 1326, 5, 263, 0, 0, 1326, 1327, 3, 108, 54, 0,
		1327, 1328, 5, 273, 0, 0, 1328, 1334, 1, 0, 0, 0, 1329, 1330, 3, 200, 100,
		0, 1330, 1331, 5, 11, 0, 0, 1331, 1332, 3, 242, 121, 0, 1332, 1334, 1,
		0, 0, 0, 1333, 1321, 1, 0, 0, 0, 1333, 1329, 1, 0, 0, 0, 1334, 119, 1,
		0, 0, 0, 1335, 1336, 5, 209, 0, 0, 1336, 1339, 5, 242, 0, 0, 1337, 1338,
		5, 233, 0, 0, 1338, 1340, 5, 205, 0, 0, 1339, 1337, 1, 0, 0, 0, 1339, 1340,
		1, 0, 0, 0, 1340, 121, 1, 0, 0, 0, 1341, 1342, 5, 81, 0, 0, 1342, 1343,
		3, 148, 74, 0, 1343, 123, 1, 0, 0, 0, 1344, 1346, 7, 8, 0, 0, 1345, 1344,
		1, 0, 0, 0, 1345, 1346, 1, 0, 0, 0, 1346, 1347, 1, 0, 0, 0, 1347, 1348,
		5, 10, 0, 0, 1348, 1349, 5, 110, 0, 0, 1349, 1350, 3, 196, 98, 0, 1350,
		125, 1, 0, 0, 0, 1351, 1352, 5, 232, 0, 0, 1352, 1353, 3, 242, 121, 0,
		1353, 1354, 5, 11, 0, 0, 1354, 1355, 5, 263, 0, 0, 1355, 1356, 3, 170,
		85, 0, 1356, 1357, 5, 273, 0, 0, 1357, 127, 1, 0, 0, 0, 1358, 1359, 5,
		158, 0, 0, 1359, 1360, 3, 200, 100, 0, 1360, 129, 1, 0, 0, 0, 1361, 1362,
		5, 231, 0, 0, 1362, 1363, 3, 200, 100, 0, 1363, 131, 1, 0, 0, 0, 1364,
		1365, 5, 88, 0, 0, 1365, 1366, 5, 19, 0, 0, 1366, 1386, 5, 5, 0, 0, 1367,
		1368, 5, 88, 0, 0, 1368, 1369, 5, 19, 0, 0, 1369, 1370, 7, 7, 0, 0, 1370,
		1371, 5, 263, 0, 0, 1371, 1372, 3, 196, 98, 0, 1372, 1373, 5, 273, 0, 0,
		1373, 1386, 1, 0, 0, 0, 1374, 1375, 5, 88, 0, 0, 1375, 1376, 5, 19, 0,
		0, 1376, 1377, 5, 89, 0, 0, 1377, 1378, 5, 188, 0, 0, 1378, 1379, 5, 263,
		0, 0, 1379, 1380, 3, 196, 98, 0, 1380, 1381, 5, 273, 0, 0, 1381, 1386,
		1, 0, 0, 0, 1382, 1383, 5, 88, 0, 0, 1383, 1384, 5, 19, 0, 0, 1384, 1386,
		3, 196, 98, 0, 1385, 1364, 1, 0, 0, 0, 1385, 1367, 1, 0, 0, 0, 1385, 1374,
		1, 0, 0, 0, 1385, 1382, 1, 0, 0, 0, 1386, 133, 1, 0, 0, 0, 1387, 1388,
		5, 90, 0, 0, 1388, 1389, 3, 200, 100, 0, 1389, 135, 1, 0, 0, 0, 1390, 1391,
		5, 146, 0, 0, 1391, 1392, 5, 19, 0, 0, 1392, 1393, 3, 160, 80, 0, 1393,
		137, 1, 0, 0, 0, 1394, 1395, 5, 105, 0, 0, 1395, 1396, 5, 263, 0, 0, 1396,
		1397, 3, 196, 98, 0, 1397, 1398, 5, 273, 0, 0, 1398, 139, 1, 0, 0, 0, 1399,
		1400, 5, 146, 0, 0, 1400, 1401, 5, 19, 0, 0, 1401, 1402, 3, 196, 98, 0,
		1402, 141, 1, 0, 0, 0, 1403, 1404, 5, 120, 0, 0, 1404, 1405, 3, 158, 79,
		0, 1405, 1406, 5, 19, 0, 0, 1406, 1407, 3, 196, 98, 0, 1407, 143, 1, 0,
		0, 0, 1408, 1409, 5, 120, 0, 0, 1409, 1412, 3, 158, 79, 0, 1410, 1411,
		5, 233, 0, 0, 1411, 1413, 5, 205, 0, 0, 1412, 1410, 1, 0, 0, 0, 1412, 1413,
		1, 0, 0, 0, 1413, 145, 1, 0, 0, 0, 1414, 1415, 5, 190, 0, 0, 1415, 1416,
		3, 166, 83, 0, 1416, 147, 1, 0, 0, 0, 1417, 1418, 6, 74, -1, 0, 1418, 1420,
		3, 214, 107, 0, 1419, 1421, 5, 74, 0, 0, 1420, 1419, 1, 0, 0, 0, 1420,
		1421, 1, 0, 0, 0, 1421, 1423, 1, 0, 0, 0, 1422, 1424, 3, 156, 78, 0, 1423,
		1422, 1, 0, 0, 0, 1423, 1424, 1, 0, 0, 0, 1424, 1430, 1, 0, 0, 0, 1425,
		1426, 5, 263, 0, 0, 1426, 1427, 3, 148, 74, 0, 1427, 1428, 5, 273, 0, 0,
		1428, 1430, 1, 0, 0, 0, 1429, 1417, 1, 0, 0, 0, 1429, 1425, 1, 0, 0, 0,
		1430, 1448, 1, 0, 0, 0, 1431, 1432, 10, 3, 0, 0, 1432, 1433, 3, 152, 76,
		0, 1433, 1434, 3, 148, 74, 4, 1434, 1447, 1, 0, 0, 0, 1435, 1437, 10, 4,
		0, 0, 1436, 1438, 7, 9, 0, 0, 1437, 1436, 1, 0, 0, 0, 1437, 1438, 1, 0,
		0, 0, 1438, 1440, 1, 0, 0, 0, 1439, 1441, 3, 150, 75, 0, 1440, 1439, 1,
		0, 0, 0, 1440, 1441, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1443, 5,
		110, 0, 0, 1443, 1444, 3, 148, 74, 0, 1444, 1445, 3, 154, 77, 0, 1445,
		1447, 1, 0, 0, 0, 1446, 1431, 1, 0, 0, 0, 1446, 1435, 1, 0, 0, 0, 1447,
		1450, 1, 0, 0, 0, 1448, 1446, 1, 0, 0, 0, 1448, 1449, 1, 0, 0, 0, 1449,
		149, 1, 0, 0, 0, 1450, 1448, 1, 0, 0, 0, 1451, 1453, 7, 10, 0, 0, 1452,
		1451, 1, 0, 0, 0, 1452, 1453, 1, 0, 0, 0, 1453, 1454, 1, 0, 0, 0, 1454,
		1461, 5, 103, 0, 0, 1455, 1457, 5, 103, 0, 0, 1456, 1458, 7, 10, 0, 0,
		1457, 1456, 1, 0, 0, 0, 1457, 1458, 1, 0, 0, 0, 1458, 1461, 1, 0, 0, 0,
		1459, 1461, 7, 10, 0, 0, 1460, 1452, 1, 0, 0, 0, 1460, 1455, 1, 0, 0, 0,
		1460, 1459, 1, 0, 0, 0, 1461, 1495, 1, 0, 0, 0, 1462, 1464, 7, 11, 0, 0,
		1463, 1462, 1, 0, 0, 0, 1463, 1464, 1, 0, 0, 0, 1464, 1465, 1, 0, 0, 0,
		1465, 1467, 7, 12, 0, 0, 1466, 1468, 5, 147, 0, 0, 1467, 1466, 1, 0, 0,
		0, 1467, 1468, 1, 0, 0, 0, 1468, 1477, 1, 0, 0, 0, 1469, 1471, 7, 12, 0,
		0, 1470, 1472, 5, 147, 0, 0, 1471, 1470, 1, 0, 0, 0, 1471, 1472, 1, 0,
		0, 0, 1472, 1474, 1, 0, 0, 0, 1473, 1475, 7, 11, 0, 0, 1474, 1473, 1, 0,
		0, 0, 1474, 1475, 1, 0, 0, 0, 1475, 1477, 1, 0, 0, 0, 1476, 1463, 1, 0,
		0, 0, 1476, 1469, 1, 0, 0, 0, 1477, 1495, 1, 0, 0, 0, 1478, 1480, 7, 13,
		0, 0, 1479, 1478, 1, 0, 0, 0, 1479, 1480, 1, 0, 0, 0, 1480, 1481, 1, 0,
		0, 0, 1481, 1483, 5, 82, 0, 0, 1482, 1484, 5, 147, 0, 0, 1483, 1482, 1,
		0, 0, 0, 1483, 1484, 1, 0, 0, 0, 1484, 1493, 1, 0, 0, 0, 1485, 1487, 5,
		82, 0, 0, 1486, 1488, 5, 147, 0, 0, 1487, 1486, 1, 0, 0, 0, 1487, 1488,
		1, 0, 0, 0, 1488, 1490, 1, 0, 0, 0, 1489, 1491, 7, 13, 0, 0, 1490, 1489,
		1, 0, 0, 0, 1490, 1491, 1, 0, 0, 0, 1491, 1493, 1, 0, 0, 0, 1492, 1479,
		1, 0, 0, 0, 1492, 1485, 1, 0, 0, 0, 1493, 1495, 1, 0, 0, 0, 1494, 1460,
		1, 0, 0, 0, 1494, 1476, 1, 0, 0, 0, 1494, 1492, 1, 0, 0, 0, 1495, 151,
		1, 0, 0, 0, 1496, 1498, 7, 9, 0, 0, 1497, 1496, 1, 0, 0, 0, 1497, 1498,
		1, 0, 0, 0, 1498, 1499, 1, 0, 0, 0, 1499, 1500, 5, 34, 0, 0, 1500, 1503,
		5, 110, 0, 0, 1501, 1503, 5, 252, 0, 0, 1502, 1497, 1, 0, 0, 0, 1502, 1501,
		1, 0, 0, 0, 1503, 153, 1, 0, 0, 0, 1504, 1505, 5, 143, 0, 0, 1505, 1514,
		3, 196, 98, 0, 1506, 1507, 5, 223, 0, 0, 1507, 1508, 5, 263, 0, 0, 1508,
		1509, 3, 196, 98, 0, 1509, 1510, 5, 273, 0, 0, 1510, 1514, 1, 0, 0, 0,
		1511, 1512, 5, 223, 0, 0, 1512, 1514, 3, 196, 98, 0, 1513, 1504, 1, 0,
		0, 0, 1513, 1506, 1, 0, 0, 0, 1513, 1511, 1, 0, 0, 0, 1514, 155, 1, 0,
		0, 0, 1515, 1516, 5, 182, 0, 0, 1516, 1519, 3, 164, 82, 0, 1517, 1518,
		5, 142, 0, 0, 1518, 1520, 3, 164, 82, 0, 1519, 1517, 1, 0, 0, 0, 1519,
		1520, 1, 0, 0, 0, 1520, 157, 1, 0, 0, 0, 1521, 1524, 3, 200, 100, 0, 1522,
		1523, 7, 14, 0, 0, 1523, 1525, 3, 200, 100, 0, 1524, 1522, 1, 0, 0, 0,
		1524, 1525, 1, 0, 0, 0, 1525, 159, 1, 0, 0, 0, 1526, 1531, 3, 162, 81,
		0, 1527, 1528, 5, 252, 0, 0, 1528, 1530, 3, 162, 81, 0, 1529, 1527, 1,
		0, 0, 0, 1530, 1533, 1, 0, 0, 0, 1531, 1529, 1, 0, 0, 0, 1531, 1532, 1,
		0, 0, 0, 1532, 161, 1, 0, 0, 0, 1533, 1531, 1, 0, 0, 0, 1534, 1536, 3,
		200, 100, 0, 1535, 1537, 7, 15, 0, 0, 1536, 1535, 1, 0, 0, 0, 1536, 1537,
		1, 0, 0, 0, 1537, 1540, 1, 0, 0, 0, 1538, 1539, 5, 141, 0, 0, 1539, 1541,
		7, 16, 0, 0, 1540, 1538, 1, 0, 0, 0, 1540, 1541, 1, 0, 0, 0, 1541, 1544,
		1, 0, 0, 0, 1542, 1543, 5, 28, 0, 0, 1543, 1545, 3, 230, 115, 0, 1544,
		1542, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 1560, 1, 0, 0, 0, 1546,
		1547, 5, 233, 0, 0, 1547, 1550, 5, 73, 0, 0, 1548, 1549, 5, 81, 0, 0, 1549,
		1551, 3, 200, 100, 0, 1550, 1548, 1, 0, 0, 0, 1550, 1551, 1, 0, 0, 0, 1551,
		1554, 1, 0, 0, 0, 1552, 1553, 5, 208, 0, 0, 1553, 1555, 3, 200, 100, 0,
		1554, 1552, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1558, 1, 0, 0, 0,
		1556, 1557, 5, 199, 0, 0, 1557, 1559, 3, 200, 100, 0, 1558, 1556, 1, 0,
		0, 0, 1558, 1559, 1, 0, 0, 0, 1559, 1561, 1, 0, 0, 0, 1560, 1546, 1, 0,
		0, 0, 1560, 1561, 1, 0, 0, 0, 1561, 163, 1, 0, 0, 0, 1562, 1565, 3, 228,
		114, 0, 1563, 1564, 5, 275, 0, 0, 1564, 1566, 3, 228, 114, 0, 1565, 1563,
		1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566, 165, 1, 0, 0, 0, 1567, 1572,
		3, 168, 84, 0, 1568, 1569, 5, 252, 0, 0, 1569, 1571, 3, 168, 84, 0, 1570,
		1568, 1, 0, 0, 0, 1571, 1574, 1, 0, 0, 0, 1572, 1570, 1, 0, 0, 0, 1572,
		1573, 1, 0, 0, 0, 1573, 167, 1, 0, 0, 0, 1574, 1572, 1, 0, 0, 0, 1575,
		1576, 3, 242, 121, 0, 1576, 1577, 5, 257, 0, 0, 1577, 1578, 3, 232, 116,
		0, 1578, 169, 1, 0, 0, 0, 1579, 1581, 3, 172, 86, 0, 1580, 1579, 1, 0,
		0, 0, 1580, 1581, 1, 0, 0, 0, 1581, 1583, 1, 0, 0, 0, 1582, 1584, 3, 174,
		87, 0, 1583, 1582, 1, 0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 1586, 1, 0,
		0, 0, 1585, 1587, 3, 176, 88, 0, 1586, 1585, 1, 0, 0, 0, 1586, 1587, 1,
		0, 0, 0, 1587, 171, 1, 0, 0, 0, 1588, 1589, 5, 151, 0, 0, 1589, 1590, 5,
		19, 0, 0, 1590, 1591, 3, 196, 98, 0, 1591, 173, 1, 0, 0, 0, 1592, 1593,
		5, 146, 0, 0, 1593, 1594, 5, 19, 0, 0, 1594, 1595, 3, 160, 80, 0, 1595,
		175, 1, 0, 0, 0, 1596, 1597, 7, 17, 0, 0, 1597, 1598, 3, 178, 89, 0, 1598,
		177, 1, 0, 0, 0, 1599, 1606, 3, 180, 90, 0, 1600, 1601, 5, 17, 0, 0, 1601,
		1602, 3, 180, 90, 0, 1602, 1603, 5, 7, 0, 0, 1603, 1604, 3, 180, 90, 0,
		1604, 1606, 1, 0, 0, 0, 1605, 1599, 1, 0, 0, 0, 1605, 1600, 1, 0, 0, 0,
		1606, 179, 1, 0, 0, 0, 1607, 1608, 5, 36, 0, 0, 1608, 1620, 5, 180, 0,
		0, 1609, 1610, 5, 217, 0, 0, 1610, 1620, 5, 157, 0, 0, 1611, 1612, 5, 217,
		0, 0, 1612, 1620, 5, 77, 0, 0, 1613, 1614, 3, 228, 114, 0, 1614, 1615,
		5, 157, 0, 0, 1615, 1620, 1, 0, 0, 0, 1616, 1617, 3, 228, 114, 0, 1617,
		1618, 5, 77, 0, 0, 1618, 1620, 1, 0, 0, 0, 1619, 1607, 1, 0, 0, 0, 1619,
		1609, 1, 0, 0, 0, 1619, 1611, 1, 0, 0, 0, 1619, 1613, 1, 0, 0, 0, 1619,
		1616, 1, 0, 0, 0, 1620, 181, 1, 0, 0, 0, 1621, 1622, 5, 187, 0, 0, 1622,
		1623, 3, 166, 83, 0, 1623, 183, 1, 0, 0, 0, 1624, 1626, 5, 191, 0, 0, 1625,
		1627, 5, 33, 0, 0, 1626, 1625, 1, 0, 0, 0, 1626, 1627, 1, 0, 0, 0, 1627,
		1628, 1, 0, 0, 0, 1628, 1629, 5, 39, 0, 0, 1629, 1931, 3, 224, 112, 0,
		1630, 1631, 5, 191, 0, 0, 1631, 1632, 5, 33, 0, 0, 1632, 1633, 5, 52, 0,
		0, 1633, 1931, 3, 218, 109, 0, 1634, 1636, 5, 191, 0, 0, 1635, 1637, 5,
		33, 0, 0, 1636, 1635, 1, 0, 0, 0, 1636, 1637, 1, 0, 0, 0, 1637, 1638, 1,
		0, 0, 0, 1638, 1639, 5, 226, 0, 0, 1639, 1931, 3, 218, 109, 0, 1640, 1641,
		5, 191, 0, 0, 1641, 1649, 5, 40, 0, 0, 1642, 1644, 5, 139, 0, 0, 1643,
		1642, 1, 0, 0, 0, 1643, 1644, 1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645,
		1646, 7, 18, 0, 0, 1646, 1650, 3, 230, 115, 0, 1647, 1648, 5, 231, 0, 0,
		1648, 1650, 3, 200, 100, 0, 1649, 1643, 1, 0, 0, 0, 1649, 1647, 1, 0, 0,
		0, 1649, 1650, 1, 0, 0, 0, 1650, 1653, 1, 0, 0, 0, 1651, 1652, 5, 120,
		0, 0, 1652, 1654, 5, 242, 0, 0, 1653, 1651, 1, 0, 0, 0, 1653, 1654, 1,
		0, 0, 0, 1654, 1931, 1, 0, 0, 0, 1655, 1656, 5, 191, 0, 0, 1656, 1659,
		5, 51, 0, 0, 1657, 1658, 5, 81, 0, 0, 1658, 1660, 3, 224, 112, 0, 1659,
		1657, 1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1668, 1, 0, 0, 0, 1661,
		1663, 5, 139, 0, 0, 1662, 1661, 1, 0, 0, 0, 1662, 1663, 1, 0, 0, 0, 1663,
		1664, 1, 0, 0, 0, 1664, 1665, 7, 18, 0, 0, 1665, 1669, 3, 230, 115, 0,
		1666, 1667, 5, 231, 0, 0, 1667, 1669, 3, 200, 100, 0, 1668, 1662, 1, 0,
		0, 0, 1668, 1666, 1, 0, 0, 0, 1668, 1669, 1, 0, 0, 0, 1669, 1672, 1, 0,
		0, 0, 1670, 1671, 5, 120, 0, 0, 1671, 1673, 5, 242, 0, 0, 1672, 1670, 1,
		0, 0, 0, 1672, 1673, 1, 0, 0, 0, 1673, 1931, 1, 0, 0, 0, 1674, 1676, 5,
		191, 0, 0, 1675, 1677, 5, 82, 0, 0, 1676, 1675, 1, 0, 0, 0, 1676, 1677,
		1, 0, 0, 0, 1677, 1679, 1, 0, 0, 0, 1678, 1680, 5, 202, 0, 0, 1679, 1678,
		1, 0, 0, 0, 1679, 1680, 1, 0, 0, 0, 1680, 1681, 1, 0, 0, 0, 1681, 1684,
		5, 201, 0, 0, 1682, 1683, 7, 19, 0, 0, 1683, 1685, 3, 224, 112, 0, 1684,
		1682, 1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685, 1693, 1, 0, 0, 0, 1686,
		1688, 5, 139, 0, 0, 1687, 1686, 1, 0, 0, 0, 1687, 1688, 1, 0, 0, 0, 1688,
		1689, 1, 0, 0, 0, 1689, 1690, 7, 18, 0, 0, 1690, 1694, 3, 230, 115, 0,
		1691, 1692, 5, 231, 0, 0, 1692, 1694, 3, 200, 100, 0, 1693, 1687, 1, 0,
		0, 0, 1693, 1691, 1, 0, 0, 0, 1693, 1694, 1, 0, 0, 0, 1694, 1697, 1, 0,
		0, 0, 1695, 1696, 5, 120, 0, 0, 1696, 1698, 5, 242, 0, 0, 1697, 1695, 1,
		0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1931, 1, 0, 0, 0, 1699, 1701, 5,
		191, 0, 0, 1700, 1702, 5, 68, 0, 0, 1701, 1700, 1, 0, 0, 0, 1701, 1702,
		1, 0, 0, 0, 1702, 1704, 1, 0, 0, 0, 1703, 1705, 5, 82, 0, 0, 1704, 1703,
		1, 0, 0, 0, 1704, 1705, 1, 0, 0, 0, 1705, 1706, 1, 0, 0, 0, 1706, 1707,
		7, 20, 0, 0, 1707, 1713, 7, 19, 0, 0, 1708, 1714, 3, 218, 109, 0, 1709,
		1710, 3, 242, 121, 0, 1710, 1711, 7, 19, 0, 0, 1711, 1712, 3, 242, 121,
		0, 1712, 1714, 1, 0, 0, 0, 1713, 1708, 1, 0, 0, 0, 1713, 1709, 1, 0, 0,
		0, 1714, 1722, 1, 0, 0, 0, 1715, 1717, 5, 139, 0, 0, 1716, 1715, 1, 0,
		0, 0, 1716, 1717, 1, 0, 0, 0, 1717, 1718, 1, 0, 0, 0, 1718, 1719, 7, 18,
		0, 0, 1719, 1723, 3, 230, 115, 0, 1720, 1721, 5, 231, 0, 0, 1721, 1723,
		3, 200, 100, 0, 1722, 1716, 1, 0, 0, 0, 1722, 1720, 1, 0, 0, 0, 1722, 1723,
		1, 0, 0, 0, 1723, 1726, 1, 0, 0, 0, 1724, 1725, 5, 120, 0, 0, 1725, 1727,
		5, 242, 0, 0, 1726, 1724, 1, 0, 0, 0, 1726, 1727, 1, 0, 0, 0, 1727, 1931,
		1, 0, 0, 0, 1728, 1730, 5, 191, 0, 0, 1729, 1731, 5, 68, 0, 0, 1730, 1729,
		1, 0, 0, 0, 1730, 1731, 1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732, 1733,
		7, 21, 0, 0, 1733, 1739, 7, 19, 0, 0, 1734, 1740, 3, 218, 109, 0, 1735,
		1736, 3, 242, 121, 0, 1736, 1737, 7, 19, 0, 0, 1737, 1738, 3, 242, 121,
		0, 1738, 1740, 1, 0, 0, 0, 1739, 1734, 1, 0, 0, 0, 1739, 1735, 1, 0, 0,
		0, 1740, 1743, 1, 0, 0, 0, 1741, 1742, 5, 231, 0, 0, 1742, 1744, 3, 200,
		100, 0, 1743, 1741, 1, 0, 0, 0, 1743, 1744, 1, 0, 0, 0, 1744, 1931, 1,
		0, 0, 0, 1745, 1746, 5, 191, 0, 0, 1746, 1931, 5, 161, 0, 0, 1747, 1748,
		5, 191, 0, 0, 1748, 1758, 5, 87, 0, 0, 1749, 1750, 5, 78, 0, 0, 1750, 1755,
		3, 242, 121, 0, 1751, 1752, 5, 252, 0, 0, 1752, 1754, 3, 242, 121, 0, 1753,
		1751, 1, 0, 0, 0, 1754, 1757, 1, 0, 0, 0, 1755, 1753, 1, 0, 0, 0, 1755,
		1756, 1, 0, 0, 0, 1756, 1759, 1, 0, 0, 0, 1757, 1755, 1, 0, 0, 0, 1758,
		1749, 1, 0, 0, 0, 1758, 1759, 1, 0, 0, 0, 1759, 1762, 1, 0, 0, 0, 1760,
		1761, 5, 233, 0, 0, 1761, 1763, 5, 96, 0, 0, 1762, 1760, 1, 0, 0, 0, 1762,
		1763, 1, 0, 0, 0, 1763, 1765, 1, 0, 0, 0, 1764, 1766, 5, 74, 0, 0, 1765,
		1764, 1, 0, 0, 0, 1765, 1766, 1, 0, 0, 0, 1766, 1931, 1, 0, 0, 0, 1767,
		1768, 5, 191, 0, 0, 1768, 1769, 5, 33, 0, 0, 1769, 1779, 5, 221, 0, 0,
		1770, 1775, 3, 242, 121, 0, 1771, 1772, 5, 252, 0, 0, 1772, 1774, 3, 242,
		121, 0, 1773, 1771, 1, 0, 0, 0, 1774, 1777, 1, 0, 0, 0, 1775, 1773, 1,
		0, 0, 0, 1775, 1776, 1, 0, 0, 0, 1776, 1780, 1, 0, 0, 0, 1777, 1775, 1,
		0, 0, 0, 1778, 1780, 5, 37, 0, 0, 1779, 1770, 1, 0, 0, 0, 1779, 1778, 1,
		0, 0, 0, 1779, 1780, 1, 0, 0, 0, 1780, 1931, 1, 0, 0, 0, 1781, 1782, 5,
		191, 0, 0, 1782, 1783, 5, 33, 0, 0, 1783, 1784, 5, 177, 0, 0, 1784, 1789,
		3, 242, 121, 0, 1785, 1786, 5, 252, 0, 0, 1786, 1788, 3, 242, 121, 0, 1787,
		1785, 1, 0, 0, 0, 1788, 1791, 1, 0, 0, 0, 1789, 1787, 1, 0, 0, 0, 1789,
		1790, 1, 0, 0, 0, 1790, 1931, 1, 0, 0, 0, 1791, 1789, 1, 0, 0, 0, 1792,
		1793, 5, 191, 0, 0, 1793, 1795, 5, 33, 0, 0, 1794, 1796, 5, 180, 0, 0,
		1795, 1794, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0, 1796, 1797, 1, 0, 0, 0,
		1797, 1798, 5, 154, 0, 0, 1798, 1799, 3, 242, 121, 0, 1799, 1800, 5, 143,
		0, 0, 1800, 1805, 3, 218, 109, 0, 1801, 1802, 5, 252, 0, 0, 1802, 1804,
		3, 218, 109, 0, 1803, 1801, 1, 0, 0, 0, 1804, 1807, 1, 0, 0, 0, 1805, 1803,
		1, 0, 0, 0, 1805, 1806, 1, 0, 0, 0, 1806, 1931, 1, 0, 0, 0, 1807, 1805,
		1, 0, 0, 0, 1808, 1809, 5, 191, 0, 0, 1809, 1810, 5, 33, 0, 0, 1810, 1820,
		5, 166, 0, 0, 1811, 1816, 3, 242, 121, 0, 1812, 1813, 5, 252, 0, 0, 1813,
		1815, 3, 242, 121, 0, 1814, 1812, 1, 0, 0, 0, 1815, 1818, 1, 0, 0, 0, 1816,
		1814, 1, 0, 0, 0, 1816, 1817, 1, 0, 0, 0, 1817, 1821, 1, 0, 0, 0, 1818,
		1816, 1, 0, 0, 0, 1819, 1821, 5, 36, 0, 0, 1820, 1811, 1, 0, 0, 0, 1820,
		1819, 1, 0, 0, 0, 1821, 1931, 1, 0, 0, 0, 1822, 1823, 5, 191, 0, 0, 1823,
		1825, 5, 33, 0, 0, 1824, 1826, 5, 190, 0, 0, 1825, 1824, 1, 0, 0, 0, 1825,
		1826, 1, 0, 0, 0, 1826, 1827, 1, 0, 0, 0, 1827, 1828, 5, 162, 0, 0, 1828,
		1833, 3, 242, 121, 0, 1829, 1830, 5, 252, 0, 0, 1830, 1832, 3, 242, 121,
		0, 1831, 1829, 1, 0, 0, 0, 1832, 1835, 1, 0, 0, 0, 1833, 1831, 1, 0, 0,
		0, 1833, 1834, 1, 0, 0, 0, 1834, 1931, 1, 0, 0, 0, 1835, 1833, 1, 0, 0,
		0, 1836, 1837, 5, 191, 0, 0, 1837, 1931, 5, 222, 0, 0, 1838, 1840, 5, 191,
		0, 0, 1839, 1841, 7, 22, 0, 0, 1840, 1839, 1, 0, 0, 0, 1840, 1841, 1, 0,
		0, 0, 1841, 1842, 1, 0, 0, 0, 1842, 1931, 5, 178, 0, 0, 1843, 1845, 5,
		191, 0, 0, 1844, 1846, 5, 190, 0, 0, 1845, 1844, 1, 0, 0, 0, 1845, 1846,
		1, 0, 0, 0, 1846, 1847, 1, 0, 0, 0, 1847, 1931, 5, 163, 0, 0, 1848, 1850,
		5, 191, 0, 0, 1849, 1851, 5, 180, 0, 0, 1850, 1849, 1, 0, 0, 0, 1850, 1851,
		1, 0, 0, 0, 1851, 1852, 1, 0, 0, 0, 1852, 1855, 5, 155, 0, 0, 1853, 1854,
		5, 143, 0, 0, 1854, 1856, 3, 218, 109, 0, 1855, 1853, 1, 0, 0, 0, 1855,
		1856, 1, 0, 0, 0, 1856, 1931, 1, 0, 0, 0, 1857, 1858, 5, 191, 0, 0, 1858,
		1931, 5, 167, 0, 0, 1859, 1861, 5, 191, 0, 0, 1860, 1862, 5, 36, 0, 0,
		1861, 1860, 1, 0, 0, 0, 1861, 1862, 1, 0, 0, 0, 1862, 1863, 1, 0, 0, 0,
		1863, 1931, 5, 166, 0, 0, 1864, 1865, 5, 191, 0, 0, 1865, 1931, 5, 1, 0,
		0, 1866, 1867, 5, 191, 0, 0, 1867, 1868, 5, 25, 0, 0, 1868, 1931, 3, 230,
		115, 0, 1869, 1870, 5, 191, 0, 0, 1870, 1876, 5, 26, 0, 0, 1871, 1873,
		5, 139, 0, 0, 1872, 1871, 1, 0, 0, 0, 1872, 1873, 1, 0, 0, 0, 1873, 1874,
		1, 0, 0, 0, 1874, 1875, 7, 18, 0, 0, 1875, 1877, 3, 230, 115, 0, 1876,
		1872, 1, 0, 0, 0, 1876, 1877, 1, 0, 0, 0, 1877, 1880, 1, 0, 0, 0, 1878,
		1879, 5, 120, 0, 0, 1879, 1881, 5, 242, 0, 0, 1880, 1878, 1, 0, 0, 0, 1880,
		1881, 1, 0, 0, 0, 1881, 1931, 1, 0, 0, 0, 1882, 1884, 5, 191, 0, 0, 1883,
		1885, 5, 38, 0, 0, 1884, 1883, 1, 0, 0, 0, 1884, 1885, 1, 0, 0, 0, 1885,
		1886, 1, 0, 0, 0, 1886, 1887, 5, 190, 0, 0, 1887, 1888, 7, 18, 0, 0, 1888,
		1931, 3, 230, 115, 0, 1889, 1890, 5, 191, 0, 0, 1890, 1891, 5, 189, 0,
		0, 1891, 1931, 3, 230, 115, 0, 1892, 1893, 5, 191, 0, 0, 1893, 1894, 5,
		72, 0, 0, 1894, 1931, 5, 20, 0, 0, 1895, 1896, 5, 191, 0, 0, 1896, 1931,
		5, 61, 0, 0, 1897, 1898, 5, 191, 0, 0, 1898, 1901, 5, 84, 0, 0, 1899, 1900,
		7, 18, 0, 0, 1900, 1902, 3, 230, 115, 0, 1901, 1899, 1, 0, 0, 0, 1901,
		1902, 1, 0, 0, 0, 1902, 1931, 1, 0, 0, 0, 1903, 1904, 5, 191, 0, 0, 1904,
		1910, 5, 127, 0, 0, 1905, 1907, 5, 139, 0, 0, 1906, 1905, 1, 0, 0, 0, 1906,
		1907, 1, 0, 0, 0, 1907, 1908, 1, 0, 0, 0, 1908, 1909, 7, 18, 0, 0, 1909,
		1911, 3, 230, 115, 0, 1910, 1906, 1, 0, 0, 0, 1910, 1911, 1, 0, 0, 0, 1911,
		1914, 1, 0, 0, 0, 1912, 1913, 5, 120, 0, 0, 1913, 1915, 5, 242, 0, 0, 1914,
		1912, 1, 0, 0, 0, 1914, 1915, 1, 0, 0, 0, 1915, 1931, 1, 0, 0, 0, 1916,
		1917, 5, 191, 0, 0, 1917, 1931, 5, 160, 0, 0, 1918, 1927, 5, 191, 0, 0,
		1919, 1928, 5, 200, 0, 0, 1920, 1922, 5, 33, 0, 0, 1921, 1923, 5, 202,
		0, 0, 1922, 1921, 1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923, 1925, 1, 0,
		0, 0, 1924, 1926, 5, 200, 0, 0, 1925, 1924, 1, 0, 0, 0, 1925, 1926, 1,
		0, 0, 0, 1926, 1928, 1, 0, 0, 0, 1927, 1919, 1, 0, 0, 0, 1927, 1920, 1,
		0, 0, 0, 1927, 1928, 1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 1931, 3,
		218, 109, 0, 1930, 1624, 1, 0, 0, 0, 1930, 1630, 1, 0, 0, 0, 1930, 1634,
		1, 0, 0, 0, 1930, 1640, 1, 0, 0, 0, 1930, 1655, 1, 0, 0, 0, 1930, 1674,
		1, 0, 0, 0, 1930, 1699, 1, 0, 0, 0, 1930, 1728, 1, 0, 0, 0, 1930, 1745,
		1, 0, 0, 0, 1930, 1747, 1, 0, 0, 0, 1930, 1767, 1, 0, 0, 0, 1930, 1781,
		1, 0, 0, 0, 1930, 1792, 1, 0, 0, 0, 1930, 1808, 1, 0, 0, 0, 1930, 1822,
		1, 0, 0, 0, 1930, 1836, 1, 0, 0, 0, 1930, 1838, 1, 0, 0, 0, 1930, 1843,
		1, 0, 0, 0, 1930, 1848, 1, 0, 0, 0, 1930, 1857, 1, 0, 0, 0, 1930, 1859,
		1, 0, 0, 0, 1930, 1864, 1, 0, 0, 0, 1930, 1866, 1, 0, 0, 0, 1930, 1869,
		1, 0, 0, 0, 1930, 1882, 1, 0, 0, 0, 1930, 1889, 1, 0, 0, 0, 1930, 1892,
		1, 0, 0, 0, 1930, 1895, 1, 0, 0, 0, 1930, 1897, 1, 0, 0, 0, 1930, 1903,
		1, 0, 0, 0, 1930, 1916, 1, 0, 0, 0, 1930, 1918, 1, 0, 0, 0, 1931, 185,
		1, 0, 0, 0, 1932, 1933, 5, 198, 0, 0, 1933, 1934, 5, 76, 0, 0, 1934, 1935,
		5, 55, 0, 0, 1935, 1967, 3, 218, 109, 0, 1936, 1937, 5, 198, 0, 0, 1937,
		1938, 5, 76, 0, 0, 1938, 1967, 5, 123, 0, 0, 1939, 1940, 5, 198, 0, 0,
		1940, 1941, 5, 170, 0, 0, 1941, 1967, 5, 51, 0, 0, 1942, 1943, 5, 198,
		0, 0, 1943, 1944, 5, 170, 0, 0, 1944, 1945, 5, 52, 0, 0, 1945, 1967, 3,
		218, 109, 0, 1946, 1947, 5, 198, 0, 0, 1947, 1955, 7, 23, 0, 0, 1948, 1949,
		5, 55, 0, 0, 1949, 1956, 5, 186, 0, 0, 1950, 1956, 5, 70, 0, 0, 1951, 1953,
		5, 215, 0, 0, 1952, 1951, 1, 0, 0, 0, 1952, 1953, 1, 0, 0, 0, 1953, 1954,
		1, 0, 0, 0, 1954, 1956, 5, 127, 0, 0, 1955, 1948, 1, 0, 0, 0, 1955, 1950,
		1, 0, 0, 0, 1955, 1952, 1, 0, 0, 0, 1956, 1957, 1, 0, 0, 0, 1957, 1967,
		3, 218, 109, 0, 1958, 1959, 5, 198, 0, 0, 1959, 1960, 7, 23, 0, 0, 1960,
		1961, 5, 175, 0, 0, 1961, 1967, 5, 186, 0, 0, 1962, 1963, 5, 198, 0, 0,
		1963, 1964, 5, 196, 0, 0, 1964, 1965, 5, 174, 0, 0, 1965, 1967, 3, 218,
		109, 0, 1966, 1932, 1, 0, 0, 0, 1966, 1936, 1, 0, 0, 0, 1966, 1939, 1,
		0, 0, 0, 1966, 1942, 1, 0, 0, 0, 1966, 1946, 1, 0, 0, 0, 1966, 1958, 1,
		0, 0, 0, 1966, 1962, 1, 0, 0, 0, 1967, 187, 1, 0, 0, 0, 1968, 1970, 5,
		214, 0, 0, 1969, 1971, 5, 202, 0, 0, 1970, 1969, 1, 0, 0, 0, 1970, 1971,
		1, 0, 0, 0, 1971, 1973, 1, 0, 0, 0, 1972, 1974, 5, 200, 0, 0, 1973, 1972,
		1, 0, 0, 0, 1973, 1974, 1, 0, 0, 0, 1974, 1977, 1, 0, 0, 0, 1975, 1976,
		5, 94, 0, 0, 1976, 1978, 5, 65, 0, 0, 1977, 1975, 1, 0, 0, 0, 1977, 1978,
		1, 0, 0, 0, 1978, 1979, 1, 0, 0, 0, 1979, 1981, 3, 218, 109, 0, 1980, 1982,
		3, 42, 21, 0, 1981, 1980, 1, 0, 0, 0, 1981, 1982, 1, 0, 0, 0, 1982, 189,
		1, 0, 0, 0, 1983, 1984, 5, 220, 0, 0, 1984, 1985, 3, 224, 112, 0, 1985,
		191, 1, 0, 0, 0, 1986, 1987, 5, 228, 0, 0, 1987, 1989, 3, 218, 109, 0,
		1988, 1990, 5, 63, 0, 0, 1989, 1988, 1, 0, 0, 0, 1989, 1990, 1, 0, 0, 0,
		1990, 1993, 1, 0, 0, 0, 1991, 1992, 5, 120, 0, 0, 1992, 1994, 5, 242, 0,
		0, 1993, 1991, 1, 0, 0, 0, 1993, 1994, 1, 0, 0, 0, 1994, 193, 1, 0, 0,
		0, 1995, 2043, 3, 242, 121, 0, 1996, 1997, 3, 242, 121, 0, 1997, 1998,
		5, 263, 0, 0, 1998, 1999, 3, 242, 121, 0, 1999, 2006, 3, 194, 97, 0, 2000,
		2001, 5, 252, 0, 0, 2001, 2002, 3, 242, 121, 0, 2002, 2003, 3, 194, 97,
		0, 2003, 2005, 1, 0, 0, 0, 2004, 2000, 1, 0, 0, 0, 2005, 2008, 1, 0, 0,
		0, 2006, 2004, 1, 0, 0, 0, 2006, 2007, 1, 0, 0, 0, 2007, 2009, 1, 0, 0,
		0, 2008, 2006, 1, 0, 0, 0, 2009, 2010, 5, 273, 0, 0, 2010, 2043, 1, 0,
		0, 0, 2011, 2012, 3, 242, 121, 0, 2012, 2013, 5, 263, 0, 0, 2013, 2018,
		3, 246, 123, 0, 2014, 2015, 5, 252, 0, 0, 2015, 2017, 3, 246, 123, 0, 2016,
		2014, 1, 0, 0, 0, 2017, 2020, 1, 0, 0, 0, 2018, 2016, 1, 0, 0, 0, 2018,
		2019, 1, 0, 0, 0, 2019, 2021, 1, 0, 0, 0, 2020, 2018, 1, 0, 0, 0, 2021,
		2022, 5, 273, 0, 0, 2022, 2043, 1, 0, 0, 0, 2023, 2024, 3, 242, 121, 0,
		2024, 2025, 5, 263, 0, 0, 2025, 2030, 3, 194, 97, 0, 2026, 2027, 5, 252,
		0, 0, 2027, 2029, 3, 194, 97, 0, 2028, 2026, 1, 0, 0, 0, 2029, 2032, 1,
		0, 0, 0, 2030, 2028, 1, 0, 0, 0, 2030, 2031, 1, 0, 0, 0, 2031, 2033, 1,
		0, 0, 0, 2032, 2030, 1, 0, 0, 0, 2033, 2034, 5, 273, 0, 0, 2034, 2043,
		1, 0, 0, 0, 2035, 2036, 3, 242, 121, 0, 2036, 2038, 5, 263, 0, 0, 2037,
		2039, 3, 196, 98, 0, 2038, 2037, 1, 0, 0, 0, 2038, 2039, 1, 0, 0, 0, 2039,
		2040, 1, 0, 0, 0, 2040, 2041, 5, 273, 0, 0, 2041, 2043, 1, 0, 0, 0, 2042,
		1995, 1, 0, 0, 0, 2042, 1996, 1, 0, 0, 0, 2042, 2011, 1, 0, 0, 0, 2042,
		2023, 1, 0, 0, 0, 2042, 2035, 1, 0, 0, 0, 2043, 195, 1, 0, 0, 0, 2044,
		2049, 3, 198, 99, 0, 2045, 2046, 5, 252, 0, 0, 2046, 2048, 3, 198, 99,
		0, 2047, 2045, 1, 0, 0, 0, 2048, 2051, 1, 0, 0, 0, 2049, 2047, 1, 0, 0,
		0, 2049, 2050, 1, 0, 0, 0, 2050, 197, 1, 0, 0, 0, 2051, 2049, 1, 0, 0,
		0, 2052, 2053, 3, 218, 109, 0, 2053, 2054, 5, 255, 0, 0, 2054, 2056, 1,
		0, 0, 0, 2055, 2052, 1, 0, 0, 0, 2055, 2056, 1, 0, 0, 0, 2056, 2057, 1,
		0, 0, 0, 2057, 2059, 5, 247, 0, 0, 2058, 2060, 3, 212, 106, 0, 2059, 2058,
		1, 0, 0, 0, 2059, 2060, 1, 0, 0, 0, 2060, 2067, 1, 0, 0, 0, 2061, 2062,
		5, 263, 0, 0, 2062, 2063, 3, 108, 54, 0, 2063, 2064, 5, 273, 0, 0, 2064,
		2067, 1, 0, 0, 0, 2065, 2067, 3, 200, 100, 0, 2066, 2055, 1, 0, 0, 0, 2066,
		2061, 1, 0, 0, 0, 2066, 2065, 1, 0, 0, 0, 2067, 199, 1, 0, 0, 0, 2068,
		2069, 6, 100, -1, 0, 2069, 2071, 5, 21, 0, 0, 2070, 2072, 3, 200, 100,
		0, 2071, 2070, 1, 0, 0, 0, 2071, 2072, 1, 0, 0, 0, 2072, 2078, 1, 0, 0,
		0, 2073, 2074, 5, 230, 0, 0, 2074, 2075, 3, 200, 100, 0, 2075, 2076, 5,
		204, 0, 0, 2076, 2077, 3, 200, 100, 0, 2077, 2079, 1, 0, 0, 0, 2078, 2073,
		1, 0, 0, 0, 2079, 2080, 1, 0, 0, 0, 2080, 2078, 1, 0, 0, 0, 2080, 2081,
		1, 0, 0, 0, 2081, 2084, 1, 0, 0, 0, 2082, 2083, 5, 57, 0, 0, 2083, 2085,
		3, 200, 100, 0, 2084, 2082, 1, 0, 0, 0, 2084, 2085, 1, 0, 0, 0, 2085, 2086,
		1, 0, 0, 0, 2086, 2087, 5, 59, 0, 0, 2087, 2199, 1, 0, 0, 0, 2088, 2089,
		5, 22, 0, 0, 2089, 2090, 5, 263, 0, 0, 2090, 2091, 3, 200, 100, 0, 2091,
		2092, 5, 11, 0, 0, 2092, 2093, 3, 194, 97, 0, 2093, 2094, 5, 273, 0, 0,
		2094, 2199, 1, 0, 0, 0, 2095, 2096, 5, 41, 0, 0, 2096, 2199, 3, 230, 115,
		0, 2097, 2098, 5, 69, 0, 0, 2098, 2099, 5, 263, 0, 0, 2099, 2100, 3, 234,
		117, 0, 2100, 2101, 5, 81, 0, 0, 2101, 2102, 3, 200, 100, 0, 2102, 2103,
		5, 273, 0, 0, 2103, 2199, 1, 0, 0, 0, 2104, 2105, 5, 106, 0, 0, 2105, 2106,
		3, 200, 100, 0, 2106, 2107, 3, 234, 117, 0, 2107, 2199, 1, 0, 0, 0, 2108,
		2109, 5, 195, 0, 0, 2109, 2110, 5, 263, 0, 0, 2110, 2111, 3, 200, 100,
		0, 2111, 2112, 5, 81, 0, 0, 2112, 2115, 3, 200, 100, 0, 2113, 2114, 5,
		78, 0, 0, 2114, 2116, 3, 200, 100, 0, 2115, 2113, 1, 0, 0, 0, 2115, 2116,
		1, 0, 0, 0, 2116, 2117, 1, 0, 0, 0, 2117, 2118, 5, 273, 0, 0, 2118, 2199,
		1, 0, 0, 0, 2119, 2120, 5, 207, 0, 0, 2120, 2199, 3, 230, 115, 0, 2121,
		2122, 5, 213, 0, 0, 2122, 2123, 5, 263, 0, 0, 2123, 2124, 7, 24, 0, 0,
		2124, 2125, 3, 230, 115, 0, 2125, 2126, 5, 81, 0, 0, 2126, 2127, 3, 200,
		100, 0, 2127, 2128, 5, 273, 0, 0, 2128, 2199, 1, 0, 0, 0, 2129, 2130, 5,
		139, 0, 0, 2130, 2199, 3, 200, 100, 22, 2131, 2132, 3, 242, 121, 0, 2132,
		2134, 5, 263, 0, 0, 2133, 2135, 3, 196, 98, 0, 2134, 2133, 1, 0, 0, 0,
		2134, 2135, 1, 0, 0, 0, 2135, 2136, 1, 0, 0, 0, 2136, 2137, 5, 273, 0,
		0, 2137, 2138, 1, 0, 0, 0, 2138, 2139, 5, 149, 0, 0, 2139, 2140, 5, 263,
		0, 0, 2140, 2141, 3, 170, 85, 0, 2141, 2142, 5, 273, 0, 0, 2142, 2199,
		1, 0, 0, 0, 2143, 2144, 3, 242, 121, 0, 2144, 2146, 5, 263, 0, 0, 2145,
		2147, 3, 196, 98, 0, 2146, 2145, 1, 0, 0, 0, 2146, 2147, 1, 0, 0, 0, 2147,
		2148, 1, 0, 0, 0, 2148, 2149, 5, 273, 0, 0, 2149, 2150, 1, 0, 0, 0, 2150,
		2151, 5, 149, 0, 0, 2151, 2152, 3, 242, 121, 0, 2152, 2199, 1, 0, 0, 0,
		2153, 2159, 3, 242, 121, 0, 2154, 2156, 5, 263, 0, 0, 2155, 2157, 3, 196,
		98, 0, 2156, 2155, 1, 0, 0, 0, 2156, 2157, 1, 0, 0, 0, 2157, 2158, 1, 0,
		0, 0, 2158, 2160, 5, 273, 0, 0, 2159, 2154, 1, 0, 0, 0, 2159, 2160, 1,
		0, 0, 0, 2160, 2161, 1, 0, 0, 0, 2161, 2163, 5, 263, 0, 0, 2162, 2164,
		5, 54, 0, 0, 2163, 2162, 1, 0, 0, 0, 2163, 2164, 1, 0, 0, 0, 2164, 2166,
		1, 0, 0, 0, 2165, 2167, 3, 202, 101, 0, 2166, 2165, 1, 0, 0, 0, 2166, 2167,
		1, 0, 0, 0, 2167, 2168, 1, 0, 0, 0, 2168, 2169, 5, 273, 0, 0, 2169, 2199,
		1, 0, 0, 0, 2170, 2199, 3, 232, 116, 0, 2171, 2172, 5, 254, 0, 0, 2172,
		2199, 3, 200, 100, 15, 2173, 2174, 3, 218, 109, 0, 2174, 2175, 5, 255,
		0, 0, 2175, 2177, 1, 0, 0, 0, 2176, 2173, 1, 0, 0, 0, 2176, 2177, 1, 0,
		0, 0, 2177, 2178, 1, 0, 0, 0, 2178, 2199, 5, 247, 0, 0, 2179, 2180, 5,
		263, 0, 0, 2180, 2181, 3, 108, 54, 0, 2181, 2182, 5, 273, 0, 0, 2182, 2199,
		1, 0, 0, 0, 2183, 2184, 5, 263, 0, 0, 2184, 2185, 3, 200, 100, 0, 2185,
		2186, 5, 273, 0, 0, 2186, 2199, 1, 0, 0, 0, 2187, 2189, 5, 263, 0, 0, 2188,
		2190, 3, 196, 98, 0, 2189, 2188, 1, 0, 0, 0, 2189, 2190, 1, 0, 0, 0, 2190,
		2191, 1, 0, 0, 0, 2191, 2199, 5, 273, 0, 0, 2192, 2194, 5, 261, 0, 0, 2193,
		2195, 3, 196, 98, 0, 2194, 2193, 1, 0, 0, 0, 2194, 2195, 1, 0, 0, 0, 2195,
		2196, 1, 0, 0, 0, 2196, 2199, 5, 272, 0, 0, 2197, 2199, 3, 208, 104, 0,
		2198, 2068, 1, 0, 0, 0, 2198, 2088, 1, 0, 0, 0, 2198, 2095, 1, 0, 0, 0,
		2198, 2097, 1, 0, 0, 0, 2198, 2104, 1, 0, 0, 0, 2198, 2108, 1, 0, 0, 0,
		2198, 2119, 1, 0, 0, 0, 2198, 2121, 1, 0, 0, 0, 2198, 2129, 1, 0, 0, 0,
		2198, 2131, 1, 0, 0, 0, 2198, 2143, 1, 0, 0, 0, 2198, 2153, 1, 0, 0, 0,
		2198, 2170, 1, 0, 0, 0, 2198, 2171, 1, 0, 0, 0, 2198, 2176, 1, 0, 0, 0,
		2198, 2179, 1, 0, 0, 0, 2198, 2183, 1, 0, 0, 0, 2198, 2187, 1, 0, 0, 0,
		2198, 2192, 1, 0, 0, 0, 2198, 2197, 1, 0, 0, 0, 2199, 2278, 1, 0, 0, 0,
		2200, 2202, 10, 23, 0, 0, 2201, 2203, 5, 139, 0, 0, 2202, 2201, 1, 0, 0,
		0, 2202, 2203, 1, 0, 0, 0, 2203, 2204, 1, 0, 0, 0, 2204, 2205, 5, 17, 0,
		0, 2205, 2206, 3, 200, 100, 0, 2206, 2207, 5, 7, 0, 0, 2207, 2208, 3, 200,
		100, 24, 2208, 2277, 1, 0, 0, 0, 2209, 2210, 10, 14, 0, 0, 2210, 2211,
		7, 25, 0, 0, 2211, 2277, 3, 200, 100, 15, 2212, 2213, 10, 13, 0, 0, 2213,
		2214, 7, 26, 0, 0, 2214, 2277, 3, 200, 100, 14, 2215, 2234, 10, 12, 0,
		0, 2216, 2235, 5, 256, 0, 0, 2217, 2235, 5, 257, 0, 0, 2218, 2235, 5, 265,
		0, 0, 2219, 2235, 5, 262, 0, 0, 2220, 2235, 5, 258, 0, 0, 2221, 2235, 5,
		264, 0, 0, 2222, 2235, 5, 259, 0, 0, 2223, 2225, 5, 85, 0, 0, 2224, 2223,
		1, 0, 0, 0, 2224, 2225, 1, 0, 0, 0, 2225, 2227, 1, 0, 0, 0, 2226, 2228,
		5, 139, 0, 0, 2227, 2226, 1, 0, 0, 0, 2227, 2228, 1, 0, 0, 0, 2228, 2229,
		1, 0, 0, 0, 2229, 2235, 5, 97, 0, 0, 2230, 2232, 5, 139, 0, 0, 2231, 2230,
		1, 0, 0, 0, 2231, 2232, 1, 0, 0, 0, 2232, 2233, 1, 0, 0, 0, 2233, 2235,
		7, 18, 0, 0, 2234, 2216, 1, 0, 0, 0, 2234, 2217, 1, 0, 0, 0, 2234, 2218,
		1, 0, 0, 0, 2234, 2219, 1, 0, 0, 0, 2234, 2220, 1, 0, 0, 0, 2234, 2221,
		1, 0, 0, 0, 2234, 2222, 1, 0, 0, 0, 2234, 2224, 1, 0, 0, 0, 2234, 2231,
		1, 0, 0, 0, 2235, 2236, 1, 0, 0, 0, 2236, 2277, 3, 200, 100, 13, 2237,
		2238, 10, 10, 0, 0, 2238, 2239, 5, 7, 0, 0, 2239, 2277, 3, 200, 100, 11,
		2240, 2241, 10, 9, 0, 0, 2241, 2242, 5, 145, 0, 0, 2242, 2277, 3, 200,
		100, 10, 2243, 2244, 10, 8, 0, 0, 2244, 2245, 5, 268, 0, 0, 2245, 2246,
		3, 200, 100, 0, 2246, 2247, 5, 251, 0, 0, 2247, 2248, 3, 200, 100, 8, 2248,
		2277, 1, 0, 0, 0, 2249, 2250, 10, 30, 0, 0, 2250, 2251, 5, 250, 0, 0, 2251,
		2277, 3, 194, 97, 0, 2252, 2253, 10, 17, 0, 0, 2253, 2254, 5, 261, 0, 0,
		2254, 2255, 3, 200, 100, 0, 2255, 2256, 5, 272, 0, 0, 2256, 2277, 1, 0,
		0, 0, 2257, 2258, 10, 16, 0, 0, 2258, 2262, 5, 255, 0, 0, 2259, 2263, 5,
		242, 0, 0, 2260, 2263, 3, 230, 115, 0, 2261, 2263, 3, 242, 121, 0, 2262,
		2259, 1, 0, 0, 0, 2262, 2260, 1, 0, 0, 0, 2262, 2261, 1, 0, 0, 0, 2263,
		2277, 1, 0, 0, 0, 2264, 2265, 10, 11, 0, 0, 2265, 2267, 5, 108, 0, 0, 2266,
		2268, 5, 139, 0, 0, 2267, 2266, 1, 0, 0, 0, 2267, 2268, 1, 0, 0, 0, 2268,
		2269, 1, 0, 0, 0, 2269, 2277, 5, 140, 0, 0, 2270, 2274, 10, 7, 0, 0, 2271,
		2275, 3, 240, 120, 0, 2272, 2273, 5, 11, 0, 0, 2273, 2275, 3, 242, 121,
		0, 2274, 2271, 1, 0, 0, 0, 2274, 2272, 1, 0, 0, 0, 2275, 2277, 1, 0, 0,
		0, 2276, 2200, 1, 0, 0, 0, 2276, 2209, 1, 0, 0, 0, 2276, 2212, 1, 0, 0,
		0, 2276, 2215, 1, 0, 0, 0, 2276, 2237, 1, 0, 0, 0, 2276, 2240, 1, 0, 0,
		0, 2276, 2243, 1, 0, 0, 0, 2276, 2249, 1, 0, 0, 0, 2276, 2252, 1, 0, 0,
		0, 2276, 2257, 1, 0, 0, 0, 2276, 2264, 1, 0, 0, 0, 2276, 2270, 1, 0, 0,
		0, 2277, 2280, 1, 0, 0, 0, 2278, 2276, 1, 0, 0, 0, 2278, 2279, 1, 0, 0,
		0, 2279, 201, 1, 0, 0, 0, 2280, 2278, 1, 0, 0, 0, 2281, 2286, 3, 204, 102,
		0, 2282, 2283, 5, 252, 0, 0, 2283, 2285, 3, 204, 102, 0, 2284, 2282, 1,
		0, 0, 0, 2285, 2288, 1, 0, 0, 0, 2286, 2284, 1, 0, 0, 0, 2286, 2287, 1,
		0, 0, 0, 2287, 203, 1, 0, 0, 0, 2288, 2286, 1, 0, 0, 0, 2289, 2292, 3,
		206, 103, 0, 2290, 2292, 3, 200, 100, 0, 2291, 2289, 1, 0, 0, 0, 2291,
		2290, 1, 0, 0, 0, 2292, 205, 1, 0, 0, 0, 2293, 2294, 5, 263, 0, 0, 2294,
		2299, 3, 242, 121, 0, 2295, 2296, 5, 252, 0, 0, 2296, 2298, 3, 242, 121,
		0, 2297, 2295, 1, 0, 0, 0, 2298, 2301, 1, 0, 0, 0, 2299, 2297, 1, 0, 0,
		0, 2299, 2300, 1, 0, 0, 0, 2300, 2302, 1, 0, 0, 0, 2301, 2299, 1, 0, 0,
		0, 2302, 2303, 5, 273, 0, 0, 2303, 2313, 1, 0, 0, 0, 2304, 2309, 3, 242,
		121, 0, 2305, 2306, 5, 252, 0, 0, 2306, 2308, 3, 242, 121, 0, 2307, 2305,
		1, 0, 0, 0, 2308, 2311, 1, 0, 0, 0, 2309, 2307, 1, 0, 0, 0, 2309, 2310,
		1, 0, 0, 0, 2310, 2313, 1, 0, 0, 0, 2311, 2309, 1, 0, 0, 0, 2312, 2293,
		1, 0, 0, 0, 2312, 2304, 1, 0, 0, 0, 2313, 2314, 1, 0, 0, 0, 2314, 2315,
		5, 246, 0, 0, 2315, 2316, 3, 200, 100, 0, 2316, 207, 1, 0, 0, 0, 2317,
		2318, 3, 218, 109, 0, 2318, 2319, 5, 255, 0, 0, 2319, 2321, 1, 0, 0, 0,
		2320, 2317, 1, 0, 0, 0, 2320, 2321, 1, 0, 0, 0, 2321, 2322, 1, 0, 0, 0,
		2322, 2323, 3, 210, 105, 0, 2323, 209, 1, 0, 0, 0, 2324, 2329, 3, 242,
		121, 0, 2325, 2326, 5, 255, 0, 0, 2326, 2328, 3, 242, 121, 0, 2327, 2325,
		1, 0, 0, 0, 2328, 2331, 1, 0, 0, 0, 2329, 2327, 1, 0, 0, 0, 2329, 2330,
		1, 0, 0, 0, 2330, 211, 1, 0, 0, 0, 2331, 2329, 1, 0, 0, 0, 2332, 2338,
		5, 64, 0, 0, 2333, 2339, 3, 230, 115, 0, 2334, 2335, 5, 263, 0, 0, 2335,
		2336, 3, 230, 115, 0, 2336, 2337, 5, 273, 0, 0, 2337, 2339, 1, 0, 0, 0,
		2338, 2333, 1, 0, 0, 0, 2338, 2334, 1, 0, 0, 0, 2339, 2356, 1, 0, 0, 0,
		2340, 2353, 5, 64, 0, 0, 2341, 2354, 3, 242, 121, 0, 2342, 2343, 5, 263,
		0, 0, 2343, 2348, 3, 242, 121, 0, 2344, 2345, 5, 252, 0, 0, 2345, 2347,
		3, 242, 121, 0, 2346, 2344, 1, 0, 0, 0, 2347, 2350, 1, 0, 0, 0, 2348, 2346,
		1, 0, 0, 0, 2348, 2349, 1, 0, 0, 0, 2349, 2351, 1, 0, 0, 0, 2350, 2348,
		1, 0, 0, 0, 2351, 2352, 5, 273, 0, 0, 2352, 2354, 1, 0, 0, 0, 2353, 2341,
		1, 0, 0, 0, 2353, 2342, 1, 0, 0, 0, 2354, 2356, 1, 0, 0, 0, 2355, 2332,
		1, 0, 0, 0, 2355, 2340, 1, 0, 0, 0, 2356, 213, 1, 0, 0, 0, 2357, 2358,
		6, 107, -1, 0, 2358, 2365, 3, 218, 109, 0, 2359, 2365, 3, 216, 108, 0,
		2360, 2361, 5, 263, 0, 0, 2361, 2362, 3, 108, 54, 0, 2362, 2363, 5, 273,
		0, 0, 2363, 2365, 1, 0, 0, 0, 2364, 2357, 1, 0, 0, 0, 2364, 2359, 1, 0,
		0, 0, 2364, 2360, 1, 0, 0, 0, 2365, 2374, 1, 0, 0, 0, 2366, 2370, 10, 1,
		0, 0, 2367, 2371, 3, 240, 120, 0, 2368, 2369, 5, 11, 0, 0, 2369, 2371,
		3, 242, 121, 0, 2370, 2367, 1, 0, 0, 0, 2370, 2368, 1, 0, 0, 0, 2371, 2373,
		1, 0, 0, 0, 2372, 2366, 1, 0, 0, 0, 2373, 2376, 1, 0, 0, 0, 2374, 2372,
		1, 0, 0, 0, 2374, 2375, 1, 0, 0, 0, 2375, 215, 1, 0, 0, 0, 2376, 2374,
		1, 0, 0, 0, 2377, 2378, 3, 242, 121, 0, 2378, 2380, 5, 263, 0, 0, 2379,
		2381, 3, 220, 110, 0, 2380, 2379, 1, 0, 0, 0, 2380, 2381, 1, 0, 0, 0, 2381,
		2382, 1, 0, 0, 0, 2382, 2383, 5, 273, 0, 0, 2383, 217, 1, 0, 0, 0, 2384,
		2385, 3, 224, 112, 0, 2385, 2386, 5, 255, 0, 0, 2386, 2388, 1, 0, 0, 0,
		2387, 2384, 1, 0, 0, 0, 2387, 2388, 1, 0, 0, 0, 2388, 2389, 1, 0, 0, 0,
		2389, 2390, 3, 242, 121, 0, 2390, 219, 1, 0, 0, 0, 2391, 2396, 3, 222,
		111, 0, 2392, 2393, 5, 252, 0, 0, 2393, 2395, 3, 222, 111, 0, 2394, 2392,
		1, 0, 0, 0, 2395, 2398, 1, 0, 0, 0, 2396, 2394, 1, 0, 0, 0, 2396, 2397,
		1, 0, 0, 0, 2397, 221, 1, 0, 0, 0, 2398, 2396, 1, 0, 0, 0, 2399, 2403,
		3, 216, 108, 0, 2400, 2403, 3, 232, 116, 0, 2401, 2403, 3, 210, 105, 0,
		2402, 2399, 1, 0, 0, 0, 2402, 2400, 1, 0, 0, 0, 2402, 2401, 1, 0, 0, 0,
		2403, 223, 1, 0, 0, 0, 2404, 2405, 3, 242, 121, 0, 2405, 225, 1, 0, 0,
		0, 2406, 2415, 5, 240, 0, 0, 2407, 2408, 5, 255, 0, 0, 2408, 2415, 7, 27,
		0, 0, 2409, 2410, 5, 242, 0, 0, 2410, 2412, 5, 255, 0, 0, 2411, 2413, 7,
		27, 0, 0, 2412, 2411, 1, 0, 0, 0, 2412, 2413, 1, 0, 0, 0, 2413, 2415, 1,
		0, 0, 0, 2414, 2406, 1, 0, 0, 0, 2414, 2407, 1, 0, 0, 0, 2414, 2409, 1,
		0, 0, 0, 2415, 227, 1, 0, 0, 0, 2416, 2418, 7, 28, 0, 0, 2417, 2416, 1,
		0, 0, 0, 2417, 2418, 1, 0, 0, 0, 2418, 2426, 1, 0, 0, 0, 2419, 2427, 3,
		226, 113, 0, 2420, 2427, 5, 241, 0, 0, 2421, 2427, 5, 242, 0, 0, 2422,
		2427, 5, 243, 0, 0, 2423, 2427, 5, 244, 0, 0, 2424, 2427, 5, 101, 0, 0,
		2425, 2427, 5, 136, 0, 0, 2426, 2419, 1, 0, 0, 0, 2426, 2420, 1, 0, 0,
		0, 2426, 2421, 1, 0, 0, 0, 2426, 2422, 1, 0, 0, 0, 2426, 2423, 1, 0, 0,
		0, 2426, 2424, 1, 0, 0, 0, 2426, 2425, 1, 0, 0, 0, 2427, 229, 1, 0, 0,
		0, 2428, 2429, 7, 29, 0, 0, 2429, 231, 1, 0, 0, 0, 2430, 2436, 3, 228,
		114, 0, 2431, 2436, 5, 235, 0, 0, 2432, 2436, 5, 236, 0, 0, 2433, 2436,
		3, 230, 115, 0, 2434, 2436, 5, 140, 0, 0, 2435, 2430, 1, 0, 0, 0, 2435,
		2431, 1, 0, 0, 0, 2435, 2432, 1, 0, 0, 0, 2435, 2433, 1, 0, 0, 0, 2435,
		2434, 1, 0, 0, 0, 2436, 233, 1, 0, 0, 0, 2437, 2438, 7, 30, 0, 0, 2438,
		235, 1, 0, 0, 0, 2439, 2440, 7, 31, 0, 0, 2440, 237, 1, 0, 0, 0, 2441,
		2442, 7, 32, 0, 0, 2442, 239, 1, 0, 0, 0, 2443, 2446, 5, 239, 0, 0, 2444,
		2446, 3, 238, 119, 0, 2445, 2443, 1, 0, 0, 0, 2445, 2444, 1, 0, 0, 0, 2446,
		241, 1, 0, 0, 0, 2447, 2451, 5, 239, 0, 0, 2448, 2451, 3, 234, 117, 0,
		2449, 2451, 3, 236, 118, 0, 2450, 2447, 1, 0, 0, 0, 2450, 2448, 1, 0, 0,
		0, 2450, 2449, 1, 0, 0, 0, 2451, 243, 1, 0, 0, 0, 2452, 2455, 3, 242, 121,
		0, 2453, 2455, 5, 140, 0, 0, 2454, 2452, 1, 0, 0, 0, 2454, 2453, 1, 0,
		0, 0, 2455, 245, 1, 0, 0, 0, 2456, 2457, 3, 230, 115, 0, 2457, 2458, 5,
		257, 0, 0, 2458, 2459, 3, 228, 114, 0, 2459, 247, 1, 0, 0, 0, 337, 252,
		256, 259, 262, 282, 288, 295, 303, 308, 315, 320, 327, 332, 338, 344, 349,
		355, 360, 366, 371, 377, 391, 398, 405, 412, 418, 423, 429, 434, 440, 449,
		459, 469, 489, 497, 512, 519, 533, 539, 545, 552, 556, 559, 565, 568, 574,
		578, 581, 592, 596, 599, 604, 606, 609, 612, 622, 626, 629, 632, 637, 639,
		647, 650, 653, 659, 663, 666, 669, 672, 675, 680, 686, 690, 693, 696, 700,
		708, 735, 737, 742, 764, 766, 777, 780, 789, 806, 817, 835, 848, 865, 874,
		902, 904, 925, 930, 935, 938, 950, 955, 959, 962, 966, 970, 975, 978, 982,
		984, 1006, 1014, 1017, 1022, 1030, 1040, 1043, 1051, 1059, 1063, 1068,
		1072, 1076, 1080, 1084, 1086, 1094, 1098, 1101, 1113, 1116, 1123, 1128,
		1131, 1141, 1154, 1159, 1163, 1171, 1178, 1185, 1189, 1195, 1198, 1201,
		1204, 1218, 1222, 1226, 1231, 1234, 1244, 1252, 1255, 1259, 1262, 1266,
		1269, 1272, 1275, 1278, 1281, 1285, 1289, 1292, 1295, 1298, 1301, 1304,
		1307, 1317, 1321, 1333, 1339, 1345, 1385, 1412, 1420, 1423, 1429, 1437,
		1440, 1446, 1448, 1452, 1457, 1460, 1463, 1467, 1471, 1474, 1476, 1479,
		1483, 1487, 1490, 1492, 1494, 1497, 1502, 1513, 1519, 1524, 1531, 1536,
		1540, 1544, 1550, 1554, 1558, 1560, 1565, 1572, 1580, 1583, 1586, 1605,
		1619, 1626, 1636, 1643, 1649, 1653, 1659, 1662, 1668, 1672, 1676, 1679,
		1684, 1687, 1693, 1697, 1701, 1704, 1713, 1716, 1722, 1726, 1730, 1739,
		1743, 1755, 1758, 1762, 1765, 1775, 1779, 1789, 1795, 1805, 1816, 1820,
		1825, 1833, 1840, 1845, 1850, 1855, 1861, 1872, 1876, 1880, 1884, 1901,
		1906, 1910, 1914, 1922, 1925, 1927, 1930, 1952, 1955, 1966, 1970, 1973,
		1977, 1981, 1989, 1993, 2006, 2018, 2030, 2038, 2042, 2049, 2055, 2059,
		2066, 2071, 2080, 2084, 2115, 2134, 2146, 2156, 2159, 2163, 2166, 2176,
		2189, 2194, 2198, 2202, 2224, 2227, 2231, 2234, 2262, 2267, 2274, 2276,
		2278, 2286, 2291, 2299, 2309, 2312, 2320, 2329, 2338, 2348, 2353, 2355,
		2364, 2370, 2374, 2380, 2387, 2396, 2402, 2412, 2414, 2417, 2426, 2435,
		2445, 2450, 2454,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ClickHouseParserInit initializes any static state used to implement ClickHouseParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewClickHouseParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func ClickHouseParserInit() {
	staticData := &ClickHouseParserParserStaticData
	staticData.once.Do(clickhouseparserParserInit)
}

// NewClickHouseParser produces a new parser instance for the optional input antlr.TokenStream.
func NewClickHouseParser(input antlr.TokenStream) *ClickHouseParser {
	ClickHouseParserInit()
	this := new(ClickHouseParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ClickHouseParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "ClickHouseParser.g4"

	return this
}

// ClickHouseParser tokens.
const (
	ClickHouseParserEOF                         = antlr.TokenEOF
	ClickHouseParserACCESS                      = 1
	ClickHouseParserADD                         = 2
	ClickHouseParserAFTER                       = 3
	ClickHouseParserALIAS                       = 4
	ClickHouseParserALL                         = 5
	ClickHouseParserALTER                       = 6
	ClickHouseParserAND                         = 7
	ClickHouseParserANTI                        = 8
	ClickHouseParserANY                         = 9
	ClickHouseParserARRAY                       = 10
	ClickHouseParserAS                          = 11
	ClickHouseParserASCENDING                   = 12
	ClickHouseParserASOF                        = 13
	ClickHouseParserAST                         = 14
	ClickHouseParserASYNC                       = 15
	ClickHouseParserATTACH                      = 16
	ClickHouseParserBETWEEN                     = 17
	ClickHouseParserBOTH                        = 18
	ClickHouseParserBY                          = 19
	ClickHouseParserCACHES                      = 20
	ClickHouseParserCASE                        = 21
	ClickHouseParserCAST                        = 22
	ClickHouseParserCHECK                       = 23
	ClickHouseParserCLEAR                       = 24
	ClickHouseParserCLUSTER                     = 25
	ClickHouseParserCLUSTERS                    = 26
	ClickHouseParserCODEC                       = 27
	ClickHouseParserCOLLATE                     = 28
	ClickHouseParserCOLUMN                      = 29
	ClickHouseParserCOLUMNS                     = 30
	ClickHouseParserCOMMENT                     = 31
	ClickHouseParserCONSTRAINT                  = 32
	ClickHouseParserCREATE                      = 33
	ClickHouseParserCROSS                       = 34
	ClickHouseParserCUBE                        = 35
	ClickHouseParserCURRENT                     = 36
	ClickHouseParserCURRENT_USER                = 37
	ClickHouseParserCHANGED                     = 38
	ClickHouseParserDATABASE                    = 39
	ClickHouseParserDATABASES                   = 40
	ClickHouseParserDATE                        = 41
	ClickHouseParserDAY                         = 42
	ClickHouseParserDEDUPLICATE                 = 43
	ClickHouseParserDEFAULT                     = 44
	ClickHouseParserDELAY                       = 45
	ClickHouseParserDELETE                      = 46
	ClickHouseParserDESC                        = 47
	ClickHouseParserDESCENDING                  = 48
	ClickHouseParserDESCRIBE                    = 49
	ClickHouseParserDETACH                      = 50
	ClickHouseParserDICTIONARIES                = 51
	ClickHouseParserDICTIONARY                  = 52
	ClickHouseParserDISK                        = 53
	ClickHouseParserDISTINCT                    = 54
	ClickHouseParserDISTRIBUTED                 = 55
	ClickHouseParserDROP                        = 56
	ClickHouseParserELSE                        = 57
	ClickHouseParserENABLED                     = 58
	ClickHouseParserEND                         = 59
	ClickHouseParserENGINE                      = 60
	ClickHouseParserENGINES                     = 61
	ClickHouseParserESTIMATE                    = 62
	ClickHouseParserEVENTS                      = 63
	ClickHouseParserEXCEPT                      = 64
	ClickHouseParserEXISTS                      = 65
	ClickHouseParserEXPLAIN                     = 66
	ClickHouseParserEXPRESSION                  = 67
	ClickHouseParserEXTENDED                    = 68
	ClickHouseParserEXTRACT                     = 69
	ClickHouseParserFETCHES                     = 70
	ClickHouseParserFIELDS                      = 71
	ClickHouseParserFILESYSTEM                  = 72
	ClickHouseParserFILL                        = 73
	ClickHouseParserFINAL                       = 74
	ClickHouseParserFIRST                       = 75
	ClickHouseParserFLUSH                       = 76
	ClickHouseParserFOLLOWING                   = 77
	ClickHouseParserFOR                         = 78
	ClickHouseParserFORMAT                      = 79
	ClickHouseParserFREEZE                      = 80
	ClickHouseParserFROM                        = 81
	ClickHouseParserFULL                        = 82
	ClickHouseParserFUNCTION                    = 83
	ClickHouseParserFUNCTIONS                   = 84
	ClickHouseParserGLOBAL                      = 85
	ClickHouseParserGRANULARITY                 = 86
	ClickHouseParserGRANTS                      = 87
	ClickHouseParserGROUP                       = 88
	ClickHouseParserGROUPING                    = 89
	ClickHouseParserHAVING                      = 90
	ClickHouseParserHIERARCHICAL                = 91
	ClickHouseParserHOUR                        = 92
	ClickHouseParserID                          = 93
	ClickHouseParserIF                          = 94
	ClickHouseParserILIKE                       = 95
	ClickHouseParserIMPLICIT                    = 96
	ClickHouseParserIN                          = 97
	ClickHouseParserINDEX                       = 98
	ClickHouseParserINDEXES                     = 99
	ClickHouseParserINDICES                     = 100
	ClickHouseParserINF                         = 101
	ClickHouseParserINJECTIVE                   = 102
	ClickHouseParserINNER                       = 103
	ClickHouseParserINSERT                      = 104
	ClickHouseParserINTERPOLATE                 = 105
	ClickHouseParserINTERVAL                    = 106
	ClickHouseParserINTO                        = 107
	ClickHouseParserIS                          = 108
	ClickHouseParserIS_OBJECT_ID                = 109
	ClickHouseParserJOIN                        = 110
	ClickHouseParserKEY                         = 111
	ClickHouseParserKEYS                        = 112
	ClickHouseParserKILL                        = 113
	ClickHouseParserLAST                        = 114
	ClickHouseParserLAYOUT                      = 115
	ClickHouseParserLEADING                     = 116
	ClickHouseParserLEFT                        = 117
	ClickHouseParserLIFETIME                    = 118
	ClickHouseParserLIKE                        = 119
	ClickHouseParserLIMIT                       = 120
	ClickHouseParserLIVE                        = 121
	ClickHouseParserLOCAL                       = 122
	ClickHouseParserLOGS                        = 123
	ClickHouseParserMATERIALIZE                 = 124
	ClickHouseParserMATERIALIZED                = 125
	ClickHouseParserMAX                         = 126
	ClickHouseParserMERGES                      = 127
	ClickHouseParserMICROSECOND                 = 128
	ClickHouseParserMILLISECOND                 = 129
	ClickHouseParserMIN                         = 130
	ClickHouseParserMINUTE                      = 131
	ClickHouseParserMODIFY                      = 132
	ClickHouseParserMONTH                       = 133
	ClickHouseParserMOVE                        = 134
	ClickHouseParserMUTATION                    = 135
	ClickHouseParserNAN_SQL                     = 136
	ClickHouseParserNANOSECOND                  = 137
	ClickHouseParserNO                          = 138
	ClickHouseParserNOT                         = 139
	ClickHouseParserNULL_SQL                    = 140
	ClickHouseParserNULLS                       = 141
	ClickHouseParserOFFSET                      = 142
	ClickHouseParserON                          = 143
	ClickHouseParserOPTIMIZE                    = 144
	ClickHouseParserOR                          = 145
	ClickHouseParserORDER                       = 146
	ClickHouseParserOUTER                       = 147
	ClickHouseParserOUTFILE                     = 148
	ClickHouseParserOVER                        = 149
	ClickHouseParserOVERRIDE                    = 150
	ClickHouseParserPARTITION                   = 151
	ClickHouseParserPIPELINE                    = 152
	ClickHouseParserPLAN                        = 153
	ClickHouseParserPOLICY                      = 154
	ClickHouseParserPOLICIES                    = 155
	ClickHouseParserPOPULATE                    = 156
	ClickHouseParserPRECEDING                   = 157
	ClickHouseParserPREWHERE                    = 158
	ClickHouseParserPRIMARY                     = 159
	ClickHouseParserPRIVILEGES                  = 160
	ClickHouseParserPROCESSLIST                 = 161
	ClickHouseParserPROFILE                     = 162
	ClickHouseParserPROFILES                    = 163
	ClickHouseParserPROJECTION                  = 164
	ClickHouseParserQUARTER                     = 165
	ClickHouseParserQUOTA                       = 166
	ClickHouseParserQUOTAS                      = 167
	ClickHouseParserRANGE                       = 168
	ClickHouseParserRECURSIVE                   = 169
	ClickHouseParserRELOAD                      = 170
	ClickHouseParserREMOVE                      = 171
	ClickHouseParserRENAME                      = 172
	ClickHouseParserREPLACE                     = 173
	ClickHouseParserREPLICA                     = 174
	ClickHouseParserREPLICATED                  = 175
	ClickHouseParserRIGHT                       = 176
	ClickHouseParserROLE                        = 177
	ClickHouseParserROLES                       = 178
	ClickHouseParserROLLUP                      = 179
	ClickHouseParserROW                         = 180
	ClickHouseParserROWS                        = 181
	ClickHouseParserSAMPLE                      = 182
	ClickHouseParserSECOND                      = 183
	ClickHouseParserSELECT                      = 184
	ClickHouseParserSEMI                        = 185
	ClickHouseParserSENDS                       = 186
	ClickHouseParserSET                         = 187
	ClickHouseParserSETS                        = 188
	ClickHouseParserSETTING                     = 189
	ClickHouseParserSETTINGS                    = 190
	ClickHouseParserSHOW                        = 191
	ClickHouseParserSOURCE                      = 192
	ClickHouseParserSTART                       = 193
	ClickHouseParserSTOP                        = 194
	ClickHouseParserSUBSTRING                   = 195
	ClickHouseParserSYNC                        = 196
	ClickHouseParserSYNTAX                      = 197
	ClickHouseParserSYSTEM                      = 198
	ClickHouseParserSTEP                        = 199
	ClickHouseParserTABLE                       = 200
	ClickHouseParserTABLES                      = 201
	ClickHouseParserTEMPORARY                   = 202
	ClickHouseParserTEST                        = 203
	ClickHouseParserTHEN                        = 204
	ClickHouseParserTIES                        = 205
	ClickHouseParserTIMEOUT                     = 206
	ClickHouseParserTIMESTAMP                   = 207
	ClickHouseParserTO                          = 208
	ClickHouseParserTOP                         = 209
	ClickHouseParserTOTALS                      = 210
	ClickHouseParserTRAILING                    = 211
	ClickHouseParserTREE                        = 212
	ClickHouseParserTRIM                        = 213
	ClickHouseParserTRUNCATE                    = 214
	ClickHouseParserTTL                         = 215
	ClickHouseParserTYPE                        = 216
	ClickHouseParserUNBOUNDED                   = 217
	ClickHouseParserUNION                       = 218
	ClickHouseParserUPDATE                      = 219
	ClickHouseParserUSE                         = 220
	ClickHouseParserUSER                        = 221
	ClickHouseParserUSERS                       = 222
	ClickHouseParserUSING                       = 223
	ClickHouseParserUUID                        = 224
	ClickHouseParserVALUES                      = 225
	ClickHouseParserVIEW                        = 226
	ClickHouseParserVOLUME                      = 227
	ClickHouseParserWATCH                       = 228
	ClickHouseParserWEEK                        = 229
	ClickHouseParserWHEN                        = 230
	ClickHouseParserWHERE                       = 231
	ClickHouseParserWINDOW                      = 232
	ClickHouseParserWITH                        = 233
	ClickHouseParserYEAR                        = 234
	ClickHouseParserJSON_FALSE                  = 235
	ClickHouseParserJSON_TRUE                   = 236
	ClickHouseParserHEXADECIMAL_STRING_LITERAL  = 237
	ClickHouseParserBINARY_STRING_LITERAL       = 238
	ClickHouseParserIDENTIFIER                  = 239
	ClickHouseParserFLOATING_LITERAL            = 240
	ClickHouseParserOCTAL_LITERAL               = 241
	ClickHouseParserDECIMAL_LITERAL             = 242
	ClickHouseParserHEXADECIMAL_NUMERIC_LITERAL = 243
	ClickHouseParserBINARY_NUMERIC_LITERAL      = 244
	ClickHouseParserSTRING_LITERAL              = 245
	ClickHouseParserARROW                       = 246
	ClickHouseParserASTERISK                    = 247
	ClickHouseParserBACKQUOTE                   = 248
	ClickHouseParserBACKSLASH                   = 249
	ClickHouseParserDOUBLE_COLON                = 250
	ClickHouseParserCOLON                       = 251
	ClickHouseParserCOMMA                       = 252
	ClickHouseParserCONCAT                      = 253
	ClickHouseParserDASH                        = 254
	ClickHouseParserDOT                         = 255
	ClickHouseParserEQ_DOUBLE                   = 256
	ClickHouseParserEQ_SINGLE                   = 257
	ClickHouseParserGE                          = 258
	ClickHouseParserGT                          = 259
	ClickHouseParserLBRACE                      = 260
	ClickHouseParserLBRACKET                    = 261
	ClickHouseParserLE                          = 262
	ClickHouseParserLPAREN                      = 263
	ClickHouseParserLT                          = 264
	ClickHouseParserNOT_EQ                      = 265
	ClickHouseParserPERCENT                     = 266
	ClickHouseParserPLUS                        = 267
	ClickHouseParserQUERY                       = 268
	ClickHouseParserQUOTE_DOUBLE                = 269
	ClickHouseParserQUOTE_SINGLE                = 270
	ClickHouseParserRBRACE                      = 271
	ClickHouseParserRBRACKET                    = 272
	ClickHouseParserRPAREN                      = 273
	ClickHouseParserSEMICOLON                   = 274
	ClickHouseParserSLASH                       = 275
	ClickHouseParserUNDERSCORE                  = 276
	ClickHouseParserMULTI_LINE_COMMENT          = 277
	ClickHouseParserSINGLE_LINE_COMMENT         = 278
	ClickHouseParserWHITESPACE                  = 279
)

// ClickHouseParser rules.
const (
	ClickHouseParserRULE_queryStmt                  = 0
	ClickHouseParserRULE_query                      = 1
	ClickHouseParserRULE_alterStmt                  = 2
	ClickHouseParserRULE_alterTableClause           = 3
	ClickHouseParserRULE_assignmentExprList         = 4
	ClickHouseParserRULE_assignmentExpr             = 5
	ClickHouseParserRULE_tableColumnPropertyType    = 6
	ClickHouseParserRULE_partitionClause            = 7
	ClickHouseParserRULE_attachStmt                 = 8
	ClickHouseParserRULE_checkStmt                  = 9
	ClickHouseParserRULE_createStmt                 = 10
	ClickHouseParserRULE_dictionarySchemaClause     = 11
	ClickHouseParserRULE_dictionaryAttrDfnt         = 12
	ClickHouseParserRULE_dictionaryEngineClause     = 13
	ClickHouseParserRULE_dictionaryPrimaryKeyClause = 14
	ClickHouseParserRULE_dictionaryArgExpr          = 15
	ClickHouseParserRULE_sourceClause               = 16
	ClickHouseParserRULE_lifetimeClause             = 17
	ClickHouseParserRULE_layoutClause               = 18
	ClickHouseParserRULE_rangeClause                = 19
	ClickHouseParserRULE_dictionarySettingsClause   = 20
	ClickHouseParserRULE_clusterClause              = 21
	ClickHouseParserRULE_uuidClause                 = 22
	ClickHouseParserRULE_destinationClause          = 23
	ClickHouseParserRULE_subqueryClause             = 24
	ClickHouseParserRULE_tableSchemaClause          = 25
	ClickHouseParserRULE_engineClause               = 26
	ClickHouseParserRULE_partitionByClause          = 27
	ClickHouseParserRULE_primaryKeyClause           = 28
	ClickHouseParserRULE_sampleByClause             = 29
	ClickHouseParserRULE_ttlClause                  = 30
	ClickHouseParserRULE_engineExpr                 = 31
	ClickHouseParserRULE_tableElementExpr           = 32
	ClickHouseParserRULE_tableColumnDfnt            = 33
	ClickHouseParserRULE_tableColumnPropertyExpr    = 34
	ClickHouseParserRULE_tableIndexDfnt             = 35
	ClickHouseParserRULE_tableProjectionDfnt        = 36
	ClickHouseParserRULE_codecExpr                  = 37
	ClickHouseParserRULE_codecArgExpr               = 38
	ClickHouseParserRULE_ttlExpr                    = 39
	ClickHouseParserRULE_ttlSetExpr                 = 40
	ClickHouseParserRULE_describeStmt               = 41
	ClickHouseParserRULE_dropStmt                   = 42
	ClickHouseParserRULE_existsStmt                 = 43
	ClickHouseParserRULE_explainStmt                = 44
	ClickHouseParserRULE_insertStmt                 = 45
	ClickHouseParserRULE_columnsClause              = 46
	ClickHouseParserRULE_dataClause                 = 47
	ClickHouseParserRULE_assignmentValues           = 48
	ClickHouseParserRULE_assignmentValue            = 49
	ClickHouseParserRULE_killStmt                   = 50
	ClickHouseParserRULE_optimizeStmt               = 51
	ClickHouseParserRULE_renameStmt                 = 52
	ClickHouseParserRULE_projectionSelectStmt       = 53
	ClickHouseParserRULE_selectUnionStmt            = 54
	ClickHouseParserRULE_selectStmtWithParens       = 55
	ClickHouseParserRULE_selectStmt                 = 56
	ClickHouseParserRULE_withClause                 = 57
	ClickHouseParserRULE_withExprList               = 58
	ClickHouseParserRULE_withExpr                   = 59
	ClickHouseParserRULE_topClause                  = 60
	ClickHouseParserRULE_fromClause                 = 61
	ClickHouseParserRULE_arrayJoinClause            = 62
	ClickHouseParserRULE_windowClause               = 63
	ClickHouseParserRULE_prewhereClause             = 64
	ClickHouseParserRULE_whereClause                = 65
	ClickHouseParserRULE_groupByClause              = 66
	ClickHouseParserRULE_havingClause               = 67
	ClickHouseParserRULE_orderByClause              = 68
	ClickHouseParserRULE_interpolateClause          = 69
	ClickHouseParserRULE_projectionOrderByClause    = 70
	ClickHouseParserRULE_limitByClause              = 71
	ClickHouseParserRULE_limitClause                = 72
	ClickHouseParserRULE_settingsClause             = 73
	ClickHouseParserRULE_joinExpr                   = 74
	ClickHouseParserRULE_joinOp                     = 75
	ClickHouseParserRULE_joinOpCross                = 76
	ClickHouseParserRULE_joinConstraintClause       = 77
	ClickHouseParserRULE_sampleClause               = 78
	ClickHouseParserRULE_limitExpr                  = 79
	ClickHouseParserRULE_orderExprList              = 80
	ClickHouseParserRULE_orderExpr                  = 81
	ClickHouseParserRULE_ratioExpr                  = 82
	ClickHouseParserRULE_settingExprList            = 83
	ClickHouseParserRULE_settingExpr                = 84
	ClickHouseParserRULE_windowExpr                 = 85
	ClickHouseParserRULE_winPartitionByClause       = 86
	ClickHouseParserRULE_winOrderByClause           = 87
	ClickHouseParserRULE_winFrameClause             = 88
	ClickHouseParserRULE_winFrameExtend             = 89
	ClickHouseParserRULE_winFrameBound              = 90
	ClickHouseParserRULE_setStmt                    = 91
	ClickHouseParserRULE_showStmt                   = 92
	ClickHouseParserRULE_systemStmt                 = 93
	ClickHouseParserRULE_truncateStmt               = 94
	ClickHouseParserRULE_useStmt                    = 95
	ClickHouseParserRULE_watchStmt                  = 96
	ClickHouseParserRULE_columnTypeExpr             = 97
	ClickHouseParserRULE_columnExprList             = 98
	ClickHouseParserRULE_columnsExpr                = 99
	ClickHouseParserRULE_columnExpr                 = 100
	ClickHouseParserRULE_columnArgList              = 101
	ClickHouseParserRULE_columnArgExpr              = 102
	ClickHouseParserRULE_columnLambdaExpr           = 103
	ClickHouseParserRULE_columnIdentifier           = 104
	ClickHouseParserRULE_nestedIdentifier           = 105
	ClickHouseParserRULE_columnExceptExpr           = 106
	ClickHouseParserRULE_tableExpr                  = 107
	ClickHouseParserRULE_tableFunctionExpr          = 108
	ClickHouseParserRULE_tableIdentifier            = 109
	ClickHouseParserRULE_tableArgList               = 110
	ClickHouseParserRULE_tableArgExpr               = 111
	ClickHouseParserRULE_databaseIdentifier         = 112
	ClickHouseParserRULE_floatingLiteral            = 113
	ClickHouseParserRULE_numberLiteral              = 114
	ClickHouseParserRULE_stringLiteral              = 115
	ClickHouseParserRULE_literal                    = 116
	ClickHouseParserRULE_interval                   = 117
	ClickHouseParserRULE_keyword                    = 118
	ClickHouseParserRULE_keywordForAlias            = 119
	ClickHouseParserRULE_alias                      = 120
	ClickHouseParserRULE_identifier                 = 121
	ClickHouseParserRULE_identifierOrNull           = 122
	ClickHouseParserRULE_enumValue                  = 123
)

// IQueryStmtContext is an interface to support dynamic dispatch.
type IQueryStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryStmtContext differentiates from other interfaces.
	IsQueryStmtContext()
}

type QueryStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStmtContext() *QueryStmtContext {
	var p = new(QueryStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_queryStmt
	return p
}

func InitEmptyQueryStmtContext(p *QueryStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_queryStmt
}

func (*QueryStmtContext) IsQueryStmtContext() {}

func NewQueryStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStmtContext {
	var p = new(QueryStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_queryStmt

	return p
}

func (s *QueryStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStmtContext) CopyAll(ctx *QueryStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryStmtInsertContext struct {
	QueryStmtContext
}

func NewQueryStmtInsertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryStmtInsertContext {
	var p = new(QueryStmtInsertContext)

	InitEmptyQueryStmtContext(&p.QueryStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryStmtContext))

	return p
}

func (s *QueryStmtInsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStmtInsertContext) InsertStmt() IInsertStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStmtContext)
}

func (s *QueryStmtInsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterQueryStmtInsert(s)
	}
}

func (s *QueryStmtInsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitQueryStmtInsert(s)
	}
}

type QueryStmtQueryContext struct {
	QueryStmtContext
}

func NewQueryStmtQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryStmtQueryContext {
	var p = new(QueryStmtQueryContext)

	InitEmptyQueryStmtContext(&p.QueryStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryStmtContext))

	return p
}

func (s *QueryStmtQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStmtQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QueryStmtQueryContext) INTO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTO, 0)
}

func (s *QueryStmtQueryContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTFILE, 0)
}

func (s *QueryStmtQueryContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *QueryStmtQueryContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFORMAT, 0)
}

func (s *QueryStmtQueryContext) IdentifierOrNull() IIdentifierOrNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrNullContext)
}

func (s *QueryStmtQueryContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSEMICOLON, 0)
}

func (s *QueryStmtQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterQueryStmtQuery(s)
	}
}

func (s *QueryStmtQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitQueryStmtQuery(s)
	}
}

func (p *ClickHouseParser) QueryStmt() (localctx IQueryStmtContext) {
	localctx = NewQueryStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ClickHouseParserRULE_queryStmt)
	var _la int

	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserALTER, ClickHouseParserATTACH, ClickHouseParserCHECK, ClickHouseParserCREATE, ClickHouseParserDESC, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDROP, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserKILL, ClickHouseParserOPTIMIZE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserSELECT, ClickHouseParserSET, ClickHouseParserSHOW, ClickHouseParserSYSTEM, ClickHouseParserTRUNCATE, ClickHouseParserUSE, ClickHouseParserWATCH, ClickHouseParserWITH, ClickHouseParserLPAREN:
		localctx = NewQueryStmtQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(248)
			p.Query()
		}
		p.SetState(252)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserINTO {
			{
				p.SetState(249)
				p.Match(ClickHouseParserINTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(250)
				p.Match(ClickHouseParserOUTFILE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(251)
				p.StringLiteral()
			}

		}
		p.SetState(256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFORMAT {
			{
				p.SetState(254)
				p.Match(ClickHouseParserFORMAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(255)
				p.IdentifierOrNull()
			}

		}
		p.SetState(259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserSEMICOLON {
			{
				p.SetState(258)
				p.Match(ClickHouseParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case ClickHouseParserINSERT:
		localctx = NewQueryStmtInsertContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(261)
			p.InsertStmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterStmt() IAlterStmtContext
	AttachStmt() IAttachStmtContext
	CheckStmt() ICheckStmtContext
	CreateStmt() ICreateStmtContext
	DescribeStmt() IDescribeStmtContext
	DropStmt() IDropStmtContext
	ExistsStmt() IExistsStmtContext
	ExplainStmt() IExplainStmtContext
	KillStmt() IKillStmtContext
	OptimizeStmt() IOptimizeStmtContext
	RenameStmt() IRenameStmtContext
	SelectUnionStmt() ISelectUnionStmtContext
	SetStmt() ISetStmtContext
	ShowStmt() IShowStmtContext
	SystemStmt() ISystemStmtContext
	TruncateStmt() ITruncateStmtContext
	UseStmt() IUseStmtContext
	WatchStmt() IWatchStmtContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) AlterStmt() IAlterStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStmtContext)
}

func (s *QueryContext) AttachStmt() IAttachStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttachStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttachStmtContext)
}

func (s *QueryContext) CheckStmt() ICheckStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckStmtContext)
}

func (s *QueryContext) CreateStmt() ICreateStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateStmtContext)
}

func (s *QueryContext) DescribeStmt() IDescribeStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeStmtContext)
}

func (s *QueryContext) DropStmt() IDropStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStmtContext)
}

func (s *QueryContext) ExistsStmt() IExistsStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExistsStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExistsStmtContext)
}

func (s *QueryContext) ExplainStmt() IExplainStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainStmtContext)
}

func (s *QueryContext) KillStmt() IKillStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillStmtContext)
}

func (s *QueryContext) OptimizeStmt() IOptimizeStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeStmtContext)
}

func (s *QueryContext) RenameStmt() IRenameStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameStmtContext)
}

func (s *QueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *QueryContext) SetStmt() ISetStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStmtContext)
}

func (s *QueryContext) ShowStmt() IShowStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStmtContext)
}

func (s *QueryContext) SystemStmt() ISystemStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemStmtContext)
}

func (s *QueryContext) TruncateStmt() ITruncateStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateStmtContext)
}

func (s *QueryContext) UseStmt() IUseStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseStmtContext)
}

func (s *QueryContext) WatchStmt() IWatchStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWatchStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWatchStmtContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *ClickHouseParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ClickHouseParserRULE_query)
	p.SetState(282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(264)
			p.AlterStmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(265)
			p.AttachStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(266)
			p.CheckStmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(267)
			p.CreateStmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(268)
			p.DescribeStmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(269)
			p.DropStmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(270)
			p.ExistsStmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(271)
			p.ExplainStmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(272)
			p.KillStmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(273)
			p.OptimizeStmt()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(274)
			p.RenameStmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(275)
			p.SelectUnionStmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(276)
			p.SetStmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(277)
			p.ShowStmt()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(278)
			p.SystemStmt()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(279)
			p.TruncateStmt()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(280)
			p.UseStmt()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(281)
			p.WatchStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStmtContext is an interface to support dynamic dispatch.
type IAlterStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterStmtContext differentiates from other interfaces.
	IsAlterStmtContext()
}

type AlterStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStmtContext() *AlterStmtContext {
	var p = new(AlterStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alterStmt
	return p
}

func InitEmptyAlterStmtContext(p *AlterStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alterStmt
}

func (*AlterStmtContext) IsAlterStmtContext() {}

func NewAlterStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStmtContext {
	var p = new(AlterStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alterStmt

	return p
}

func (s *AlterStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStmtContext) CopyAll(ctx *AlterStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterTableStmtContext struct {
	AlterStmtContext
}

func NewAlterTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableStmtContext {
	var p = new(AlterTableStmtContext)

	InitEmptyAlterStmtContext(&p.AlterStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterStmtContext))

	return p
}

func (s *AlterTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStmtContext) ALTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALTER, 0)
}

func (s *AlterTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *AlterTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AlterTableStmtContext) AllAlterTableClause() []IAlterTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterTableClauseContext); ok {
			tst[i] = t.(IAlterTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStmtContext) AlterTableClause(i int) IAlterTableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableClauseContext)
}

func (s *AlterTableStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *AlterTableStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *AlterTableStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *AlterTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableStmt(s)
	}
}

func (s *AlterTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableStmt(s)
	}
}

func (p *ClickHouseParser) AlterStmt() (localctx IAlterStmtContext) {
	localctx = NewAlterStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ClickHouseParserRULE_alterStmt)
	var _la int

	localctx = NewAlterTableStmtContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(284)
		p.Match(ClickHouseParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(285)
		p.Match(ClickHouseParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(286)
		p.TableIdentifier()
	}
	p.SetState(288)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(287)
			p.ClusterClause()
		}

	}
	{
		p.SetState(290)
		p.AlterTableClause()
	}
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(291)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(292)
			p.AlterTableClause()
		}

		p.SetState(297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableClauseContext is an interface to support dynamic dispatch.
type IAlterTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterTableClauseContext differentiates from other interfaces.
	IsAlterTableClauseContext()
}

type AlterTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableClauseContext() *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alterTableClause
	return p
}

func InitEmptyAlterTableClauseContext(p *AlterTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alterTableClause
}

func (*AlterTableClauseContext) IsAlterTableClauseContext() {}

func NewAlterTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alterTableClause

	return p
}

func (s *AlterTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableClauseContext) CopyAll(ctx *AlterTableClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterTableClauseReplaceContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseReplaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseReplaceContext {
	var p = new(AlterTableClauseReplaceContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLACE, 0)
}

func (s *AlterTableClauseReplaceContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseReplaceContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *AlterTableClauseReplaceContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AlterTableClauseReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseReplace(s)
	}
}

func (s *AlterTableClauseReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseReplace(s)
	}
}

type AlterTableClauseModifyOrderByContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseModifyOrderByContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyOrderByContext {
	var p = new(AlterTableClauseModifyOrderByContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyOrderByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyOrderByContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyOrderByContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserORDER, 0)
}

func (s *AlterTableClauseModifyOrderByContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *AlterTableClauseModifyOrderByContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *AlterTableClauseModifyOrderByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyOrderBy(s)
	}
}

func (s *AlterTableClauseModifyOrderByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyOrderBy(s)
	}
}

type AlterTableClauseUpdateContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseUpdateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseUpdateContext {
	var p = new(AlterTableClauseUpdateContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseUpdateContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUPDATE, 0)
}

func (s *AlterTableClauseUpdateContext) AssignmentExprList() IAssignmentExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprListContext)
}

func (s *AlterTableClauseUpdateContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *AlterTableClauseUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseUpdate(s)
	}
}

func (s *AlterTableClauseUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseUpdate(s)
	}
}

type AlterTableClauseClearProjectionContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseClearProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseClearProjectionContext {
	var p = new(AlterTableClauseClearProjectionContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseClearProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseClearProjectionContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLEAR, 0)
}

func (s *AlterTableClauseClearProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *AlterTableClauseClearProjectionContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseClearProjectionContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseClearProjectionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseClearProjectionContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseClearProjectionContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseClearProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseClearProjection(s)
	}
}

func (s *AlterTableClauseClearProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseClearProjection(s)
	}
}

type AlterTableClauseModifyRemoveContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseModifyRemoveContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyRemoveContext {
	var p = new(AlterTableClauseModifyRemoveContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyRemoveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyRemoveContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyRemoveContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseModifyRemoveContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseModifyRemoveContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREMOVE, 0)
}

func (s *AlterTableClauseModifyRemoveContext) TableColumnPropertyType() ITableColumnPropertyTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableColumnPropertyTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableColumnPropertyTypeContext)
}

func (s *AlterTableClauseModifyRemoveContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseModifyRemoveContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseModifyRemoveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyRemove(s)
	}
}

func (s *AlterTableClauseModifyRemoveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyRemove(s)
	}
}

type AlterTableClauseDeleteContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDeleteContext {
	var p = new(AlterTableClauseDeleteContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELETE, 0)
}

func (s *AlterTableClauseDeleteContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *AlterTableClauseDeleteContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *AlterTableClauseDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDelete(s)
	}
}

func (s *AlterTableClauseDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDelete(s)
	}
}

type AlterTableClauseCommentContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseCommentContext {
	var p = new(AlterTableClauseCommentContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *AlterTableClauseCommentContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseCommentContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseCommentContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterTableClauseCommentContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseCommentContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseComment(s)
	}
}

func (s *AlterTableClauseCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseComment(s)
	}
}

type AlterTableClauseDropColumnContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseDropColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDropColumnContext {
	var p = new(AlterTableClauseDropColumnContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDropColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDropColumnContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *AlterTableClauseDropColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseDropColumnContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseDropColumnContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseDropColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseDropColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDropColumn(s)
	}
}

func (s *AlterTableClauseDropColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDropColumn(s)
	}
}

type AlterTableClauseDetachContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseDetachContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDetachContext {
	var p = new(AlterTableClauseDetachContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDetachContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDetachContext) DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDETACH, 0)
}

func (s *AlterTableClauseDetachContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseDetachContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDetach(s)
	}
}

func (s *AlterTableClauseDetachContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDetach(s)
	}
}

type AlterTableClauseAddIndexContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseAddIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseAddIndexContext {
	var p = new(AlterTableClauseAddIndexContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseAddIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseAddIndexContext) ADD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserADD, 0)
}

func (s *AlterTableClauseAddIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *AlterTableClauseAddIndexContext) TableIndexDfnt() ITableIndexDfntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIndexDfntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIndexDfntContext)
}

func (s *AlterTableClauseAddIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseAddIndexContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *AlterTableClauseAddIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseAddIndexContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAFTER, 0)
}

func (s *AlterTableClauseAddIndexContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseAddIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseAddIndex(s)
	}
}

func (s *AlterTableClauseAddIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseAddIndex(s)
	}
}

type AlterTableClauseDropPartitionContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseDropPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDropPartitionContext {
	var p = new(AlterTableClauseDropPartitionContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDropPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDropPartitionContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *AlterTableClauseDropPartitionContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseDropPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDropPartition(s)
	}
}

func (s *AlterTableClauseDropPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDropPartition(s)
	}
}

type AlterTableClauseMaterializeIndexContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseMaterializeIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseMaterializeIndexContext {
	var p = new(AlterTableClauseMaterializeIndexContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseMaterializeIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseMaterializeIndexContext) MATERIALIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZE, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseMaterializeIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseMaterializeIndexContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseMaterializeIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseMaterializeIndex(s)
	}
}

func (s *AlterTableClauseMaterializeIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseMaterializeIndex(s)
	}
}

type AlterTableClauseMaterializeProjectionContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseMaterializeProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseMaterializeProjectionContext {
	var p = new(AlterTableClauseMaterializeProjectionContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseMaterializeProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseMaterializeProjectionContext) MATERIALIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZE, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseMaterializeProjectionContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseMaterializeProjectionContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseMaterializeProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseMaterializeProjection(s)
	}
}

func (s *AlterTableClauseMaterializeProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseMaterializeProjection(s)
	}
}

type AlterTableClauseMovePartitionContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseMovePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseMovePartitionContext {
	var p = new(AlterTableClauseMovePartitionContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseMovePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseMovePartitionContext) MOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMOVE, 0)
}

func (s *AlterTableClauseMovePartitionContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseMovePartitionContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *AlterTableClauseMovePartitionContext) DISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISK, 0)
}

func (s *AlterTableClauseMovePartitionContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterTableClauseMovePartitionContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVOLUME, 0)
}

func (s *AlterTableClauseMovePartitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *AlterTableClauseMovePartitionContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AlterTableClauseMovePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseMovePartition(s)
	}
}

func (s *AlterTableClauseMovePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseMovePartition(s)
	}
}

type AlterTableClauseRenameContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseRenameContext {
	var p = new(AlterTableClauseRenameContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRENAME, 0)
}

func (s *AlterTableClauseRenameContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseRenameContext) AllNestedIdentifier() []INestedIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			len++
		}
	}

	tst := make([]INestedIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INestedIdentifierContext); ok {
			tst[i] = t.(INestedIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableClauseRenameContext) NestedIdentifier(i int) INestedIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseRenameContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *AlterTableClauseRenameContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseRenameContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseRename(s)
	}
}

func (s *AlterTableClauseRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseRename(s)
	}
}

type AlterTableClauseFreezePartitionContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseFreezePartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseFreezePartitionContext {
	var p = new(AlterTableClauseFreezePartitionContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseFreezePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseFreezePartitionContext) FREEZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFREEZE, 0)
}

func (s *AlterTableClauseFreezePartitionContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseFreezePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseFreezePartition(s)
	}
}

func (s *AlterTableClauseFreezePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseFreezePartition(s)
	}
}

type AlterTableClauseClearColumnContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseClearColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseClearColumnContext {
	var p = new(AlterTableClauseClearColumnContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseClearColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseClearColumnContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLEAR, 0)
}

func (s *AlterTableClauseClearColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseClearColumnContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseClearColumnContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseClearColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseClearColumnContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseClearColumnContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseClearColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseClearColumn(s)
	}
}

func (s *AlterTableClauseClearColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseClearColumn(s)
	}
}

type AlterTableClauseModifyContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseModifyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyContext {
	var p = new(AlterTableClauseModifyContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseModifyContext) TableColumnDfnt() ITableColumnDfntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableColumnDfntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableColumnDfntContext)
}

func (s *AlterTableClauseModifyContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseModifyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseModifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModify(s)
	}
}

func (s *AlterTableClauseModifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModify(s)
	}
}

type AlterTableClauseClearIndexContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseClearIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseClearIndexContext {
	var p = new(AlterTableClauseClearIndexContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseClearIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseClearIndexContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLEAR, 0)
}

func (s *AlterTableClauseClearIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *AlterTableClauseClearIndexContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseClearIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseClearIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseClearIndexContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *AlterTableClauseClearIndexContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseClearIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseClearIndex(s)
	}
}

func (s *AlterTableClauseClearIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseClearIndex(s)
	}
}

type AlterTableClauseRemoveTTLContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseRemoveTTLContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseRemoveTTLContext {
	var p = new(AlterTableClauseRemoveTTLContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseRemoveTTLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseRemoveTTLContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREMOVE, 0)
}

func (s *AlterTableClauseRemoveTTLContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *AlterTableClauseRemoveTTLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseRemoveTTL(s)
	}
}

func (s *AlterTableClauseRemoveTTLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseRemoveTTL(s)
	}
}

type AlterTableClauseModifyCodecContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseModifyCodecContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyCodecContext {
	var p = new(AlterTableClauseModifyCodecContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyCodecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyCodecContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyCodecContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseModifyCodecContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseModifyCodecContext) CodecExpr() ICodecExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodecExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodecExprContext)
}

func (s *AlterTableClauseModifyCodecContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseModifyCodecContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseModifyCodecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyCodec(s)
	}
}

func (s *AlterTableClauseModifyCodecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyCodec(s)
	}
}

type AlterTableClauseAttachContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseAttachContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseAttachContext {
	var p = new(AlterTableClauseAttachContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseAttachContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseAttachContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *AlterTableClauseAttachContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableClauseAttachContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *AlterTableClauseAttachContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AlterTableClauseAttachContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseAttach(s)
	}
}

func (s *AlterTableClauseAttachContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseAttach(s)
	}
}

type AlterTableClauseDropProjectionContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseDropProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDropProjectionContext {
	var p = new(AlterTableClauseDropProjectionContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDropProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDropProjectionContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *AlterTableClauseDropProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *AlterTableClauseDropProjectionContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseDropProjectionContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseDropProjectionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseDropProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDropProjection(s)
	}
}

func (s *AlterTableClauseDropProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDropProjection(s)
	}
}

type AlterTableClauseDropIndexContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseDropIndexContext {
	var p = new(AlterTableClauseDropIndexContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseDropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseDropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *AlterTableClauseDropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *AlterTableClauseDropIndexContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseDropIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseDropIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseDropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseDropIndex(s)
	}
}

func (s *AlterTableClauseDropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseDropIndex(s)
	}
}

type AlterTableClauseModifyCommentContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseModifyCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyCommentContext {
	var p = new(AlterTableClauseModifyCommentContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyCommentContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyCommentContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseModifyCommentContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseModifyCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *AlterTableClauseModifyCommentContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *AlterTableClauseModifyCommentContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseModifyCommentContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseModifyCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyComment(s)
	}
}

func (s *AlterTableClauseModifyCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyComment(s)
	}
}

type AlterTableClauseModifyTTLContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseModifyTTLContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseModifyTTLContext {
	var p = new(AlterTableClauseModifyTTLContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseModifyTTLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseModifyTTLContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *AlterTableClauseModifyTTLContext) TtlClause() ITtlClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtlClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtlClauseContext)
}

func (s *AlterTableClauseModifyTTLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseModifyTTL(s)
	}
}

func (s *AlterTableClauseModifyTTLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseModifyTTL(s)
	}
}

type AlterTableClauseAddProjectionContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseAddProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseAddProjectionContext {
	var p = new(AlterTableClauseAddProjectionContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseAddProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseAddProjectionContext) ADD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserADD, 0)
}

func (s *AlterTableClauseAddProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *AlterTableClauseAddProjectionContext) TableProjectionDfnt() ITableProjectionDfntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableProjectionDfntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableProjectionDfntContext)
}

func (s *AlterTableClauseAddProjectionContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseAddProjectionContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *AlterTableClauseAddProjectionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseAddProjectionContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAFTER, 0)
}

func (s *AlterTableClauseAddProjectionContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseAddProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseAddProjection(s)
	}
}

func (s *AlterTableClauseAddProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseAddProjection(s)
	}
}

type AlterTableClauseAddColumnContext struct {
	AlterTableClauseContext
}

func NewAlterTableClauseAddColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableClauseAddColumnContext {
	var p = new(AlterTableClauseAddColumnContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterTableClauseAddColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseAddColumnContext) ADD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserADD, 0)
}

func (s *AlterTableClauseAddColumnContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *AlterTableClauseAddColumnContext) TableColumnDfnt() ITableColumnDfntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableColumnDfntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableColumnDfntContext)
}

func (s *AlterTableClauseAddColumnContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *AlterTableClauseAddColumnContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *AlterTableClauseAddColumnContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *AlterTableClauseAddColumnContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAFTER, 0)
}

func (s *AlterTableClauseAddColumnContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AlterTableClauseAddColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlterTableClauseAddColumn(s)
	}
}

func (s *AlterTableClauseAddColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlterTableClauseAddColumn(s)
	}
}

func (p *ClickHouseParser) AlterTableClause() (localctx IAlterTableClauseContext) {
	localctx = NewAlterTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ClickHouseParserRULE_alterTableClause)
	var _la int

	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterTableClauseAddColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(298)
			p.Match(ClickHouseParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(299)
			p.Match(ClickHouseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(303)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(300)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(301)
				p.Match(ClickHouseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(302)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(305)
			p.TableColumnDfnt()
		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAFTER {
			{
				p.SetState(306)
				p.Match(ClickHouseParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(307)
				p.NestedIdentifier()
			}

		}

	case 2:
		localctx = NewAlterTableClauseAddIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(310)
			p.Match(ClickHouseParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(311)
			p.Match(ClickHouseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(315)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(312)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(313)
				p.Match(ClickHouseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(314)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(317)
			p.TableIndexDfnt()
		}
		p.SetState(320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAFTER {
			{
				p.SetState(318)
				p.Match(ClickHouseParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(319)
				p.NestedIdentifier()
			}

		}

	case 3:
		localctx = NewAlterTableClauseAddProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(322)
			p.Match(ClickHouseParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(323)
			p.Match(ClickHouseParserPROJECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(324)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(325)
				p.Match(ClickHouseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(326)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(329)
			p.TableProjectionDfnt()
		}
		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAFTER {
			{
				p.SetState(330)
				p.Match(ClickHouseParserAFTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(331)
				p.NestedIdentifier()
			}

		}

	case 4:
		localctx = NewAlterTableClauseAttachContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(334)
			p.Match(ClickHouseParserATTACH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(335)
			p.PartitionClause()
		}
		p.SetState(338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFROM {
			{
				p.SetState(336)
				p.Match(ClickHouseParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(337)
				p.TableIdentifier()
			}

		}

	case 5:
		localctx = NewAlterTableClauseClearColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(340)
			p.Match(ClickHouseParserCLEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(341)
			p.Match(ClickHouseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(344)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(342)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(343)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(346)
			p.NestedIdentifier()
		}
		p.SetState(349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(347)
				p.Match(ClickHouseParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(348)
				p.PartitionClause()
			}

		}

	case 6:
		localctx = NewAlterTableClauseClearIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(351)
			p.Match(ClickHouseParserCLEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(352)
			p.Match(ClickHouseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(355)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(353)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(354)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(357)
			p.NestedIdentifier()
		}
		p.SetState(360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(358)
				p.Match(ClickHouseParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(359)
				p.PartitionClause()
			}

		}

	case 7:
		localctx = NewAlterTableClauseClearProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(362)
			p.Match(ClickHouseParserCLEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(363)
			p.Match(ClickHouseParserPROJECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(366)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(364)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(365)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(368)
			p.NestedIdentifier()
		}
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(369)
				p.Match(ClickHouseParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(370)
				p.PartitionClause()
			}

		}

	case 8:
		localctx = NewAlterTableClauseCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(373)
			p.Match(ClickHouseParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(374)
			p.Match(ClickHouseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(377)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(375)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(376)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(379)
			p.NestedIdentifier()
		}
		{
			p.SetState(380)
			p.StringLiteral()
		}

	case 9:
		localctx = NewAlterTableClauseDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(382)
			p.Match(ClickHouseParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(383)
			p.Match(ClickHouseParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(384)
			p.columnExpr(0)
		}

	case 10:
		localctx = NewAlterTableClauseDetachContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(385)
			p.Match(ClickHouseParserDETACH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(386)
			p.PartitionClause()
		}

	case 11:
		localctx = NewAlterTableClauseDropColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(387)
			p.Match(ClickHouseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(388)
			p.Match(ClickHouseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(391)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(389)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(390)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(393)
			p.NestedIdentifier()
		}

	case 12:
		localctx = NewAlterTableClauseDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(394)
			p.Match(ClickHouseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(395)
			p.Match(ClickHouseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(396)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(397)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(400)
			p.NestedIdentifier()
		}

	case 13:
		localctx = NewAlterTableClauseDropProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(401)
			p.Match(ClickHouseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(402)
			p.Match(ClickHouseParserPROJECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(403)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(404)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(407)
			p.NestedIdentifier()
		}

	case 14:
		localctx = NewAlterTableClauseDropPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(408)
			p.Match(ClickHouseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(409)
			p.PartitionClause()
		}

	case 15:
		localctx = NewAlterTableClauseFreezePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(410)
			p.Match(ClickHouseParserFREEZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserPARTITION {
			{
				p.SetState(411)
				p.PartitionClause()
			}

		}

	case 16:
		localctx = NewAlterTableClauseMaterializeIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(414)
			p.Match(ClickHouseParserMATERIALIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(415)
			p.Match(ClickHouseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(418)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(416)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(417)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(420)
			p.NestedIdentifier()
		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(421)
				p.Match(ClickHouseParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(422)
				p.PartitionClause()
			}

		}

	case 17:
		localctx = NewAlterTableClauseMaterializeProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(425)
			p.Match(ClickHouseParserMATERIALIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(426)
			p.Match(ClickHouseParserPROJECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(427)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(428)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(431)
			p.NestedIdentifier()
		}
		p.SetState(434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserIN {
			{
				p.SetState(432)
				p.Match(ClickHouseParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(433)
				p.PartitionClause()
			}

		}

	case 18:
		localctx = NewAlterTableClauseModifyCodecContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(436)
			p.Match(ClickHouseParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(437)
			p.Match(ClickHouseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(440)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(438)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(439)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(442)
			p.NestedIdentifier()
		}
		{
			p.SetState(443)
			p.CodecExpr()
		}

	case 19:
		localctx = NewAlterTableClauseModifyCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(445)
			p.Match(ClickHouseParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(446)
			p.Match(ClickHouseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(449)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(447)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(448)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(451)
			p.NestedIdentifier()
		}
		{
			p.SetState(452)
			p.Match(ClickHouseParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(453)
			p.StringLiteral()
		}

	case 20:
		localctx = NewAlterTableClauseModifyRemoveContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(455)
			p.Match(ClickHouseParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(456)
			p.Match(ClickHouseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(457)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(458)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(461)
			p.NestedIdentifier()
		}
		{
			p.SetState(462)
			p.Match(ClickHouseParserREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(463)
			p.TableColumnPropertyType()
		}

	case 21:
		localctx = NewAlterTableClauseModifyContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(465)
			p.Match(ClickHouseParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(466)
			p.Match(ClickHouseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(469)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(467)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(468)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(471)
			p.TableColumnDfnt()
		}

	case 22:
		localctx = NewAlterTableClauseModifyOrderByContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(472)
			p.Match(ClickHouseParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(473)
			p.Match(ClickHouseParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(474)
			p.Match(ClickHouseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(475)
			p.columnExpr(0)
		}

	case 23:
		localctx = NewAlterTableClauseModifyTTLContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(476)
			p.Match(ClickHouseParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(477)
			p.TtlClause()
		}

	case 24:
		localctx = NewAlterTableClauseMovePartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(478)
			p.Match(ClickHouseParserMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(479)
			p.PartitionClause()
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(480)
				p.Match(ClickHouseParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(481)
				p.Match(ClickHouseParserDISK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(482)
				p.StringLiteral()
			}

		case 2:
			{
				p.SetState(483)
				p.Match(ClickHouseParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(484)
				p.Match(ClickHouseParserVOLUME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(485)
				p.StringLiteral()
			}

		case 3:
			{
				p.SetState(486)
				p.Match(ClickHouseParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(487)
				p.Match(ClickHouseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(488)
				p.TableIdentifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 25:
		localctx = NewAlterTableClauseRemoveTTLContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(491)
			p.Match(ClickHouseParserREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(492)
			p.Match(ClickHouseParserTTL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		localctx = NewAlterTableClauseRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(493)
			p.Match(ClickHouseParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(494)
			p.Match(ClickHouseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(497)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(495)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(496)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(499)
			p.NestedIdentifier()
		}
		{
			p.SetState(500)
			p.Match(ClickHouseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.NestedIdentifier()
		}

	case 27:
		localctx = NewAlterTableClauseReplaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(503)
			p.Match(ClickHouseParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(504)
			p.PartitionClause()
		}
		{
			p.SetState(505)
			p.Match(ClickHouseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(506)
			p.TableIdentifier()
		}

	case 28:
		localctx = NewAlterTableClauseUpdateContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(508)
			p.Match(ClickHouseParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(509)
			p.AssignmentExprList()
		}
		{
			p.SetState(510)
			p.WhereClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExprListContext is an interface to support dynamic dispatch.
type IAssignmentExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignmentExpr() []IAssignmentExprContext
	AssignmentExpr(i int) IAssignmentExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAssignmentExprListContext differentiates from other interfaces.
	IsAssignmentExprListContext()
}

type AssignmentExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExprListContext() *AssignmentExprListContext {
	var p = new(AssignmentExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentExprList
	return p
}

func InitEmptyAssignmentExprListContext(p *AssignmentExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentExprList
}

func (*AssignmentExprListContext) IsAssignmentExprListContext() {}

func NewAssignmentExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprListContext {
	var p = new(AssignmentExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_assignmentExprList

	return p
}

func (s *AssignmentExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprListContext) AllAssignmentExpr() []IAssignmentExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentExprContext); ok {
			tst[i] = t.(IAssignmentExprContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentExprListContext) AssignmentExpr(i int) IAssignmentExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *AssignmentExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *AssignmentExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *AssignmentExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAssignmentExprList(s)
	}
}

func (s *AssignmentExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAssignmentExprList(s)
	}
}

func (p *ClickHouseParser) AssignmentExprList() (localctx IAssignmentExprListContext) {
	localctx = NewAssignmentExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ClickHouseParserRULE_assignmentExprList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(514)
		p.AssignmentExpr()
	}
	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(515)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(516)
			p.AssignmentExpr()
		}

		p.SetState(521)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExprContext is an interface to support dynamic dispatch.
type IAssignmentExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedIdentifier() INestedIdentifierContext
	EQ_SINGLE() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsAssignmentExprContext differentiates from other interfaces.
	IsAssignmentExprContext()
}

type AssignmentExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExprContext() *AssignmentExprContext {
	var p = new(AssignmentExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentExpr
	return p
}

func InitEmptyAssignmentExprContext(p *AssignmentExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentExpr
}

func (*AssignmentExprContext) IsAssignmentExprContext() {}

func NewAssignmentExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprContext {
	var p = new(AssignmentExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_assignmentExpr

	return p
}

func (s *AssignmentExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *AssignmentExprContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *AssignmentExprContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *AssignmentExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAssignmentExpr(s)
	}
}

func (p *ClickHouseParser) AssignmentExpr() (localctx IAssignmentExprContext) {
	localctx = NewAssignmentExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ClickHouseParserRULE_assignmentExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(522)
		p.NestedIdentifier()
	}
	{
		p.SetState(523)
		p.Match(ClickHouseParserEQ_SINGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(524)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableColumnPropertyTypeContext is an interface to support dynamic dispatch.
type ITableColumnPropertyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALIAS() antlr.TerminalNode
	CODEC() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	TTL() antlr.TerminalNode

	// IsTableColumnPropertyTypeContext differentiates from other interfaces.
	IsTableColumnPropertyTypeContext()
}

type TableColumnPropertyTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableColumnPropertyTypeContext() *TableColumnPropertyTypeContext {
	var p = new(TableColumnPropertyTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyType
	return p
}

func InitEmptyTableColumnPropertyTypeContext(p *TableColumnPropertyTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyType
}

func (*TableColumnPropertyTypeContext) IsTableColumnPropertyTypeContext() {}

func NewTableColumnPropertyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableColumnPropertyTypeContext {
	var p = new(TableColumnPropertyTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyType

	return p
}

func (s *TableColumnPropertyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TableColumnPropertyTypeContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALIAS, 0)
}

func (s *TableColumnPropertyTypeContext) CODEC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCODEC, 0)
}

func (s *TableColumnPropertyTypeContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *TableColumnPropertyTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEFAULT, 0)
}

func (s *TableColumnPropertyTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZED, 0)
}

func (s *TableColumnPropertyTypeContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *TableColumnPropertyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableColumnPropertyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableColumnPropertyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableColumnPropertyType(s)
	}
}

func (s *TableColumnPropertyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableColumnPropertyType(s)
	}
}

func (p *ClickHouseParser) TableColumnPropertyType() (localctx ITableColumnPropertyTypeContext) {
	localctx = NewTableColumnPropertyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ClickHouseParserRULE_tableColumnPropertyType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17594467745808) != 0) || _la == ClickHouseParserMATERIALIZED || _la == ClickHouseParserTTL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	ColumnExpr() IColumnExprContext
	ID() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPARTITION, 0)
}

func (s *PartitionClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *PartitionClauseContext) ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserID, 0)
}

func (s *PartitionClauseContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (p *ClickHouseParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ClickHouseParserRULE_partitionClause)
	p.SetState(533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(528)
			p.Match(ClickHouseParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(529)
			p.columnExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(530)
			p.Match(ClickHouseParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(531)
			p.Match(ClickHouseParserID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(532)
			p.StringLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttachStmtContext is an interface to support dynamic dispatch.
type IAttachStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAttachStmtContext differentiates from other interfaces.
	IsAttachStmtContext()
}

type AttachStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttachStmtContext() *AttachStmtContext {
	var p = new(AttachStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_attachStmt
	return p
}

func InitEmptyAttachStmtContext(p *AttachStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_attachStmt
}

func (*AttachStmtContext) IsAttachStmtContext() {}

func NewAttachStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttachStmtContext {
	var p = new(AttachStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_attachStmt

	return p
}

func (s *AttachStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AttachStmtContext) CopyAll(ctx *AttachStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AttachStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttachStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AttachDictionaryStmtContext struct {
	AttachStmtContext
}

func NewAttachDictionaryStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AttachDictionaryStmtContext {
	var p = new(AttachDictionaryStmtContext)

	InitEmptyAttachStmtContext(&p.AttachStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*AttachStmtContext))

	return p
}

func (s *AttachDictionaryStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttachDictionaryStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *AttachDictionaryStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *AttachDictionaryStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *AttachDictionaryStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *AttachDictionaryStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAttachDictionaryStmt(s)
	}
}

func (s *AttachDictionaryStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAttachDictionaryStmt(s)
	}
}

func (p *ClickHouseParser) AttachStmt() (localctx IAttachStmtContext) {
	localctx = NewAttachStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ClickHouseParserRULE_attachStmt)
	var _la int

	localctx = NewAttachDictionaryStmtContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		p.Match(ClickHouseParserATTACH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(536)
		p.Match(ClickHouseParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(537)
		p.TableIdentifier()
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(538)
			p.ClusterClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckStmtContext is an interface to support dynamic dispatch.
type ICheckStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableIdentifier() ITableIdentifierContext
	PartitionClause() IPartitionClauseContext

	// IsCheckStmtContext differentiates from other interfaces.
	IsCheckStmtContext()
}

type CheckStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckStmtContext() *CheckStmtContext {
	var p = new(CheckStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_checkStmt
	return p
}

func InitEmptyCheckStmtContext(p *CheckStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_checkStmt
}

func (*CheckStmtContext) IsCheckStmtContext() {}

func NewCheckStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckStmtContext {
	var p = new(CheckStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_checkStmt

	return p
}

func (s *CheckStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckStmtContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCHECK, 0)
}

func (s *CheckStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *CheckStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CheckStmtContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *CheckStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCheckStmt(s)
	}
}

func (s *CheckStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCheckStmt(s)
	}
}

func (p *ClickHouseParser) CheckStmt() (localctx ICheckStmtContext) {
	localctx = NewCheckStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ClickHouseParserRULE_checkStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(ClickHouseParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(542)
		p.Match(ClickHouseParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(543)
		p.TableIdentifier()
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserPARTITION {
		{
			p.SetState(544)
			p.PartitionClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateStmtContext is an interface to support dynamic dispatch.
type ICreateStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCreateStmtContext differentiates from other interfaces.
	IsCreateStmtContext()
}

type CreateStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateStmtContext() *CreateStmtContext {
	var p = new(CreateStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_createStmt
	return p
}

func InitEmptyCreateStmtContext(p *CreateStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_createStmt
}

func (*CreateStmtContext) IsCreateStmtContext() {}

func NewCreateStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateStmtContext {
	var p = new(CreateStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_createStmt

	return p
}

func (s *CreateStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateStmtContext) CopyAll(ctx *CreateStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *CreateStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateViewStmtContext struct {
	CreateStmtContext
}

func NewCreateViewStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewStmtContext {
	var p = new(CreateViewStmtContext)

	InitEmptyCreateStmtContext(&p.CreateStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateViewStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *CreateViewStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateViewStmtContext) SubqueryClause() ISubqueryClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryClauseContext)
}

func (s *CreateViewStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateViewStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateViewStmtContext) OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOR, 0)
}

func (s *CreateViewStmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLACE, 0)
}

func (s *CreateViewStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateViewStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateViewStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateViewStmtContext) UuidClause() IUuidClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUuidClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateViewStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateViewStmtContext) TableSchemaClause() ITableSchemaClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSchemaClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSchemaClauseContext)
}

func (s *CreateViewStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateViewStmt(s)
	}
}

func (s *CreateViewStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateViewStmt(s)
	}
}

type CreateDictionaryStmtContext struct {
	CreateStmtContext
}

func NewCreateDictionaryStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDictionaryStmtContext {
	var p = new(CreateDictionaryStmtContext)

	InitEmptyCreateStmtContext(&p.CreateStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateDictionaryStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDictionaryStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *CreateDictionaryStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateDictionaryStmtContext) DictionarySchemaClause() IDictionarySchemaClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionarySchemaClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionarySchemaClauseContext)
}

func (s *CreateDictionaryStmtContext) DictionaryEngineClause() IDictionaryEngineClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryEngineClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryEngineClauseContext)
}

func (s *CreateDictionaryStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateDictionaryStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateDictionaryStmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLACE, 0)
}

func (s *CreateDictionaryStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateDictionaryStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateDictionaryStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateDictionaryStmtContext) UuidClause() IUuidClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUuidClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateDictionaryStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateDictionaryStmtContext) OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOR, 0)
}

func (s *CreateDictionaryStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateDictionaryStmt(s)
	}
}

func (s *CreateDictionaryStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateDictionaryStmt(s)
	}
}

type CreateDatabaseStmtContext struct {
	CreateStmtContext
}

func NewCreateDatabaseStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDatabaseStmtContext {
	var p = new(CreateDatabaseStmtContext)

	InitEmptyCreateStmtContext(&p.CreateStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateDatabaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *CreateDatabaseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *CreateDatabaseStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateDatabaseStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateDatabaseStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateDatabaseStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateDatabaseStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateDatabaseStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateDatabaseStmtContext) EngineExpr() IEngineExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineExprContext)
}

func (s *CreateDatabaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateDatabaseStmt(s)
	}
}

func (s *CreateDatabaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateDatabaseStmt(s)
	}
}

type CreateLiveViewStmtContext struct {
	CreateStmtContext
}

func NewCreateLiveViewStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateLiveViewStmtContext {
	var p = new(CreateLiveViewStmtContext)

	InitEmptyCreateStmtContext(&p.CreateStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateLiveViewStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateLiveViewStmtContext) LIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIVE, 0)
}

func (s *CreateLiveViewStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *CreateLiveViewStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateLiveViewStmtContext) SubqueryClause() ISubqueryClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryClauseContext)
}

func (s *CreateLiveViewStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateLiveViewStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateLiveViewStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateLiveViewStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateLiveViewStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateLiveViewStmtContext) UuidClause() IUuidClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUuidClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateLiveViewStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateLiveViewStmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *CreateLiveViewStmtContext) TIMEOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMEOUT, 0)
}

func (s *CreateLiveViewStmtContext) DestinationClause() IDestinationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationClauseContext)
}

func (s *CreateLiveViewStmtContext) TableSchemaClause() ITableSchemaClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSchemaClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSchemaClauseContext)
}

func (s *CreateLiveViewStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *CreateLiveViewStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateLiveViewStmt(s)
	}
}

func (s *CreateLiveViewStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateLiveViewStmt(s)
	}
}

type CreateMaterializedViewStmtContext struct {
	CreateStmtContext
}

func NewCreateMaterializedViewStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateMaterializedViewStmtContext {
	var p = new(CreateMaterializedViewStmtContext)

	InitEmptyCreateStmtContext(&p.CreateStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateMaterializedViewStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewStmtContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZED, 0)
}

func (s *CreateMaterializedViewStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *CreateMaterializedViewStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateMaterializedViewStmtContext) SubqueryClause() ISubqueryClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryClauseContext)
}

func (s *CreateMaterializedViewStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateMaterializedViewStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateMaterializedViewStmtContext) DestinationClause() IDestinationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationClauseContext)
}

func (s *CreateMaterializedViewStmtContext) EngineClause() IEngineClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineClauseContext)
}

func (s *CreateMaterializedViewStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateMaterializedViewStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateMaterializedViewStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateMaterializedViewStmtContext) UuidClause() IUuidClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUuidClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateMaterializedViewStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateMaterializedViewStmtContext) TableSchemaClause() ITableSchemaClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSchemaClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSchemaClauseContext)
}

func (s *CreateMaterializedViewStmtContext) POPULATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPOPULATE, 0)
}

func (s *CreateMaterializedViewStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateMaterializedViewStmt(s)
	}
}

func (s *CreateMaterializedViewStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateMaterializedViewStmt(s)
	}
}

type CreateTableStmtContext struct {
	CreateStmtContext
}

func NewCreateTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableStmtContext {
	var p = new(CreateTableStmtContext)

	InitEmptyCreateStmtContext(&p.CreateStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*CreateStmtContext))

	return p
}

func (s *CreateTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *CreateTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *CreateTableStmtContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *CreateTableStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *CreateTableStmtContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLACE, 0)
}

func (s *CreateTableStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *CreateTableStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *CreateTableStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *CreateTableStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *CreateTableStmtContext) UuidClause() IUuidClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUuidClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUuidClauseContext)
}

func (s *CreateTableStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *CreateTableStmtContext) TableSchemaClause() ITableSchemaClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSchemaClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSchemaClauseContext)
}

func (s *CreateTableStmtContext) EngineClause() IEngineClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineClauseContext)
}

func (s *CreateTableStmtContext) SubqueryClause() ISubqueryClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryClauseContext)
}

func (s *CreateTableStmtContext) OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOR, 0)
}

func (s *CreateTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCreateTableStmt(s)
	}
}

func (s *CreateTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCreateTableStmt(s)
	}
}

func (p *ClickHouseParser) CreateStmt() (localctx ICreateStmtContext) {
	localctx = NewCreateStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ClickHouseParserRULE_createStmt)
	var _la int

	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateDatabaseStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(547)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(548)
			p.Match(ClickHouseParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(549)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(550)
				p.Match(ClickHouseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(551)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(554)
			p.DatabaseIdentifier()
		}
		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(555)
				p.ClusterClause()
			}

		}
		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserENGINE {
			{
				p.SetState(558)
				p.EngineExpr()
			}

		}

	case 2:
		localctx = NewCreateDictionaryStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserATTACH:
			{
				p.SetState(561)
				p.Match(ClickHouseParserATTACH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case ClickHouseParserCREATE:
			{
				p.SetState(562)
				p.Match(ClickHouseParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(565)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOR {
				{
					p.SetState(563)
					p.Match(ClickHouseParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(564)
					p.Match(ClickHouseParserREPLACE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case ClickHouseParserREPLACE:
			{
				p.SetState(567)
				p.Match(ClickHouseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(570)
			p.Match(ClickHouseParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(574)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(571)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(572)
				p.Match(ClickHouseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(573)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(576)
			p.TableIdentifier()
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(577)
				p.UuidClause()
			}

		}
		p.SetState(581)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(580)
				p.ClusterClause()
			}

		}
		{
			p.SetState(583)
			p.DictionarySchemaClause()
		}
		{
			p.SetState(584)
			p.DictionaryEngineClause()
		}

	case 3:
		localctx = NewCreateLiveViewStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(586)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(587)
			p.Match(ClickHouseParserLIVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(588)
			p.Match(ClickHouseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(592)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(589)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(590)
				p.Match(ClickHouseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(591)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(594)
			p.TableIdentifier()
		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(595)
				p.UuidClause()
			}

		}
		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(598)
				p.ClusterClause()
			}

		}
		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserWITH {
			{
				p.SetState(601)
				p.Match(ClickHouseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(602)
				p.Match(ClickHouseParserTIMEOUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(604)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserDECIMAL_LITERAL {
				{
					p.SetState(603)
					p.Match(ClickHouseParserDECIMAL_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTO {
			{
				p.SetState(608)
				p.DestinationClause()
			}

		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(611)
				p.TableSchemaClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(614)
			p.SubqueryClause()
		}

	case 4:
		localctx = NewCreateMaterializedViewStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(616)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(617)
			p.Match(ClickHouseParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(618)
			p.Match(ClickHouseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(619)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(620)
				p.Match(ClickHouseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(621)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(624)
			p.TableIdentifier()
		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(625)
				p.UuidClause()
			}

		}
		p.SetState(629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(628)
				p.ClusterClause()
			}

		}
		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAS || _la == ClickHouseParserLPAREN {
			{
				p.SetState(631)
				p.TableSchemaClause()
			}

		}
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserTO:
			{
				p.SetState(634)
				p.DestinationClause()
			}

		case ClickHouseParserENGINE:
			{
				p.SetState(635)
				p.EngineClause()
			}
			p.SetState(637)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserPOPULATE {
				{
					p.SetState(636)
					p.Match(ClickHouseParserPOPULATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(641)
			p.SubqueryClause()
		}

	case 5:
		localctx = NewCreateTableStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserATTACH:
			{
				p.SetState(643)
				p.Match(ClickHouseParserATTACH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case ClickHouseParserCREATE:
			{
				p.SetState(644)
				p.Match(ClickHouseParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(647)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOR {
				{
					p.SetState(645)
					p.Match(ClickHouseParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(646)
					p.Match(ClickHouseParserREPLACE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case ClickHouseParserREPLACE:
			{
				p.SetState(649)
				p.Match(ClickHouseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTEMPORARY {
			{
				p.SetState(652)
				p.Match(ClickHouseParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(655)
			p.Match(ClickHouseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(659)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(656)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(657)
				p.Match(ClickHouseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(658)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(661)
			p.TableIdentifier()
		}
		p.SetState(663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(662)
				p.UuidClause()
			}

		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(665)
				p.ClusterClause()
			}

		}
		p.SetState(669)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(668)
				p.TableSchemaClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserENGINE {
			{
				p.SetState(671)
				p.EngineClause()
			}

		}
		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserAS {
			{
				p.SetState(674)
				p.SubqueryClause()
			}

		}

	case 6:
		localctx = NewCreateViewStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(677)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserATTACH || _la == ClickHouseParserCREATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserOR {
			{
				p.SetState(678)
				p.Match(ClickHouseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(679)
				p.Match(ClickHouseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(682)
			p.Match(ClickHouseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(683)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(684)
				p.Match(ClickHouseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(685)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(688)
			p.TableIdentifier()
		}
		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserUUID {
			{
				p.SetState(689)
				p.UuidClause()
			}

		}
		p.SetState(693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(692)
				p.ClusterClause()
			}

		}
		p.SetState(696)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(695)
				p.TableSchemaClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(698)
			p.SubqueryClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionarySchemaClauseContext is an interface to support dynamic dispatch.
type IDictionarySchemaClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllDictionaryAttrDfnt() []IDictionaryAttrDfntContext
	DictionaryAttrDfnt(i int) IDictionaryAttrDfntContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDictionarySchemaClauseContext differentiates from other interfaces.
	IsDictionarySchemaClauseContext()
}

type DictionarySchemaClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionarySchemaClauseContext() *DictionarySchemaClauseContext {
	var p = new(DictionarySchemaClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionarySchemaClause
	return p
}

func InitEmptyDictionarySchemaClauseContext(p *DictionarySchemaClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionarySchemaClause
}

func (*DictionarySchemaClauseContext) IsDictionarySchemaClauseContext() {}

func NewDictionarySchemaClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionarySchemaClauseContext {
	var p = new(DictionarySchemaClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionarySchemaClause

	return p
}

func (s *DictionarySchemaClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionarySchemaClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *DictionarySchemaClauseContext) AllDictionaryAttrDfnt() []IDictionaryAttrDfntContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionaryAttrDfntContext); ok {
			len++
		}
	}

	tst := make([]IDictionaryAttrDfntContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionaryAttrDfntContext); ok {
			tst[i] = t.(IDictionaryAttrDfntContext)
			i++
		}
	}

	return tst
}

func (s *DictionarySchemaClauseContext) DictionaryAttrDfnt(i int) IDictionaryAttrDfntContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryAttrDfntContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryAttrDfntContext)
}

func (s *DictionarySchemaClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *DictionarySchemaClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *DictionarySchemaClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *DictionarySchemaClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionarySchemaClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionarySchemaClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionarySchemaClause(s)
	}
}

func (s *DictionarySchemaClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionarySchemaClause(s)
	}
}

func (p *ClickHouseParser) DictionarySchemaClause() (localctx IDictionarySchemaClauseContext) {
	localctx = NewDictionarySchemaClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ClickHouseParserRULE_dictionarySchemaClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(703)
		p.DictionaryAttrDfnt()
	}
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(704)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(705)
			p.DictionaryAttrDfnt()
		}

		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(711)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryAttrDfntContext is an interface to support dynamic dispatch.
type IDictionaryAttrDfntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAttrs returns the attrs attribute.
	GetAttrs() map[string]bool

	// SetAttrs sets the attrs attribute.
	SetAttrs(map[string]bool)

	// Getter signatures
	Identifier() IIdentifierContext
	ColumnTypeExpr() IColumnTypeExprContext
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	AllLiteral() []ILiteralContext
	Literal(i int) ILiteralContext
	AllEXPRESSION() []antlr.TerminalNode
	EXPRESSION(i int) antlr.TerminalNode
	AllColumnExpr() []IColumnExprContext
	ColumnExpr(i int) IColumnExprContext
	AllHIERARCHICAL() []antlr.TerminalNode
	HIERARCHICAL(i int) antlr.TerminalNode
	AllINJECTIVE() []antlr.TerminalNode
	INJECTIVE(i int) antlr.TerminalNode
	AllIS_OBJECT_ID() []antlr.TerminalNode
	IS_OBJECT_ID(i int) antlr.TerminalNode

	// IsDictionaryAttrDfntContext differentiates from other interfaces.
	IsDictionaryAttrDfntContext()
}

type DictionaryAttrDfntContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	attrs  map[string]bool
}

func NewEmptyDictionaryAttrDfntContext() *DictionaryAttrDfntContext {
	var p = new(DictionaryAttrDfntContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryAttrDfnt
	return p
}

func InitEmptyDictionaryAttrDfntContext(p *DictionaryAttrDfntContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryAttrDfnt
}

func (*DictionaryAttrDfntContext) IsDictionaryAttrDfntContext() {}

func NewDictionaryAttrDfntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryAttrDfntContext {
	var p = new(DictionaryAttrDfntContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionaryAttrDfnt

	return p
}

func (s *DictionaryAttrDfntContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryAttrDfntContext) GetAttrs() map[string]bool { return s.attrs }

func (s *DictionaryAttrDfntContext) SetAttrs(v map[string]bool) { s.attrs = v }

func (s *DictionaryAttrDfntContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DictionaryAttrDfntContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *DictionaryAttrDfntContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserDEFAULT)
}

func (s *DictionaryAttrDfntContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEFAULT, i)
}

func (s *DictionaryAttrDfntContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryAttrDfntContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DictionaryAttrDfntContext) AllEXPRESSION() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserEXPRESSION)
}

func (s *DictionaryAttrDfntContext) EXPRESSION(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPRESSION, i)
}

func (s *DictionaryAttrDfntContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryAttrDfntContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *DictionaryAttrDfntContext) AllHIERARCHICAL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserHIERARCHICAL)
}

func (s *DictionaryAttrDfntContext) HIERARCHICAL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHIERARCHICAL, i)
}

func (s *DictionaryAttrDfntContext) AllINJECTIVE() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserINJECTIVE)
}

func (s *DictionaryAttrDfntContext) INJECTIVE(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINJECTIVE, i)
}

func (s *DictionaryAttrDfntContext) AllIS_OBJECT_ID() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserIS_OBJECT_ID)
}

func (s *DictionaryAttrDfntContext) IS_OBJECT_ID(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIS_OBJECT_ID, i)
}

func (s *DictionaryAttrDfntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryAttrDfntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryAttrDfntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionaryAttrDfnt(s)
	}
}

func (s *DictionaryAttrDfntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionaryAttrDfnt(s)
	}
}

func (p *ClickHouseParser) DictionaryAttrDfnt() (localctx IDictionaryAttrDfntContext) {
	localctx = NewDictionaryAttrDfntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ClickHouseParserRULE_dictionaryAttrDfnt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)

	localctx.(*DictionaryAttrDfntContext).attrs = make(map[string]bool)

	{
		p.SetState(714)
		p.Identifier()
	}
	{
		p.SetState(715)
		p.ColumnTypeExpr()
	}
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(735)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
			case 1:
				p.SetState(716)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["default"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$attrs[\"default\"]", ""))
					goto errorExit
				}
				{
					p.SetState(717)
					p.Match(ClickHouseParserDEFAULT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(718)
					p.Literal()
				}
				localctx.(*DictionaryAttrDfntContext).attrs["default"] = true

			case 2:
				p.SetState(721)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["expression"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$attrs[\"expression\"]", ""))
					goto errorExit
				}
				{
					p.SetState(722)
					p.Match(ClickHouseParserEXPRESSION)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(723)
					p.columnExpr(0)
				}
				localctx.(*DictionaryAttrDfntContext).attrs["expression"] = true

			case 3:
				p.SetState(726)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["hierarchical"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$attrs[\"hierarchical\"]", ""))
					goto errorExit
				}
				{
					p.SetState(727)
					p.Match(ClickHouseParserHIERARCHICAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*DictionaryAttrDfntContext).attrs["hierarchical"] = true

			case 4:
				p.SetState(729)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["injective"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$attrs[\"injective\"]", ""))
					goto errorExit
				}
				{
					p.SetState(730)
					p.Match(ClickHouseParserINJECTIVE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*DictionaryAttrDfntContext).attrs["injective"] = true

			case 5:
				p.SetState(732)

				if !(!localctx.(*DictionaryAttrDfntContext).attrs["is_object_id"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$attrs[\"is_object_id\"]", ""))
					goto errorExit
				}
				{
					p.SetState(733)
					p.Match(ClickHouseParserIS_OBJECT_ID)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*DictionaryAttrDfntContext).attrs["is_object_id"] = true

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryEngineClauseContext is an interface to support dynamic dispatch.
type IDictionaryEngineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetClauses returns the clauses attribute.
	GetClauses() map[string]bool

	// SetClauses sets the clauses attribute.
	SetClauses(map[string]bool)

	// Getter signatures
	DictionaryPrimaryKeyClause() IDictionaryPrimaryKeyClauseContext
	AllSourceClause() []ISourceClauseContext
	SourceClause(i int) ISourceClauseContext
	AllLifetimeClause() []ILifetimeClauseContext
	LifetimeClause(i int) ILifetimeClauseContext
	AllLayoutClause() []ILayoutClauseContext
	LayoutClause(i int) ILayoutClauseContext
	AllRangeClause() []IRangeClauseContext
	RangeClause(i int) IRangeClauseContext
	AllDictionarySettingsClause() []IDictionarySettingsClauseContext
	DictionarySettingsClause(i int) IDictionarySettingsClauseContext

	// IsDictionaryEngineClauseContext differentiates from other interfaces.
	IsDictionaryEngineClauseContext()
}

type DictionaryEngineClauseContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	clauses map[string]bool
}

func NewEmptyDictionaryEngineClauseContext() *DictionaryEngineClauseContext {
	var p = new(DictionaryEngineClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryEngineClause
	return p
}

func InitEmptyDictionaryEngineClauseContext(p *DictionaryEngineClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryEngineClause
}

func (*DictionaryEngineClauseContext) IsDictionaryEngineClauseContext() {}

func NewDictionaryEngineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryEngineClauseContext {
	var p = new(DictionaryEngineClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionaryEngineClause

	return p
}

func (s *DictionaryEngineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryEngineClauseContext) GetClauses() map[string]bool { return s.clauses }

func (s *DictionaryEngineClauseContext) SetClauses(v map[string]bool) { s.clauses = v }

func (s *DictionaryEngineClauseContext) DictionaryPrimaryKeyClause() IDictionaryPrimaryKeyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryPrimaryKeyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryPrimaryKeyClauseContext)
}

func (s *DictionaryEngineClauseContext) AllSourceClause() []ISourceClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISourceClauseContext); ok {
			len++
		}
	}

	tst := make([]ISourceClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISourceClauseContext); ok {
			tst[i] = t.(ISourceClauseContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) SourceClause(i int) ISourceClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceClauseContext)
}

func (s *DictionaryEngineClauseContext) AllLifetimeClause() []ILifetimeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILifetimeClauseContext); ok {
			len++
		}
	}

	tst := make([]ILifetimeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILifetimeClauseContext); ok {
			tst[i] = t.(ILifetimeClauseContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) LifetimeClause(i int) ILifetimeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILifetimeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILifetimeClauseContext)
}

func (s *DictionaryEngineClauseContext) AllLayoutClause() []ILayoutClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILayoutClauseContext); ok {
			len++
		}
	}

	tst := make([]ILayoutClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILayoutClauseContext); ok {
			tst[i] = t.(ILayoutClauseContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) LayoutClause(i int) ILayoutClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILayoutClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILayoutClauseContext)
}

func (s *DictionaryEngineClauseContext) AllRangeClause() []IRangeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangeClauseContext); ok {
			len++
		}
	}

	tst := make([]IRangeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangeClauseContext); ok {
			tst[i] = t.(IRangeClauseContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) RangeClause(i int) IRangeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeClauseContext)
}

func (s *DictionaryEngineClauseContext) AllDictionarySettingsClause() []IDictionarySettingsClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionarySettingsClauseContext); ok {
			len++
		}
	}

	tst := make([]IDictionarySettingsClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionarySettingsClauseContext); ok {
			tst[i] = t.(IDictionarySettingsClauseContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryEngineClauseContext) DictionarySettingsClause(i int) IDictionarySettingsClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionarySettingsClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionarySettingsClauseContext)
}

func (s *DictionaryEngineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryEngineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryEngineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionaryEngineClause(s)
	}
}

func (s *DictionaryEngineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionaryEngineClause(s)
	}
}

func (p *ClickHouseParser) DictionaryEngineClause() (localctx IDictionaryEngineClauseContext) {
	localctx = NewDictionaryEngineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ClickHouseParserRULE_dictionaryEngineClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)

	localctx.(*DictionaryEngineClauseContext).clauses = make(map[string]bool)

	p.SetState(742)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(741)
			p.DictionaryPrimaryKeyClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(764)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
			case 1:
				p.SetState(744)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["source"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"source\"]", ""))
					goto errorExit
				}
				{
					p.SetState(745)
					p.SourceClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["source"] = true

			case 2:
				p.SetState(748)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["lifetime"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"lifetime\"]", ""))
					goto errorExit
				}
				{
					p.SetState(749)
					p.LifetimeClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["lifetime"] = true

			case 3:
				p.SetState(752)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["layout"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"layout\"]", ""))
					goto errorExit
				}
				{
					p.SetState(753)
					p.LayoutClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["layout"] = true

			case 4:
				p.SetState(756)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["range"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"range\"]", ""))
					goto errorExit
				}
				{
					p.SetState(757)
					p.RangeClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["range"] = true

			case 5:
				p.SetState(760)

				if !(!localctx.(*DictionaryEngineClauseContext).clauses["settings"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"settings\"]", ""))
					goto errorExit
				}
				{
					p.SetState(761)
					p.DictionarySettingsClause()
				}
				localctx.(*DictionaryEngineClauseContext).clauses["settings"] = true

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryPrimaryKeyClauseContext is an interface to support dynamic dispatch.
type IDictionaryPrimaryKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext

	// IsDictionaryPrimaryKeyClauseContext differentiates from other interfaces.
	IsDictionaryPrimaryKeyClauseContext()
}

type DictionaryPrimaryKeyClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryPrimaryKeyClauseContext() *DictionaryPrimaryKeyClauseContext {
	var p = new(DictionaryPrimaryKeyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryPrimaryKeyClause
	return p
}

func InitEmptyDictionaryPrimaryKeyClauseContext(p *DictionaryPrimaryKeyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryPrimaryKeyClause
}

func (*DictionaryPrimaryKeyClauseContext) IsDictionaryPrimaryKeyClauseContext() {}

func NewDictionaryPrimaryKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryPrimaryKeyClauseContext {
	var p = new(DictionaryPrimaryKeyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionaryPrimaryKeyClause

	return p
}

func (s *DictionaryPrimaryKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryPrimaryKeyClauseContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRIMARY, 0)
}

func (s *DictionaryPrimaryKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEY, 0)
}

func (s *DictionaryPrimaryKeyClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *DictionaryPrimaryKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryPrimaryKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryPrimaryKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionaryPrimaryKeyClause(s)
	}
}

func (s *DictionaryPrimaryKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionaryPrimaryKeyClause(s)
	}
}

func (p *ClickHouseParser) DictionaryPrimaryKeyClause() (localctx IDictionaryPrimaryKeyClauseContext) {
	localctx = NewDictionaryPrimaryKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ClickHouseParserRULE_dictionaryPrimaryKeyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(ClickHouseParserPRIMARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(770)
		p.Match(ClickHouseParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(771)
		p.ColumnExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryArgExprContext is an interface to support dynamic dispatch.
type IDictionaryArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Literal() ILiteralContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsDictionaryArgExprContext differentiates from other interfaces.
	IsDictionaryArgExprContext()
}

type DictionaryArgExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryArgExprContext() *DictionaryArgExprContext {
	var p = new(DictionaryArgExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryArgExpr
	return p
}

func InitEmptyDictionaryArgExprContext(p *DictionaryArgExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionaryArgExpr
}

func (*DictionaryArgExprContext) IsDictionaryArgExprContext() {}

func NewDictionaryArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryArgExprContext {
	var p = new(DictionaryArgExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionaryArgExpr

	return p
}

func (s *DictionaryArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryArgExprContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryArgExprContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DictionaryArgExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DictionaryArgExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *DictionaryArgExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *DictionaryArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionaryArgExpr(s)
	}
}

func (s *DictionaryArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionaryArgExpr(s)
	}
}

func (p *ClickHouseParser) DictionaryArgExpr() (localctx IDictionaryArgExprContext) {
	localctx = NewDictionaryArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ClickHouseParserRULE_dictionaryArgExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.Identifier()
	}
	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(774)
			p.Identifier()
		}
		p.SetState(777)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserLPAREN {
			{
				p.SetState(775)
				p.Match(ClickHouseParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(776)
				p.Match(ClickHouseParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		{
			p.SetState(779)
			p.Literal()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceClauseContext is an interface to support dynamic dispatch.
type ISourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SOURCE() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllDictionaryArgExpr() []IDictionaryArgExprContext
	DictionaryArgExpr(i int) IDictionaryArgExprContext

	// IsSourceClauseContext differentiates from other interfaces.
	IsSourceClauseContext()
}

type SourceClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceClauseContext() *SourceClauseContext {
	var p = new(SourceClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sourceClause
	return p
}

func InitEmptySourceClauseContext(p *SourceClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sourceClause
}

func (*SourceClauseContext) IsSourceClauseContext() {}

func NewSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceClauseContext {
	var p = new(SourceClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_sourceClause

	return p
}

func (s *SourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceClauseContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSOURCE, 0)
}

func (s *SourceClauseContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *SourceClauseContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *SourceClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SourceClauseContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserRPAREN)
}

func (s *SourceClauseContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, i)
}

func (s *SourceClauseContext) AllDictionaryArgExpr() []IDictionaryArgExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionaryArgExprContext); ok {
			len++
		}
	}

	tst := make([]IDictionaryArgExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionaryArgExprContext); ok {
			tst[i] = t.(IDictionaryArgExprContext)
			i++
		}
	}

	return tst
}

func (s *SourceClauseContext) DictionaryArgExpr(i int) IDictionaryArgExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryArgExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryArgExprContext)
}

func (s *SourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSourceClause(s)
	}
}

func (s *SourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSourceClause(s)
	}
}

func (p *ClickHouseParser) SourceClause() (localctx ISourceClauseContext) {
	localctx = NewSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ClickHouseParserRULE_sourceClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Match(ClickHouseParserSOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(783)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(784)
		p.Identifier()
	}
	{
		p.SetState(785)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-137438953473) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606851329) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&175921860444159) != 0) {
		{
			p.SetState(786)
			p.DictionaryArgExpr()
		}

		p.SetState(791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(792)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(793)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILifetimeClauseContext is an interface to support dynamic dispatch.
type ILifetimeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIFETIME() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllDECIMAL_LITERAL() []antlr.TerminalNode
	DECIMAL_LITERAL(i int) antlr.TerminalNode
	MIN() antlr.TerminalNode
	MAX() antlr.TerminalNode

	// IsLifetimeClauseContext differentiates from other interfaces.
	IsLifetimeClauseContext()
}

type LifetimeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLifetimeClauseContext() *LifetimeClauseContext {
	var p = new(LifetimeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_lifetimeClause
	return p
}

func InitEmptyLifetimeClauseContext(p *LifetimeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_lifetimeClause
}

func (*LifetimeClauseContext) IsLifetimeClauseContext() {}

func NewLifetimeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LifetimeClauseContext {
	var p = new(LifetimeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_lifetimeClause

	return p
}

func (s *LifetimeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LifetimeClauseContext) LIFETIME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIFETIME, 0)
}

func (s *LifetimeClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *LifetimeClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *LifetimeClauseContext) AllDECIMAL_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserDECIMAL_LITERAL)
}

func (s *LifetimeClauseContext) DECIMAL_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, i)
}

func (s *LifetimeClauseContext) MIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMIN, 0)
}

func (s *LifetimeClauseContext) MAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMAX, 0)
}

func (s *LifetimeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LifetimeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LifetimeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLifetimeClause(s)
	}
}

func (s *LifetimeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLifetimeClause(s)
	}
}

func (p *ClickHouseParser) LifetimeClause() (localctx ILifetimeClauseContext) {
	localctx = NewLifetimeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ClickHouseParserRULE_lifetimeClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		p.Match(ClickHouseParserLIFETIME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(796)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserDECIMAL_LITERAL:
		{
			p.SetState(797)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ClickHouseParserMIN:
		{
			p.SetState(798)
			p.Match(ClickHouseParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(799)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(800)
			p.Match(ClickHouseParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(801)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ClickHouseParserMAX:
		{
			p.SetState(802)
			p.Match(ClickHouseParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(803)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(804)
			p.Match(ClickHouseParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(805)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(808)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILayoutClauseContext is an interface to support dynamic dispatch.
type ILayoutClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LAYOUT() antlr.TerminalNode
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllDictionaryArgExpr() []IDictionaryArgExprContext
	DictionaryArgExpr(i int) IDictionaryArgExprContext

	// IsLayoutClauseContext differentiates from other interfaces.
	IsLayoutClauseContext()
}

type LayoutClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLayoutClauseContext() *LayoutClauseContext {
	var p = new(LayoutClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_layoutClause
	return p
}

func InitEmptyLayoutClauseContext(p *LayoutClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_layoutClause
}

func (*LayoutClauseContext) IsLayoutClauseContext() {}

func NewLayoutClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LayoutClauseContext {
	var p = new(LayoutClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_layoutClause

	return p
}

func (s *LayoutClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LayoutClauseContext) LAYOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLAYOUT, 0)
}

func (s *LayoutClauseContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *LayoutClauseContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *LayoutClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LayoutClauseContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserRPAREN)
}

func (s *LayoutClauseContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, i)
}

func (s *LayoutClauseContext) AllDictionaryArgExpr() []IDictionaryArgExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionaryArgExprContext); ok {
			len++
		}
	}

	tst := make([]IDictionaryArgExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionaryArgExprContext); ok {
			tst[i] = t.(IDictionaryArgExprContext)
			i++
		}
	}

	return tst
}

func (s *LayoutClauseContext) DictionaryArgExpr(i int) IDictionaryArgExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryArgExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryArgExprContext)
}

func (s *LayoutClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LayoutClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LayoutClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLayoutClause(s)
	}
}

func (s *LayoutClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLayoutClause(s)
	}
}

func (p *ClickHouseParser) LayoutClause() (localctx ILayoutClauseContext) {
	localctx = NewLayoutClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ClickHouseParserRULE_layoutClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.Match(ClickHouseParserLAYOUT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(811)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(812)
		p.Identifier()
	}
	{
		p.SetState(813)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-137438953473) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606851329) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&175921860444159) != 0) {
		{
			p.SetState(814)
			p.DictionaryArgExpr()
		}

		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(820)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(821)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeClauseContext is an interface to support dynamic dispatch.
type IRangeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RANGE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	MIN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	MAX() antlr.TerminalNode

	// IsRangeClauseContext differentiates from other interfaces.
	IsRangeClauseContext()
}

type RangeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeClauseContext() *RangeClauseContext {
	var p = new(RangeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_rangeClause
	return p
}

func InitEmptyRangeClauseContext(p *RangeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_rangeClause
}

func (*RangeClauseContext) IsRangeClauseContext() {}

func NewRangeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeClauseContext {
	var p = new(RangeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_rangeClause

	return p
}

func (s *RangeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeClauseContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRANGE, 0)
}

func (s *RangeClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *RangeClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *RangeClauseContext) MIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMIN, 0)
}

func (s *RangeClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RangeClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RangeClauseContext) MAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMAX, 0)
}

func (s *RangeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterRangeClause(s)
	}
}

func (s *RangeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitRangeClause(s)
	}
}

func (p *ClickHouseParser) RangeClause() (localctx IRangeClauseContext) {
	localctx = NewRangeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ClickHouseParserRULE_rangeClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Match(ClickHouseParserRANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(824)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserMIN:
		{
			p.SetState(825)
			p.Match(ClickHouseParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(826)
			p.Identifier()
		}
		{
			p.SetState(827)
			p.Match(ClickHouseParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(828)
			p.Identifier()
		}

	case ClickHouseParserMAX:
		{
			p.SetState(830)
			p.Match(ClickHouseParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(831)
			p.Identifier()
		}
		{
			p.SetState(832)
			p.Match(ClickHouseParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(833)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(837)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionarySettingsClauseContext is an interface to support dynamic dispatch.
type IDictionarySettingsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SETTINGS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	SettingExprList() ISettingExprListContext
	RPAREN() antlr.TerminalNode

	// IsDictionarySettingsClauseContext differentiates from other interfaces.
	IsDictionarySettingsClauseContext()
}

type DictionarySettingsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionarySettingsClauseContext() *DictionarySettingsClauseContext {
	var p = new(DictionarySettingsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionarySettingsClause
	return p
}

func InitEmptyDictionarySettingsClauseContext(p *DictionarySettingsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dictionarySettingsClause
}

func (*DictionarySettingsClauseContext) IsDictionarySettingsClauseContext() {}

func NewDictionarySettingsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionarySettingsClauseContext {
	var p = new(DictionarySettingsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dictionarySettingsClause

	return p
}

func (s *DictionarySettingsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionarySettingsClauseContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTINGS, 0)
}

func (s *DictionarySettingsClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *DictionarySettingsClauseContext) SettingExprList() ISettingExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingExprListContext)
}

func (s *DictionarySettingsClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *DictionarySettingsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionarySettingsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionarySettingsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDictionarySettingsClause(s)
	}
}

func (s *DictionarySettingsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDictionarySettingsClause(s)
	}
}

func (p *ClickHouseParser) DictionarySettingsClause() (localctx IDictionarySettingsClauseContext) {
	localctx = NewDictionarySettingsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ClickHouseParserRULE_dictionarySettingsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(839)
		p.Match(ClickHouseParserSETTINGS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(840)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(841)
		p.SettingExprList()
	}
	{
		p.SetState(842)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusterClauseContext is an interface to support dynamic dispatch.
type IClusterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	Identifier() IIdentifierContext
	StringLiteral() IStringLiteralContext

	// IsClusterClauseContext differentiates from other interfaces.
	IsClusterClauseContext()
}

type ClusterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusterClauseContext() *ClusterClauseContext {
	var p = new(ClusterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_clusterClause
	return p
}

func InitEmptyClusterClauseContext(p *ClusterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_clusterClause
}

func (*ClusterClauseContext) IsClusterClauseContext() {}

func NewClusterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusterClauseContext {
	var p = new(ClusterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_clusterClause

	return p
}

func (s *ClusterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusterClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserON, 0)
}

func (s *ClusterClauseContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLUSTER, 0)
}

func (s *ClusterClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClusterClauseContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ClusterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterClusterClause(s)
	}
}

func (s *ClusterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitClusterClause(s)
	}
}

func (p *ClickHouseParser) ClusterClause() (localctx IClusterClauseContext) {
	localctx = NewClusterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ClickHouseParserRULE_clusterClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.Match(ClickHouseParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(845)
		p.Match(ClickHouseParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserACCESS, ClickHouseParserADD, ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCACHES, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCLUSTERS, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOLUMNS, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserCURRENT, ClickHouseParserCURRENT_USER, ClickHouseParserCHANGED, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDAY, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserENABLED, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserENGINES, ClickHouseParserESTIMATE, ClickHouseParserEVENTS, ClickHouseParserEXCEPT, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTENDED, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFIELDS, ClickHouseParserFILESYSTEM, ClickHouseParserFILL, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOLLOWING, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserFUNCTIONS, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGRANTS, ClickHouseParserGROUP, ClickHouseParserGROUPING, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserHOUR, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIMPLICIT, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINDEXES, ClickHouseParserINDICES, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERPOLATE, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKEYS, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMICROSECOND, ClickHouseParserMILLISECOND, ClickHouseParserMIN, ClickHouseParserMINUTE, ClickHouseParserMODIFY, ClickHouseParserMONTH, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNANOSECOND, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserOVER, ClickHouseParserOVERRIDE, ClickHouseParserPARTITION, ClickHouseParserPIPELINE, ClickHouseParserPLAN, ClickHouseParserPOLICY, ClickHouseParserPOLICIES, ClickHouseParserPOPULATE, ClickHouseParserPRECEDING, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserPRIVILEGES, ClickHouseParserPROCESSLIST, ClickHouseParserPROFILE, ClickHouseParserPROFILES, ClickHouseParserPROJECTION, ClickHouseParserQUARTER, ClickHouseParserQUOTA, ClickHouseParserQUOTAS, ClickHouseParserRANGE, ClickHouseParserRECURSIVE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLE, ClickHouseParserROLES, ClickHouseParserROLLUP, ClickHouseParserROW, ClickHouseParserROWS, ClickHouseParserSAMPLE, ClickHouseParserSECOND, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTING, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserSTEP, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTREE, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNBOUNDED, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSER, ClickHouseParserUSERS, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWEEK, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWINDOW, ClickHouseParserWITH, ClickHouseParserYEAR, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE, ClickHouseParserIDENTIFIER:
		{
			p.SetState(846)
			p.Identifier()
		}

	case ClickHouseParserHEXADECIMAL_STRING_LITERAL, ClickHouseParserBINARY_STRING_LITERAL, ClickHouseParserSTRING_LITERAL:
		{
			p.SetState(847)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUuidClauseContext is an interface to support dynamic dispatch.
type IUuidClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UUID() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsUuidClauseContext differentiates from other interfaces.
	IsUuidClauseContext()
}

type UuidClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUuidClauseContext() *UuidClauseContext {
	var p = new(UuidClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_uuidClause
	return p
}

func InitEmptyUuidClauseContext(p *UuidClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_uuidClause
}

func (*UuidClauseContext) IsUuidClauseContext() {}

func NewUuidClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UuidClauseContext {
	var p = new(UuidClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_uuidClause

	return p
}

func (s *UuidClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UuidClauseContext) UUID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUUID, 0)
}

func (s *UuidClauseContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *UuidClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UuidClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UuidClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterUuidClause(s)
	}
}

func (s *UuidClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitUuidClause(s)
	}
}

func (p *ClickHouseParser) UuidClause() (localctx IUuidClauseContext) {
	localctx = NewUuidClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ClickHouseParserRULE_uuidClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Match(ClickHouseParserUUID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(851)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDestinationClauseContext is an interface to support dynamic dispatch.
type IDestinationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TO() antlr.TerminalNode
	TableIdentifier() ITableIdentifierContext

	// IsDestinationClauseContext differentiates from other interfaces.
	IsDestinationClauseContext()
}

type DestinationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationClauseContext() *DestinationClauseContext {
	var p = new(DestinationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_destinationClause
	return p
}

func InitEmptyDestinationClauseContext(p *DestinationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_destinationClause
}

func (*DestinationClauseContext) IsDestinationClauseContext() {}

func NewDestinationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationClauseContext {
	var p = new(DestinationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_destinationClause

	return p
}

func (s *DestinationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *DestinationClauseContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *DestinationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDestinationClause(s)
	}
}

func (s *DestinationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDestinationClause(s)
	}
}

func (p *ClickHouseParser) DestinationClause() (localctx IDestinationClauseContext) {
	localctx = NewDestinationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ClickHouseParserRULE_destinationClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Match(ClickHouseParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(854)
		p.TableIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubqueryClauseContext is an interface to support dynamic dispatch.
type ISubqueryClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	SelectUnionStmt() ISelectUnionStmtContext

	// IsSubqueryClauseContext differentiates from other interfaces.
	IsSubqueryClauseContext()
}

type SubqueryClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryClauseContext() *SubqueryClauseContext {
	var p = new(SubqueryClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_subqueryClause
	return p
}

func InitEmptySubqueryClauseContext(p *SubqueryClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_subqueryClause
}

func (*SubqueryClauseContext) IsSubqueryClauseContext() {}

func NewSubqueryClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryClauseContext {
	var p = new(SubqueryClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_subqueryClause

	return p
}

func (s *SubqueryClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *SubqueryClauseContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *SubqueryClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSubqueryClause(s)
	}
}

func (s *SubqueryClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSubqueryClause(s)
	}
}

func (p *ClickHouseParser) SubqueryClause() (localctx ISubqueryClauseContext) {
	localctx = NewSubqueryClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ClickHouseParserRULE_subqueryClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.Match(ClickHouseParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(857)
		p.SelectUnionStmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSchemaClauseContext is an interface to support dynamic dispatch.
type ITableSchemaClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableSchemaClauseContext differentiates from other interfaces.
	IsTableSchemaClauseContext()
}

type TableSchemaClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSchemaClauseContext() *TableSchemaClauseContext {
	var p = new(TableSchemaClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableSchemaClause
	return p
}

func InitEmptyTableSchemaClauseContext(p *TableSchemaClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableSchemaClause
}

func (*TableSchemaClauseContext) IsTableSchemaClauseContext() {}

func NewTableSchemaClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSchemaClauseContext {
	var p = new(TableSchemaClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableSchemaClause

	return p
}

func (s *TableSchemaClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSchemaClauseContext) CopyAll(ctx *TableSchemaClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableSchemaClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSchemaClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SchemaAsTableClauseContext struct {
	TableSchemaClauseContext
}

func NewSchemaAsTableClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SchemaAsTableClauseContext {
	var p = new(SchemaAsTableClauseContext)

	InitEmptyTableSchemaClauseContext(&p.TableSchemaClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSchemaClauseContext))

	return p
}

func (s *SchemaAsTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaAsTableClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *SchemaAsTableClauseContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *SchemaAsTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSchemaAsTableClause(s)
	}
}

func (s *SchemaAsTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSchemaAsTableClause(s)
	}
}

type SchemaAsFunctionClauseContext struct {
	TableSchemaClauseContext
}

func NewSchemaAsFunctionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SchemaAsFunctionClauseContext {
	var p = new(SchemaAsFunctionClauseContext)

	InitEmptyTableSchemaClauseContext(&p.TableSchemaClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSchemaClauseContext))

	return p
}

func (s *SchemaAsFunctionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaAsFunctionClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *SchemaAsFunctionClauseContext) TableFunctionExpr() ITableFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *SchemaAsFunctionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSchemaAsFunctionClause(s)
	}
}

func (s *SchemaAsFunctionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSchemaAsFunctionClause(s)
	}
}

type SchemaDescriptionClauseContext struct {
	TableSchemaClauseContext
}

func NewSchemaDescriptionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SchemaDescriptionClauseContext {
	var p = new(SchemaDescriptionClauseContext)

	InitEmptyTableSchemaClauseContext(&p.TableSchemaClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableSchemaClauseContext))

	return p
}

func (s *SchemaDescriptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaDescriptionClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *SchemaDescriptionClauseContext) AllTableElementExpr() []ITableElementExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableElementExprContext); ok {
			len++
		}
	}

	tst := make([]ITableElementExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableElementExprContext); ok {
			tst[i] = t.(ITableElementExprContext)
			i++
		}
	}

	return tst
}

func (s *SchemaDescriptionClauseContext) TableElementExpr(i int) ITableElementExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementExprContext)
}

func (s *SchemaDescriptionClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *SchemaDescriptionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *SchemaDescriptionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *SchemaDescriptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSchemaDescriptionClause(s)
	}
}

func (s *SchemaDescriptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSchemaDescriptionClause(s)
	}
}

func (p *ClickHouseParser) TableSchemaClause() (localctx ITableSchemaClauseContext) {
	localctx = NewTableSchemaClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ClickHouseParserRULE_tableSchemaClause)
	var _la int

	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSchemaDescriptionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(859)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(860)
			p.TableElementExpr()
		}
		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(861)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(862)
				p.TableElementExpr()
			}

			p.SetState(867)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(868)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSchemaAsTableClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(870)
			p.Match(ClickHouseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(871)
			p.TableIdentifier()
		}

	case 3:
		localctx = NewSchemaAsFunctionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(872)
			p.Match(ClickHouseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(873)
			p.TableFunctionExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineClauseContext is an interface to support dynamic dispatch.
type IEngineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetClauses returns the clauses attribute.
	GetClauses() map[string]bool

	// SetClauses sets the clauses attribute.
	SetClauses(map[string]bool)

	// Getter signatures
	EngineExpr() IEngineExprContext
	AllOrderByClause() []IOrderByClauseContext
	OrderByClause(i int) IOrderByClauseContext
	AllPartitionByClause() []IPartitionByClauseContext
	PartitionByClause(i int) IPartitionByClauseContext
	AllPrimaryKeyClause() []IPrimaryKeyClauseContext
	PrimaryKeyClause(i int) IPrimaryKeyClauseContext
	AllSampleByClause() []ISampleByClauseContext
	SampleByClause(i int) ISampleByClauseContext
	AllTtlClause() []ITtlClauseContext
	TtlClause(i int) ITtlClauseContext
	AllSettingsClause() []ISettingsClauseContext
	SettingsClause(i int) ISettingsClauseContext

	// IsEngineClauseContext differentiates from other interfaces.
	IsEngineClauseContext()
}

type EngineClauseContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	clauses map[string]bool
}

func NewEmptyEngineClauseContext() *EngineClauseContext {
	var p = new(EngineClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_engineClause
	return p
}

func InitEmptyEngineClauseContext(p *EngineClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_engineClause
}

func (*EngineClauseContext) IsEngineClauseContext() {}

func NewEngineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineClauseContext {
	var p = new(EngineClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_engineClause

	return p
}

func (s *EngineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineClauseContext) GetClauses() map[string]bool { return s.clauses }

func (s *EngineClauseContext) SetClauses(v map[string]bool) { s.clauses = v }

func (s *EngineClauseContext) EngineExpr() IEngineExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineExprContext)
}

func (s *EngineClauseContext) AllOrderByClause() []IOrderByClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			len++
		}
	}

	tst := make([]IOrderByClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderByClauseContext); ok {
			tst[i] = t.(IOrderByClauseContext)
			i++
		}
	}

	return tst
}

func (s *EngineClauseContext) OrderByClause(i int) IOrderByClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *EngineClauseContext) AllPartitionByClause() []IPartitionByClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionByClauseContext); ok {
			len++
		}
	}

	tst := make([]IPartitionByClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionByClauseContext); ok {
			tst[i] = t.(IPartitionByClauseContext)
			i++
		}
	}

	return tst
}

func (s *EngineClauseContext) PartitionByClause(i int) IPartitionByClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionByClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionByClauseContext)
}

func (s *EngineClauseContext) AllPrimaryKeyClause() []IPrimaryKeyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryKeyClauseContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryKeyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryKeyClauseContext); ok {
			tst[i] = t.(IPrimaryKeyClauseContext)
			i++
		}
	}

	return tst
}

func (s *EngineClauseContext) PrimaryKeyClause(i int) IPrimaryKeyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyClauseContext)
}

func (s *EngineClauseContext) AllSampleByClause() []ISampleByClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISampleByClauseContext); ok {
			len++
		}
	}

	tst := make([]ISampleByClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISampleByClauseContext); ok {
			tst[i] = t.(ISampleByClauseContext)
			i++
		}
	}

	return tst
}

func (s *EngineClauseContext) SampleByClause(i int) ISampleByClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleByClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleByClauseContext)
}

func (s *EngineClauseContext) AllTtlClause() []ITtlClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITtlClauseContext); ok {
			len++
		}
	}

	tst := make([]ITtlClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITtlClauseContext); ok {
			tst[i] = t.(ITtlClauseContext)
			i++
		}
	}

	return tst
}

func (s *EngineClauseContext) TtlClause(i int) ITtlClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtlClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtlClauseContext)
}

func (s *EngineClauseContext) AllSettingsClause() []ISettingsClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISettingsClauseContext); ok {
			len++
		}
	}

	tst := make([]ISettingsClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISettingsClauseContext); ok {
			tst[i] = t.(ISettingsClauseContext)
			i++
		}
	}

	return tst
}

func (s *EngineClauseContext) SettingsClause(i int) ISettingsClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingsClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingsClauseContext)
}

func (s *EngineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterEngineClause(s)
	}
}

func (s *EngineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitEngineClause(s)
	}
}

func (p *ClickHouseParser) EngineClause() (localctx IEngineClauseContext) {
	localctx = NewEngineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ClickHouseParserRULE_engineClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)

	localctx.(*EngineClauseContext).clauses = make(map[string]bool)

	{
		p.SetState(877)
		p.EngineExpr()
	}
	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(902)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) {
			case 1:
				p.SetState(878)

				if !(!localctx.(*EngineClauseContext).clauses["orderByClause"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"orderByClause\"]", ""))
					goto errorExit
				}
				{
					p.SetState(879)
					p.OrderByClause()
				}
				localctx.(*EngineClauseContext).clauses["orderByClause"] = true

			case 2:
				p.SetState(882)

				if !(!localctx.(*EngineClauseContext).clauses["partitionByClause"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"partitionByClause\"]", ""))
					goto errorExit
				}
				{
					p.SetState(883)
					p.PartitionByClause()
				}
				localctx.(*EngineClauseContext).clauses["partitionByClause"] = true

			case 3:
				p.SetState(886)

				if !(!localctx.(*EngineClauseContext).clauses["primaryKeyClause"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"primaryKeyClause\"]", ""))
					goto errorExit
				}
				{
					p.SetState(887)
					p.PrimaryKeyClause()
				}
				localctx.(*EngineClauseContext).clauses["primaryKeyClause"] = true

			case 4:
				p.SetState(890)

				if !(!localctx.(*EngineClauseContext).clauses["sampleByClause"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"sampleByClause\"]", ""))
					goto errorExit
				}
				{
					p.SetState(891)
					p.SampleByClause()
				}
				localctx.(*EngineClauseContext).clauses["sampleByClause"] = true

			case 5:
				p.SetState(894)

				if !(!localctx.(*EngineClauseContext).clauses["ttlClause"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"ttlClause\"]", ""))
					goto errorExit
				}
				{
					p.SetState(895)
					p.TtlClause()
				}
				localctx.(*EngineClauseContext).clauses["ttlClause"] = true

			case 6:
				p.SetState(898)

				if !(!localctx.(*EngineClauseContext).clauses["settingsClause"]) {
					p.SetError(antlr.NewFailedPredicateException(p, "!$clauses[\"settingsClause\"]", ""))
					goto errorExit
				}
				{
					p.SetState(899)
					p.SettingsClause()
				}
				localctx.(*EngineClauseContext).clauses["settingsClause"] = true

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionByClauseContext is an interface to support dynamic dispatch.
type IPartitionByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsPartitionByClauseContext differentiates from other interfaces.
	IsPartitionByClauseContext()
}

type PartitionByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByClauseContext() *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_partitionByClause
	return p
}

func InitEmptyPartitionByClauseContext(p *PartitionByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_partitionByClause
}

func (*PartitionByClauseContext) IsPartitionByClauseContext() {}

func NewPartitionByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_partitionByClause

	return p
}

func (s *PartitionByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPARTITION, 0)
}

func (s *PartitionByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *PartitionByClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *PartitionByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPartitionByClause(s)
	}
}

func (s *PartitionByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPartitionByClause(s)
	}
}

func (p *ClickHouseParser) PartitionByClause() (localctx IPartitionByClauseContext) {
	localctx = NewPartitionByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ClickHouseParserRULE_partitionByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		p.Match(ClickHouseParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(908)
		p.Match(ClickHouseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(909)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryKeyClauseContext is an interface to support dynamic dispatch.
type IPrimaryKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsPrimaryKeyClauseContext differentiates from other interfaces.
	IsPrimaryKeyClauseContext()
}

type PrimaryKeyClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyClauseContext() *PrimaryKeyClauseContext {
	var p = new(PrimaryKeyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_primaryKeyClause
	return p
}

func InitEmptyPrimaryKeyClauseContext(p *PrimaryKeyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_primaryKeyClause
}

func (*PrimaryKeyClauseContext) IsPrimaryKeyClauseContext() {}

func NewPrimaryKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyClauseContext {
	var p = new(PrimaryKeyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_primaryKeyClause

	return p
}

func (s *PrimaryKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyClauseContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRIMARY, 0)
}

func (s *PrimaryKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEY, 0)
}

func (s *PrimaryKeyClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *PrimaryKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPrimaryKeyClause(s)
	}
}

func (s *PrimaryKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPrimaryKeyClause(s)
	}
}

func (p *ClickHouseParser) PrimaryKeyClause() (localctx IPrimaryKeyClauseContext) {
	localctx = NewPrimaryKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ClickHouseParserRULE_primaryKeyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		p.Match(ClickHouseParserPRIMARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(912)
		p.Match(ClickHouseParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(913)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleByClauseContext is an interface to support dynamic dispatch.
type ISampleByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	BY() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsSampleByClauseContext differentiates from other interfaces.
	IsSampleByClauseContext()
}

type SampleByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleByClauseContext() *SampleByClauseContext {
	var p = new(SampleByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sampleByClause
	return p
}

func InitEmptySampleByClauseContext(p *SampleByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sampleByClause
}

func (*SampleByClauseContext) IsSampleByClauseContext() {}

func NewSampleByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleByClauseContext {
	var p = new(SampleByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_sampleByClause

	return p
}

func (s *SampleByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleByClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSAMPLE, 0)
}

func (s *SampleByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *SampleByClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *SampleByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSampleByClause(s)
	}
}

func (s *SampleByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSampleByClause(s)
	}
}

func (p *ClickHouseParser) SampleByClause() (localctx ISampleByClauseContext) {
	localctx = NewSampleByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ClickHouseParserRULE_sampleByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(915)
		p.Match(ClickHouseParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(916)
		p.Match(ClickHouseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(917)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITtlClauseContext is an interface to support dynamic dispatch.
type ITtlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TTL() antlr.TerminalNode
	AllTtlExpr() []ITtlExprContext
	TtlExpr(i int) ITtlExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTtlClauseContext differentiates from other interfaces.
	IsTtlClauseContext()
}

type TtlClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtlClauseContext() *TtlClauseContext {
	var p = new(TtlClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ttlClause
	return p
}

func InitEmptyTtlClauseContext(p *TtlClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ttlClause
}

func (*TtlClauseContext) IsTtlClauseContext() {}

func NewTtlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtlClauseContext {
	var p = new(TtlClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_ttlClause

	return p
}

func (s *TtlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TtlClauseContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *TtlClauseContext) AllTtlExpr() []ITtlExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITtlExprContext); ok {
			len++
		}
	}

	tst := make([]ITtlExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITtlExprContext); ok {
			tst[i] = t.(ITtlExprContext)
			i++
		}
	}

	return tst
}

func (s *TtlClauseContext) TtlExpr(i int) ITtlExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtlExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtlExprContext)
}

func (s *TtlClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *TtlClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *TtlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTtlClause(s)
	}
}

func (s *TtlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTtlClause(s)
	}
}

func (p *ClickHouseParser) TtlClause() (localctx ITtlClauseContext) {
	localctx = NewTtlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ClickHouseParserRULE_ttlClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.Match(ClickHouseParserTTL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(920)
		p.TtlExpr()
	}
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(921)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(922)
				p.TtlExpr()
			}

		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineExprContext is an interface to support dynamic dispatch.
type IEngineExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINE() antlr.TerminalNode
	IdentifierOrNull() IIdentifierOrNullContext
	EQ_SINGLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext

	// IsEngineExprContext differentiates from other interfaces.
	IsEngineExprContext()
}

type EngineExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineExprContext() *EngineExprContext {
	var p = new(EngineExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_engineExpr
	return p
}

func InitEmptyEngineExprContext(p *EngineExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_engineExpr
}

func (*EngineExprContext) IsEngineExprContext() {}

func NewEngineExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineExprContext {
	var p = new(EngineExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_engineExpr

	return p
}

func (s *EngineExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineExprContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserENGINE, 0)
}

func (s *EngineExprContext) IdentifierOrNull() IIdentifierOrNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrNullContext)
}

func (s *EngineExprContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *EngineExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *EngineExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *EngineExprContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *EngineExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterEngineExpr(s)
	}
}

func (s *EngineExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitEngineExpr(s)
	}
}

func (p *ClickHouseParser) EngineExpr() (localctx IEngineExprContext) {
	localctx = NewEngineExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ClickHouseParserRULE_engineExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Match(ClickHouseParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(930)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserEQ_SINGLE {
		{
			p.SetState(929)
			p.Match(ClickHouseParserEQ_SINGLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(932)
		p.IdentifierOrNull()
	}
	p.SetState(938)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(933)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4557642822898941953) != 0) || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&69) != 0) {
			{
				p.SetState(934)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(937)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementExprContext is an interface to support dynamic dispatch.
type ITableElementExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableElementExprContext differentiates from other interfaces.
	IsTableElementExprContext()
}

type TableElementExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementExprContext() *TableElementExprContext {
	var p = new(TableElementExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableElementExpr
	return p
}

func InitEmptyTableElementExprContext(p *TableElementExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableElementExpr
}

func (*TableElementExprContext) IsTableElementExprContext() {}

func NewTableElementExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementExprContext {
	var p = new(TableElementExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableElementExpr

	return p
}

func (s *TableElementExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementExprContext) CopyAll(ctx *TableElementExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableElementExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableElementExprProjectionContext struct {
	TableElementExprContext
}

func NewTableElementExprProjectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableElementExprProjectionContext {
	var p = new(TableElementExprProjectionContext)

	InitEmptyTableElementExprContext(&p.TableElementExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableElementExprContext))

	return p
}

func (s *TableElementExprProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprProjectionContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *TableElementExprProjectionContext) TableProjectionDfnt() ITableProjectionDfntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableProjectionDfntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableProjectionDfntContext)
}

func (s *TableElementExprProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableElementExprProjection(s)
	}
}

func (s *TableElementExprProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableElementExprProjection(s)
	}
}

type TableElementExprConstraintContext struct {
	TableElementExprContext
}

func NewTableElementExprConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableElementExprConstraintContext {
	var p = new(TableElementExprConstraintContext)

	InitEmptyTableElementExprContext(&p.TableElementExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableElementExprContext))

	return p
}

func (s *TableElementExprConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCONSTRAINT, 0)
}

func (s *TableElementExprConstraintContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableElementExprConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCHECK, 0)
}

func (s *TableElementExprConstraintContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TableElementExprConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableElementExprConstraint(s)
	}
}

func (s *TableElementExprConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableElementExprConstraint(s)
	}
}

type TableElementExprColumnContext struct {
	TableElementExprContext
}

func NewTableElementExprColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableElementExprColumnContext {
	var p = new(TableElementExprColumnContext)

	InitEmptyTableElementExprContext(&p.TableElementExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableElementExprContext))

	return p
}

func (s *TableElementExprColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprColumnContext) TableColumnDfnt() ITableColumnDfntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableColumnDfntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableColumnDfntContext)
}

func (s *TableElementExprColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableElementExprColumn(s)
	}
}

func (s *TableElementExprColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableElementExprColumn(s)
	}
}

type TableElementExprIndexContext struct {
	TableElementExprContext
}

func NewTableElementExprIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableElementExprIndexContext {
	var p = new(TableElementExprIndexContext)

	InitEmptyTableElementExprContext(&p.TableElementExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableElementExprContext))

	return p
}

func (s *TableElementExprIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementExprIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *TableElementExprIndexContext) TableIndexDfnt() ITableIndexDfntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIndexDfntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIndexDfntContext)
}

func (s *TableElementExprIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableElementExprIndex(s)
	}
}

func (s *TableElementExprIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableElementExprIndex(s)
	}
}

func (p *ClickHouseParser) TableElementExpr() (localctx ITableElementExprContext) {
	localctx = NewTableElementExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ClickHouseParserRULE_tableElementExpr)
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableElementExprColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(940)
			p.TableColumnDfnt()
		}

	case 2:
		localctx = NewTableElementExprConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(941)
			p.Match(ClickHouseParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(942)
			p.Identifier()
		}
		{
			p.SetState(943)
			p.Match(ClickHouseParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(944)
			p.columnExpr(0)
		}

	case 3:
		localctx = NewTableElementExprIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(946)
			p.Match(ClickHouseParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(947)
			p.TableIndexDfnt()
		}

	case 4:
		localctx = NewTableElementExprProjectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(948)
			p.Match(ClickHouseParserPROJECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(949)
			p.TableProjectionDfnt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableColumnDfntContext is an interface to support dynamic dispatch.
type ITableColumnDfntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedIdentifier() INestedIdentifierContext
	ColumnTypeExpr() IColumnTypeExprContext
	TableColumnPropertyExpr() ITableColumnPropertyExprContext
	COMMENT() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	CodecExpr() ICodecExprContext
	TTL() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsTableColumnDfntContext differentiates from other interfaces.
	IsTableColumnDfntContext()
}

type TableColumnDfntContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableColumnDfntContext() *TableColumnDfntContext {
	var p = new(TableColumnDfntContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableColumnDfnt
	return p
}

func InitEmptyTableColumnDfntContext(p *TableColumnDfntContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableColumnDfnt
}

func (*TableColumnDfntContext) IsTableColumnDfntContext() {}

func NewTableColumnDfntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableColumnDfntContext {
	var p = new(TableColumnDfntContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableColumnDfnt

	return p
}

func (s *TableColumnDfntContext) GetParser() antlr.Parser { return s.parser }

func (s *TableColumnDfntContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *TableColumnDfntContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *TableColumnDfntContext) TableColumnPropertyExpr() ITableColumnPropertyExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableColumnPropertyExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableColumnPropertyExprContext)
}

func (s *TableColumnDfntContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *TableColumnDfntContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TableColumnDfntContext) CodecExpr() ICodecExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodecExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodecExprContext)
}

func (s *TableColumnDfntContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *TableColumnDfntContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TableColumnDfntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableColumnDfntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableColumnDfntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableColumnDfnt(s)
	}
}

func (s *TableColumnDfntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableColumnDfnt(s)
	}
}

func (p *ClickHouseParser) TableColumnDfnt() (localctx ITableColumnDfntContext) {
	localctx = NewTableColumnDfntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ClickHouseParserRULE_tableColumnDfnt)
	var _la int

	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(952)
			p.NestedIdentifier()
		}
		{
			p.SetState(953)
			p.ColumnTypeExpr()
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserALIAS || _la == ClickHouseParserDEFAULT || _la == ClickHouseParserMATERIALIZED {
			{
				p.SetState(954)
				p.TableColumnPropertyExpr()
			}

		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCOMMENT {
			{
				p.SetState(957)
				p.Match(ClickHouseParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(958)
				p.StringLiteral()
			}

		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCODEC {
			{
				p.SetState(961)
				p.CodecExpr()
			}

		}
		p.SetState(966)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTTL {
			{
				p.SetState(964)
				p.Match(ClickHouseParserTTL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(965)
				p.columnExpr(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(968)
			p.NestedIdentifier()
		}
		p.SetState(970)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(969)
				p.ColumnTypeExpr()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(972)
			p.TableColumnPropertyExpr()
		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCOMMENT {
			{
				p.SetState(973)
				p.Match(ClickHouseParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(974)
				p.StringLiteral()
			}

		}
		p.SetState(978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCODEC {
			{
				p.SetState(977)
				p.CodecExpr()
			}

		}
		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTTL {
			{
				p.SetState(980)
				p.Match(ClickHouseParserTTL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(981)
				p.columnExpr(0)
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableColumnPropertyExprContext is an interface to support dynamic dispatch.
type ITableColumnPropertyExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnExpr() IColumnExprContext
	DEFAULT() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	ALIAS() antlr.TerminalNode

	// IsTableColumnPropertyExprContext differentiates from other interfaces.
	IsTableColumnPropertyExprContext()
}

type TableColumnPropertyExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableColumnPropertyExprContext() *TableColumnPropertyExprContext {
	var p = new(TableColumnPropertyExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyExpr
	return p
}

func InitEmptyTableColumnPropertyExprContext(p *TableColumnPropertyExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyExpr
}

func (*TableColumnPropertyExprContext) IsTableColumnPropertyExprContext() {}

func NewTableColumnPropertyExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableColumnPropertyExprContext {
	var p = new(TableColumnPropertyExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableColumnPropertyExpr

	return p
}

func (s *TableColumnPropertyExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableColumnPropertyExprContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TableColumnPropertyExprContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEFAULT, 0)
}

func (s *TableColumnPropertyExprContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZED, 0)
}

func (s *TableColumnPropertyExprContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALIAS, 0)
}

func (s *TableColumnPropertyExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableColumnPropertyExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableColumnPropertyExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableColumnPropertyExpr(s)
	}
}

func (s *TableColumnPropertyExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableColumnPropertyExpr(s)
	}
}

func (p *ClickHouseParser) TableColumnPropertyExpr() (localctx ITableColumnPropertyExprContext) {
	localctx = NewTableColumnPropertyExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ClickHouseParserRULE_tableColumnPropertyExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(986)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserALIAS || _la == ClickHouseParserDEFAULT || _la == ClickHouseParserMATERIALIZED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(987)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableIndexDfntContext is an interface to support dynamic dispatch.
type ITableIndexDfntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedIdentifier() INestedIdentifierContext
	ColumnExpr() IColumnExprContext
	TYPE() antlr.TerminalNode
	ColumnTypeExpr() IColumnTypeExprContext
	GRANULARITY() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode

	// IsTableIndexDfntContext differentiates from other interfaces.
	IsTableIndexDfntContext()
}

type TableIndexDfntContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableIndexDfntContext() *TableIndexDfntContext {
	var p = new(TableIndexDfntContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableIndexDfnt
	return p
}

func InitEmptyTableIndexDfntContext(p *TableIndexDfntContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableIndexDfnt
}

func (*TableIndexDfntContext) IsTableIndexDfntContext() {}

func NewTableIndexDfntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIndexDfntContext {
	var p = new(TableIndexDfntContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableIndexDfnt

	return p
}

func (s *TableIndexDfntContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIndexDfntContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *TableIndexDfntContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TableIndexDfntContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTYPE, 0)
}

func (s *TableIndexDfntContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *TableIndexDfntContext) GRANULARITY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGRANULARITY, 0)
}

func (s *TableIndexDfntContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *TableIndexDfntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIndexDfntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIndexDfntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableIndexDfnt(s)
	}
}

func (s *TableIndexDfntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableIndexDfnt(s)
	}
}

func (p *ClickHouseParser) TableIndexDfnt() (localctx ITableIndexDfntContext) {
	localctx = NewTableIndexDfntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ClickHouseParserRULE_tableIndexDfnt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(989)
		p.NestedIdentifier()
	}
	{
		p.SetState(990)
		p.columnExpr(0)
	}
	{
		p.SetState(991)
		p.Match(ClickHouseParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(992)
		p.ColumnTypeExpr()
	}
	{
		p.SetState(993)
		p.Match(ClickHouseParserGRANULARITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(994)
		p.Match(ClickHouseParserDECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableProjectionDfntContext is an interface to support dynamic dispatch.
type ITableProjectionDfntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedIdentifier() INestedIdentifierContext
	ProjectionSelectStmt() IProjectionSelectStmtContext

	// IsTableProjectionDfntContext differentiates from other interfaces.
	IsTableProjectionDfntContext()
}

type TableProjectionDfntContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableProjectionDfntContext() *TableProjectionDfntContext {
	var p = new(TableProjectionDfntContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableProjectionDfnt
	return p
}

func InitEmptyTableProjectionDfntContext(p *TableProjectionDfntContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableProjectionDfnt
}

func (*TableProjectionDfntContext) IsTableProjectionDfntContext() {}

func NewTableProjectionDfntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableProjectionDfntContext {
	var p = new(TableProjectionDfntContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableProjectionDfnt

	return p
}

func (s *TableProjectionDfntContext) GetParser() antlr.Parser { return s.parser }

func (s *TableProjectionDfntContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *TableProjectionDfntContext) ProjectionSelectStmt() IProjectionSelectStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectionSelectStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectionSelectStmtContext)
}

func (s *TableProjectionDfntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableProjectionDfntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableProjectionDfntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableProjectionDfnt(s)
	}
}

func (s *TableProjectionDfntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableProjectionDfnt(s)
	}
}

func (p *ClickHouseParser) TableProjectionDfnt() (localctx ITableProjectionDfntContext) {
	localctx = NewTableProjectionDfntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ClickHouseParserRULE_tableProjectionDfnt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(996)
		p.NestedIdentifier()
	}
	{
		p.SetState(997)
		p.ProjectionSelectStmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodecExprContext is an interface to support dynamic dispatch.
type ICodecExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CODEC() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllCodecArgExpr() []ICodecArgExprContext
	CodecArgExpr(i int) ICodecArgExprContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCodecExprContext differentiates from other interfaces.
	IsCodecExprContext()
}

type CodecExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodecExprContext() *CodecExprContext {
	var p = new(CodecExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_codecExpr
	return p
}

func InitEmptyCodecExprContext(p *CodecExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_codecExpr
}

func (*CodecExprContext) IsCodecExprContext() {}

func NewCodecExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodecExprContext {
	var p = new(CodecExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_codecExpr

	return p
}

func (s *CodecExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CodecExprContext) CODEC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCODEC, 0)
}

func (s *CodecExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *CodecExprContext) AllCodecArgExpr() []ICodecArgExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodecArgExprContext); ok {
			len++
		}
	}

	tst := make([]ICodecArgExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodecArgExprContext); ok {
			tst[i] = t.(ICodecArgExprContext)
			i++
		}
	}

	return tst
}

func (s *CodecExprContext) CodecArgExpr(i int) ICodecArgExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodecArgExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodecArgExprContext)
}

func (s *CodecExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *CodecExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *CodecExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *CodecExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodecExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodecExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCodecExpr(s)
	}
}

func (s *CodecExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCodecExpr(s)
	}
}

func (p *ClickHouseParser) CodecExpr() (localctx ICodecExprContext) {
	localctx = NewCodecExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ClickHouseParserRULE_codecExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(999)
		p.Match(ClickHouseParserCODEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1000)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1001)
		p.CodecArgExpr()
	}
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(1002)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1003)
			p.CodecArgExpr()
		}

		p.SetState(1008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1009)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodecArgExprContext is an interface to support dynamic dispatch.
type ICodecArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext

	// IsCodecArgExprContext differentiates from other interfaces.
	IsCodecArgExprContext()
}

type CodecArgExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodecArgExprContext() *CodecArgExprContext {
	var p = new(CodecArgExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_codecArgExpr
	return p
}

func InitEmptyCodecArgExprContext(p *CodecArgExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_codecArgExpr
}

func (*CodecArgExprContext) IsCodecArgExprContext() {}

func NewCodecArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodecArgExprContext {
	var p = new(CodecArgExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_codecArgExpr

	return p
}

func (s *CodecArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CodecArgExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodecArgExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *CodecArgExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *CodecArgExprContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *CodecArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodecArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodecArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterCodecArgExpr(s)
	}
}

func (s *CodecArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitCodecArgExpr(s)
	}
}

func (p *ClickHouseParser) CodecArgExpr() (localctx ICodecArgExprContext) {
	localctx = NewCodecArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ClickHouseParserRULE_codecArgExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.Identifier()
	}
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserLPAREN {
		{
			p.SetState(1012)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4557642822898941953) != 0) || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&69) != 0) {
			{
				p.SetState(1013)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(1016)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITtlExprContext is an interface to support dynamic dispatch.
type ITtlExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnExpr() IColumnExprContext
	DELETE() antlr.TerminalNode
	TO() antlr.TerminalNode
	DISK() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	VOLUME() antlr.TerminalNode
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	SET() antlr.TerminalNode
	AllTtlSetExpr() []ITtlSetExprContext
	TtlSetExpr(i int) ITtlSetExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTtlExprContext differentiates from other interfaces.
	IsTtlExprContext()
}

type TtlExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtlExprContext() *TtlExprContext {
	var p = new(TtlExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ttlExpr
	return p
}

func InitEmptyTtlExprContext(p *TtlExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ttlExpr
}

func (*TtlExprContext) IsTtlExprContext() {}

func NewTtlExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtlExprContext {
	var p = new(TtlExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_ttlExpr

	return p
}

func (s *TtlExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TtlExprContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TtlExprContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELETE, 0)
}

func (s *TtlExprContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *TtlExprContext) DISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISK, 0)
}

func (s *TtlExprContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TtlExprContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVOLUME, 0)
}

func (s *TtlExprContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *TtlExprContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *TtlExprContext) SET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSET, 0)
}

func (s *TtlExprContext) AllTtlSetExpr() []ITtlSetExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITtlSetExprContext); ok {
			len++
		}
	}

	tst := make([]ITtlSetExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITtlSetExprContext); ok {
			tst[i] = t.(ITtlSetExprContext)
			i++
		}
	}

	return tst
}

func (s *TtlExprContext) TtlSetExpr(i int) ITtlSetExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtlSetExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtlSetExprContext)
}

func (s *TtlExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *TtlExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *TtlExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtlExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtlExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTtlExpr(s)
	}
}

func (s *TtlExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTtlExpr(s)
	}
}

func (p *ClickHouseParser) TtlExpr() (localctx ITtlExprContext) {
	localctx = NewTtlExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ClickHouseParserRULE_ttlExpr)
	var _alt int

	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1019)
			p.columnExpr(0)
		}
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1020)
				p.Match(ClickHouseParserDELETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1022)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1021)
					p.WhereClause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1024)
				p.Match(ClickHouseParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1025)
				p.Match(ClickHouseParserDISK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1026)
				p.StringLiteral()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1027)
				p.Match(ClickHouseParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1028)
				p.Match(ClickHouseParserVOLUME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1029)
				p.StringLiteral()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1032)
			p.columnExpr(0)
		}
		{
			p.SetState(1033)
			p.GroupByClause()
		}
		{
			p.SetState(1034)
			p.Match(ClickHouseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1035)
			p.TtlSetExpr()
		}
		p.SetState(1040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1036)
					p.Match(ClickHouseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1037)
					p.TtlSetExpr()
				}

			}
			p.SetState(1042)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITtlSetExprContext is an interface to support dynamic dispatch.
type ITtlSetExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnExpr() []IColumnExprContext
	ColumnExpr(i int) IColumnExprContext
	EQ_SINGLE() antlr.TerminalNode

	// IsTtlSetExprContext differentiates from other interfaces.
	IsTtlSetExprContext()
}

type TtlSetExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtlSetExprContext() *TtlSetExprContext {
	var p = new(TtlSetExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ttlSetExpr
	return p
}

func InitEmptyTtlSetExprContext(p *TtlSetExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ttlSetExpr
}

func (*TtlSetExprContext) IsTtlSetExprContext() {}

func NewTtlSetExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtlSetExprContext {
	var p = new(TtlSetExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_ttlSetExpr

	return p
}

func (s *TtlSetExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TtlSetExprContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *TtlSetExprContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *TtlSetExprContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *TtlSetExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtlSetExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtlSetExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTtlSetExpr(s)
	}
}

func (s *TtlSetExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTtlSetExpr(s)
	}
}

func (p *ClickHouseParser) TtlSetExpr() (localctx ITtlSetExprContext) {
	localctx = NewTtlSetExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ClickHouseParserRULE_ttlSetExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.columnExpr(0)
	}
	{
		p.SetState(1046)
		p.Match(ClickHouseParserEQ_SINGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1047)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeStmtContext is an interface to support dynamic dispatch.
type IDescribeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableExpr() ITableExprContext
	DESCRIBE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	TABLE() antlr.TerminalNode

	// IsDescribeStmtContext differentiates from other interfaces.
	IsDescribeStmtContext()
}

type DescribeStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeStmtContext() *DescribeStmtContext {
	var p = new(DescribeStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_describeStmt
	return p
}

func InitEmptyDescribeStmtContext(p *DescribeStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_describeStmt
}

func (*DescribeStmtContext) IsDescribeStmtContext() {}

func NewDescribeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeStmtContext {
	var p = new(DescribeStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_describeStmt

	return p
}

func (s *DescribeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeStmtContext) TableExpr() ITableExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableExprContext)
}

func (s *DescribeStmtContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESCRIBE, 0)
}

func (s *DescribeStmtContext) DESC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESC, 0)
}

func (s *DescribeStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *DescribeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescribeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDescribeStmt(s)
	}
}

func (s *DescribeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDescribeStmt(s)
	}
}

func (p *ClickHouseParser) DescribeStmt() (localctx IDescribeStmtContext) {
	localctx = NewDescribeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ClickHouseParserRULE_describeStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1049)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserDESC || _la == ClickHouseParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1050)
			p.Match(ClickHouseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1053)
		p.tableExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStmtContext is an interface to support dynamic dispatch.
type IDropStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDropStmtContext differentiates from other interfaces.
	IsDropStmtContext()
}

type DropStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropStmtContext() *DropStmtContext {
	var p = new(DropStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dropStmt
	return p
}

func InitEmptyDropStmtContext(p *DropStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dropStmt
}

func (*DropStmtContext) IsDropStmtContext() {}

func NewDropStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStmtContext {
	var p = new(DropStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dropStmt

	return p
}

func (s *DropStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStmtContext) CopyAll(ctx *DropStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DropStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropDatabaseStmtContext struct {
	DropStmtContext
}

func NewDropDatabaseStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropDatabaseStmtContext {
	var p = new(DropDatabaseStmtContext)

	InitEmptyDropStmtContext(&p.DropStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*DropStmtContext))

	return p
}

func (s *DropDatabaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *DropDatabaseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *DropDatabaseStmtContext) DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDETACH, 0)
}

func (s *DropDatabaseStmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *DropDatabaseStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *DropDatabaseStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *DropDatabaseStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *DropDatabaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDropDatabaseStmt(s)
	}
}

func (s *DropDatabaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDropDatabaseStmt(s)
	}
}

type DropTableStmtContext struct {
	DropStmtContext
}

func NewDropTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableStmtContext {
	var p = new(DropTableStmtContext)

	InitEmptyDropStmtContext(&p.DropStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*DropStmtContext))

	return p
}

func (s *DropTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *DropTableStmtContext) DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDETACH, 0)
}

func (s *DropTableStmtContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *DropTableStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *DropTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *DropTableStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *DropTableStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *DropTableStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *DropTableStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *DropTableStmtContext) NO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNO, 0)
}

func (s *DropTableStmtContext) DELAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELAY, 0)
}

func (s *DropTableStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *DropTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDropTableStmt(s)
	}
}

func (s *DropTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDropTableStmt(s)
	}
}

func (p *ClickHouseParser) DropStmt() (localctx IDropStmtContext) {
	localctx = NewDropStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ClickHouseParserRULE_dropStmt)
	var _la int

	p.SetState(1086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDropDatabaseStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1055)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserDETACH || _la == ClickHouseParserDROP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1056)
			p.Match(ClickHouseParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1059)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1057)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1058)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1061)
			p.DatabaseIdentifier()
		}
		p.SetState(1063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(1062)
				p.ClusterClause()
			}

		}

	case 2:
		localctx = NewDropTableStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1065)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserDETACH || _la == ClickHouseParserDROP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserDICTIONARY:
			{
				p.SetState(1066)
				p.Match(ClickHouseParserDICTIONARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case ClickHouseParserTABLE, ClickHouseParserTEMPORARY:
			p.SetState(1068)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserTEMPORARY {
				{
					p.SetState(1067)
					p.Match(ClickHouseParserTEMPORARY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1070)
				p.Match(ClickHouseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case ClickHouseParserVIEW:
			{
				p.SetState(1071)
				p.Match(ClickHouseParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1076)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1074)
				p.Match(ClickHouseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1075)
				p.Match(ClickHouseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1078)
			p.TableIdentifier()
		}
		p.SetState(1080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(1079)
				p.ClusterClause()
			}

		}
		p.SetState(1084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserNO {
			{
				p.SetState(1082)
				p.Match(ClickHouseParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1083)
				p.Match(ClickHouseParserDELAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExistsStmtContext is an interface to support dynamic dispatch.
type IExistsStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExistsStmtContext differentiates from other interfaces.
	IsExistsStmtContext()
}

type ExistsStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExistsStmtContext() *ExistsStmtContext {
	var p = new(ExistsStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_existsStmt
	return p
}

func InitEmptyExistsStmtContext(p *ExistsStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_existsStmt
}

func (*ExistsStmtContext) IsExistsStmtContext() {}

func NewExistsStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExistsStmtContext {
	var p = new(ExistsStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_existsStmt

	return p
}

func (s *ExistsStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExistsStmtContext) CopyAll(ctx *ExistsStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExistsStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExistsTableStmtContext struct {
	ExistsStmtContext
}

func NewExistsTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsTableStmtContext {
	var p = new(ExistsTableStmtContext)

	InitEmptyExistsStmtContext(&p.ExistsStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExistsStmtContext))

	return p
}

func (s *ExistsTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsTableStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *ExistsTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ExistsTableStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *ExistsTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *ExistsTableStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *ExistsTableStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *ExistsTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExistsTableStmt(s)
	}
}

func (s *ExistsTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExistsTableStmt(s)
	}
}

type ExistsDatabaseStmtContext struct {
	ExistsStmtContext
}

func NewExistsDatabaseStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsDatabaseStmtContext {
	var p = new(ExistsDatabaseStmtContext)

	InitEmptyExistsStmtContext(&p.ExistsStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExistsStmtContext))

	return p
}

func (s *ExistsDatabaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsDatabaseStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *ExistsDatabaseStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *ExistsDatabaseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *ExistsDatabaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExistsDatabaseStmt(s)
	}
}

func (s *ExistsDatabaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExistsDatabaseStmt(s)
	}
}

func (p *ClickHouseParser) ExistsStmt() (localctx IExistsStmtContext) {
	localctx = NewExistsStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ClickHouseParserRULE_existsStmt)
	var _la int

	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExistsDatabaseStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1088)
			p.Match(ClickHouseParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1089)
			p.Match(ClickHouseParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1090)
			p.DatabaseIdentifier()
		}

	case 2:
		localctx = NewExistsTableStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1091)
			p.Match(ClickHouseParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1098)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1092)
				p.Match(ClickHouseParserDICTIONARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 2 {
			p.SetState(1094)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserTEMPORARY {
				{
					p.SetState(1093)
					p.Match(ClickHouseParserTEMPORARY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1096)
				p.Match(ClickHouseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1097)
				p.Match(ClickHouseParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1100)
			p.TableIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainStmtContext is an interface to support dynamic dispatch.
type IExplainStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPLAIN() antlr.TerminalNode
	SelectUnionStmt() ISelectUnionStmtContext
	AST() antlr.TerminalNode
	SYNTAX() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	TREE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	PIPELINE() antlr.TerminalNode
	ESTIMATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	SettingExprList() ISettingExprListContext

	// IsExplainStmtContext differentiates from other interfaces.
	IsExplainStmtContext()
}

type ExplainStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainStmtContext() *ExplainStmtContext {
	var p = new(ExplainStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_explainStmt
	return p
}

func InitEmptyExplainStmtContext(p *ExplainStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_explainStmt
}

func (*ExplainStmtContext) IsExplainStmtContext() {}

func NewExplainStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainStmtContext {
	var p = new(ExplainStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_explainStmt

	return p
}

func (s *ExplainStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainStmtContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPLAIN, 0)
}

func (s *ExplainStmtContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *ExplainStmtContext) AST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAST, 0)
}

func (s *ExplainStmtContext) SYNTAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNTAX, 0)
}

func (s *ExplainStmtContext) QUERY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUERY, 0)
}

func (s *ExplainStmtContext) TREE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTREE, 0)
}

func (s *ExplainStmtContext) PLAN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPLAN, 0)
}

func (s *ExplainStmtContext) PIPELINE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPIPELINE, 0)
}

func (s *ExplainStmtContext) ESTIMATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserESTIMATE, 0)
}

func (s *ExplainStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *ExplainStmtContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOVERRIDE, 0)
}

func (s *ExplainStmtContext) SettingExprList() ISettingExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingExprListContext)
}

func (s *ExplainStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterExplainStmt(s)
	}
}

func (s *ExplainStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitExplainStmt(s)
	}
}

func (p *ClickHouseParser) ExplainStmt() (localctx IExplainStmtContext) {
	localctx = NewExplainStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ClickHouseParserRULE_explainStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1103)
		p.Match(ClickHouseParserEXPLAIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1104)
			p.Match(ClickHouseParserAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1105)
			p.Match(ClickHouseParserSYNTAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1106)
			p.Match(ClickHouseParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1107)
			p.Match(ClickHouseParserTREE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(1108)
			p.Match(ClickHouseParserPLAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 5 {
		{
			p.SetState(1109)
			p.Match(ClickHouseParserPIPELINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 6 {
		{
			p.SetState(1110)
			p.Match(ClickHouseParserESTIMATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 7 {
		{
			p.SetState(1111)
			p.Match(ClickHouseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1112)
			p.Match(ClickHouseParserOVERRIDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1116)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1115)
			p.SettingExprList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1118)
		p.SelectUnionStmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStmtContext is an interface to support dynamic dispatch.
type IInsertStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	DataClause() IDataClauseContext
	TableIdentifier() ITableIdentifierContext
	FUNCTION() antlr.TerminalNode
	TableFunctionExpr() ITableFunctionExprContext
	TABLE() antlr.TerminalNode
	ColumnsClause() IColumnsClauseContext

	// IsInsertStmtContext differentiates from other interfaces.
	IsInsertStmtContext()
}

type InsertStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStmtContext() *InsertStmtContext {
	var p = new(InsertStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_insertStmt
	return p
}

func InitEmptyInsertStmtContext(p *InsertStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_insertStmt
}

func (*InsertStmtContext) IsInsertStmtContext() {}

func NewInsertStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStmtContext {
	var p = new(InsertStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_insertStmt

	return p
}

func (s *InsertStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStmtContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINSERT, 0)
}

func (s *InsertStmtContext) INTO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTO, 0)
}

func (s *InsertStmtContext) DataClause() IDataClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataClauseContext)
}

func (s *InsertStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *InsertStmtContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFUNCTION, 0)
}

func (s *InsertStmtContext) TableFunctionExpr() ITableFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *InsertStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *InsertStmtContext) ColumnsClause() IColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsClauseContext)
}

func (s *InsertStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterInsertStmt(s)
	}
}

func (s *InsertStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitInsertStmt(s)
	}
}

func (p *ClickHouseParser) InsertStmt() (localctx IInsertStmtContext) {
	localctx = NewInsertStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ClickHouseParserRULE_insertStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1120)
		p.Match(ClickHouseParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1121)
		p.Match(ClickHouseParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1122)
			p.Match(ClickHouseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1125)
			p.TableIdentifier()
		}

	case 2:
		{
			p.SetState(1126)
			p.Match(ClickHouseParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1127)
			p.TableFunctionExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1130)
			p.ColumnsClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1133)
		p.DataClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnsClauseContext is an interface to support dynamic dispatch.
type IColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllNestedIdentifier() []INestedIdentifierContext
	NestedIdentifier(i int) INestedIdentifierContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnsClauseContext differentiates from other interfaces.
	IsColumnsClauseContext()
}

type ColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsClauseContext() *ColumnsClauseContext {
	var p = new(ColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnsClause
	return p
}

func InitEmptyColumnsClauseContext(p *ColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnsClause
}

func (*ColumnsClauseContext) IsColumnsClauseContext() {}

func NewColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsClauseContext {
	var p = new(ColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnsClause

	return p
}

func (s *ColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnsClauseContext) AllNestedIdentifier() []INestedIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			len++
		}
	}

	tst := make([]INestedIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INestedIdentifierContext); ok {
			tst[i] = t.(INestedIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnsClauseContext) NestedIdentifier(i int) INestedIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *ColumnsClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnsClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnsClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnsClause(s)
	}
}

func (s *ColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnsClause(s)
	}
}

func (p *ClickHouseParser) ColumnsClause() (localctx IColumnsClauseContext) {
	localctx = NewColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ClickHouseParserRULE_columnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1136)
		p.NestedIdentifier()
	}
	p.SetState(1141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(1137)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1138)
			p.NestedIdentifier()
		}

		p.SetState(1143)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1144)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataClauseContext is an interface to support dynamic dispatch.
type IDataClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataClauseContext differentiates from other interfaces.
	IsDataClauseContext()
}

type DataClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataClauseContext() *DataClauseContext {
	var p = new(DataClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dataClause
	return p
}

func InitEmptyDataClauseContext(p *DataClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_dataClause
}

func (*DataClauseContext) IsDataClauseContext() {}

func NewDataClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataClauseContext {
	var p = new(DataClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_dataClause

	return p
}

func (s *DataClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataClauseContext) CopyAll(ctx *DataClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DataClauseValuesContext struct {
	DataClauseContext
}

func NewDataClauseValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataClauseValuesContext {
	var p = new(DataClauseValuesContext)

	InitEmptyDataClauseContext(&p.DataClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataClauseContext))

	return p
}

func (s *DataClauseValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataClauseValuesContext) VALUES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVALUES, 0)
}

func (s *DataClauseValuesContext) AllAssignmentValues() []IAssignmentValuesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentValuesContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentValuesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentValuesContext); ok {
			tst[i] = t.(IAssignmentValuesContext)
			i++
		}
	}

	return tst
}

func (s *DataClauseValuesContext) AssignmentValues(i int) IAssignmentValuesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentValuesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentValuesContext)
}

func (s *DataClauseValuesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *DataClauseValuesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *DataClauseValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDataClauseValues(s)
	}
}

func (s *DataClauseValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDataClauseValues(s)
	}
}

type DataClauseFormatContext struct {
	DataClauseContext
}

func NewDataClauseFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataClauseFormatContext {
	var p = new(DataClauseFormatContext)

	InitEmptyDataClauseContext(&p.DataClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataClauseContext))

	return p
}

func (s *DataClauseFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataClauseFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFORMAT, 0)
}

func (s *DataClauseFormatContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataClauseFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDataClauseFormat(s)
	}
}

func (s *DataClauseFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDataClauseFormat(s)
	}
}

type DataClauseSelectContext struct {
	DataClauseContext
}

func NewDataClauseSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataClauseSelectContext {
	var p = new(DataClauseSelectContext)

	InitEmptyDataClauseContext(&p.DataClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataClauseContext))

	return p
}

func (s *DataClauseSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataClauseSelectContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *DataClauseSelectContext) EOF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEOF, 0)
}

func (s *DataClauseSelectContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSEMICOLON, 0)
}

func (s *DataClauseSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDataClauseSelect(s)
	}
}

func (s *DataClauseSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDataClauseSelect(s)
	}
}

func (p *ClickHouseParser) DataClause() (localctx IDataClauseContext) {
	localctx = NewDataClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ClickHouseParserRULE_dataClause)
	var _la int

	p.SetState(1163)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserFORMAT:
		localctx = NewDataClauseFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1146)
			p.Match(ClickHouseParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1147)
			p.Identifier()
		}

	case ClickHouseParserVALUES:
		localctx = NewDataClauseValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1148)
			p.Match(ClickHouseParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1149)
			p.AssignmentValues()
		}
		p.SetState(1154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1150)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1151)
				p.AssignmentValues()
			}

			p.SetState(1156)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case ClickHouseParserSELECT, ClickHouseParserWITH, ClickHouseParserLPAREN:
		localctx = NewDataClauseSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1157)
			p.SelectUnionStmt()
		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserSEMICOLON {
			{
				p.SetState(1158)
				p.Match(ClickHouseParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1161)
			p.Match(ClickHouseParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentValuesContext is an interface to support dynamic dispatch.
type IAssignmentValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllAssignmentValue() []IAssignmentValueContext
	AssignmentValue(i int) IAssignmentValueContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAssignmentValuesContext differentiates from other interfaces.
	IsAssignmentValuesContext()
}

type AssignmentValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentValuesContext() *AssignmentValuesContext {
	var p = new(AssignmentValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentValues
	return p
}

func InitEmptyAssignmentValuesContext(p *AssignmentValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentValues
}

func (*AssignmentValuesContext) IsAssignmentValuesContext() {}

func NewAssignmentValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentValuesContext {
	var p = new(AssignmentValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_assignmentValues

	return p
}

func (s *AssignmentValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentValuesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *AssignmentValuesContext) AllAssignmentValue() []IAssignmentValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentValueContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentValueContext); ok {
			tst[i] = t.(IAssignmentValueContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentValuesContext) AssignmentValue(i int) IAssignmentValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentValueContext)
}

func (s *AssignmentValuesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *AssignmentValuesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *AssignmentValuesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *AssignmentValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAssignmentValues(s)
	}
}

func (s *AssignmentValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAssignmentValues(s)
	}
}

func (p *ClickHouseParser) AssignmentValues() (localctx IAssignmentValuesContext) {
	localctx = NewAssignmentValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ClickHouseParserRULE_assignmentValues)
	var _la int

	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1165)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1166)
			p.AssignmentValue()
		}
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1167)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1168)
				p.AssignmentValue()
			}

			p.SetState(1173)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1174)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1176)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1177)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentValueContext is an interface to support dynamic dispatch.
type IAssignmentValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext

	// IsAssignmentValueContext differentiates from other interfaces.
	IsAssignmentValueContext()
}

type AssignmentValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentValueContext() *AssignmentValueContext {
	var p = new(AssignmentValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentValue
	return p
}

func InitEmptyAssignmentValueContext(p *AssignmentValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_assignmentValue
}

func (*AssignmentValueContext) IsAssignmentValueContext() {}

func NewAssignmentValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentValueContext {
	var p = new(AssignmentValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_assignmentValue

	return p
}

func (s *AssignmentValueContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentValueContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AssignmentValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAssignmentValue(s)
	}
}

func (s *AssignmentValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAssignmentValue(s)
	}
}

func (p *ClickHouseParser) AssignmentValue() (localctx IAssignmentValueContext) {
	localctx = NewAssignmentValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ClickHouseParserRULE_assignmentValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1180)
		p.Literal()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillStmtContext is an interface to support dynamic dispatch.
type IKillStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKillStmtContext differentiates from other interfaces.
	IsKillStmtContext()
}

type KillStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKillStmtContext() *KillStmtContext {
	var p = new(KillStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_killStmt
	return p
}

func InitEmptyKillStmtContext(p *KillStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_killStmt
}

func (*KillStmtContext) IsKillStmtContext() {}

func NewKillStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStmtContext {
	var p = new(KillStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_killStmt

	return p
}

func (s *KillStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStmtContext) CopyAll(ctx *KillStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *KillStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KillMutationStmtContext struct {
	KillStmtContext
}

func NewKillMutationStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillMutationStmtContext {
	var p = new(KillMutationStmtContext)

	InitEmptyKillStmtContext(&p.KillStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*KillStmtContext))

	return p
}

func (s *KillMutationStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillMutationStmtContext) KILL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKILL, 0)
}

func (s *KillMutationStmtContext) MUTATION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMUTATION, 0)
}

func (s *KillMutationStmtContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *KillMutationStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *KillMutationStmtContext) SYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNC, 0)
}

func (s *KillMutationStmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASYNC, 0)
}

func (s *KillMutationStmtContext) TEST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEST, 0)
}

func (s *KillMutationStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterKillMutationStmt(s)
	}
}

func (s *KillMutationStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitKillMutationStmt(s)
	}
}

func (p *ClickHouseParser) KillStmt() (localctx IKillStmtContext) {
	localctx = NewKillStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ClickHouseParserRULE_killStmt)
	var _la int

	localctx = NewKillMutationStmtContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1182)
		p.Match(ClickHouseParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1183)
		p.Match(ClickHouseParserMUTATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(1184)
			p.ClusterClause()
		}

	}
	{
		p.SetState(1187)
		p.WhereClause()
	}
	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserASYNC || _la == ClickHouseParserSYNC || _la == ClickHouseParserTEST {
		{
			p.SetState(1188)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserASYNC || _la == ClickHouseParserSYNC || _la == ClickHouseParserTEST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeStmtContext is an interface to support dynamic dispatch.
type IOptimizeStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPTIMIZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableIdentifier() ITableIdentifierContext
	ClusterClause() IClusterClauseContext
	PartitionClause() IPartitionClauseContext
	FINAL() antlr.TerminalNode
	DEDUPLICATE() antlr.TerminalNode

	// IsOptimizeStmtContext differentiates from other interfaces.
	IsOptimizeStmtContext()
}

type OptimizeStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizeStmtContext() *OptimizeStmtContext {
	var p = new(OptimizeStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_optimizeStmt
	return p
}

func InitEmptyOptimizeStmtContext(p *OptimizeStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_optimizeStmt
}

func (*OptimizeStmtContext) IsOptimizeStmtContext() {}

func NewOptimizeStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeStmtContext {
	var p = new(OptimizeStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_optimizeStmt

	return p
}

func (s *OptimizeStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeStmtContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOPTIMIZE, 0)
}

func (s *OptimizeStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *OptimizeStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *OptimizeStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *OptimizeStmtContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *OptimizeStmtContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFINAL, 0)
}

func (s *OptimizeStmtContext) DEDUPLICATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEDUPLICATE, 0)
}

func (s *OptimizeStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOptimizeStmt(s)
	}
}

func (s *OptimizeStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOptimizeStmt(s)
	}
}

func (p *ClickHouseParser) OptimizeStmt() (localctx IOptimizeStmtContext) {
	localctx = NewOptimizeStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ClickHouseParserRULE_optimizeStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1191)
		p.Match(ClickHouseParserOPTIMIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1192)
		p.Match(ClickHouseParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1193)
		p.TableIdentifier()
	}
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(1194)
			p.ClusterClause()
		}

	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserPARTITION {
		{
			p.SetState(1197)
			p.PartitionClause()
		}

	}
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserFINAL {
		{
			p.SetState(1200)
			p.Match(ClickHouseParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserDEDUPLICATE {
		{
			p.SetState(1203)
			p.Match(ClickHouseParserDEDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameStmtContext is an interface to support dynamic dispatch.
type IRenameStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllTableIdentifier() []ITableIdentifierContext
	TableIdentifier(i int) ITableIdentifierContext
	AllTO() []antlr.TerminalNode
	TO(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ClusterClause() IClusterClauseContext

	// IsRenameStmtContext differentiates from other interfaces.
	IsRenameStmtContext()
}

type RenameStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameStmtContext() *RenameStmtContext {
	var p = new(RenameStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_renameStmt
	return p
}

func InitEmptyRenameStmtContext(p *RenameStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_renameStmt
}

func (*RenameStmtContext) IsRenameStmtContext() {}

func NewRenameStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameStmtContext {
	var p = new(RenameStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_renameStmt

	return p
}

func (s *RenameStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameStmtContext) RENAME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRENAME, 0)
}

func (s *RenameStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *RenameStmtContext) AllTableIdentifier() []ITableIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITableIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableIdentifierContext); ok {
			tst[i] = t.(ITableIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameStmtContext) TableIdentifier(i int) ITableIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *RenameStmtContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserTO)
}

func (s *RenameStmtContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, i)
}

func (s *RenameStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *RenameStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *RenameStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *RenameStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterRenameStmt(s)
	}
}

func (s *RenameStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitRenameStmt(s)
	}
}

func (p *ClickHouseParser) RenameStmt() (localctx IRenameStmtContext) {
	localctx = NewRenameStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ClickHouseParserRULE_renameStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.Match(ClickHouseParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1207)
		p.Match(ClickHouseParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1208)
		p.TableIdentifier()
	}
	{
		p.SetState(1209)
		p.Match(ClickHouseParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1210)
		p.TableIdentifier()
	}
	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(1211)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1212)
			p.TableIdentifier()
		}
		{
			p.SetState(1213)
			p.Match(ClickHouseParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1214)
			p.TableIdentifier()
		}

		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(1221)
			p.ClusterClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectionSelectStmtContext is an interface to support dynamic dispatch.
type IProjectionSelectStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext
	RPAREN() antlr.TerminalNode
	WithClause() IWithClauseContext
	GroupByClause() IGroupByClauseContext
	ProjectionOrderByClause() IProjectionOrderByClauseContext

	// IsProjectionSelectStmtContext differentiates from other interfaces.
	IsProjectionSelectStmtContext()
}

type ProjectionSelectStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionSelectStmtContext() *ProjectionSelectStmtContext {
	var p = new(ProjectionSelectStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_projectionSelectStmt
	return p
}

func InitEmptyProjectionSelectStmtContext(p *ProjectionSelectStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_projectionSelectStmt
}

func (*ProjectionSelectStmtContext) IsProjectionSelectStmtContext() {}

func NewProjectionSelectStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionSelectStmtContext {
	var p = new(ProjectionSelectStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_projectionSelectStmt

	return p
}

func (s *ProjectionSelectStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionSelectStmtContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ProjectionSelectStmtContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSELECT, 0)
}

func (s *ProjectionSelectStmtContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ProjectionSelectStmtContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ProjectionSelectStmtContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *ProjectionSelectStmtContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *ProjectionSelectStmtContext) ProjectionOrderByClause() IProjectionOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectionOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectionOrderByClauseContext)
}

func (s *ProjectionSelectStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionSelectStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionSelectStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterProjectionSelectStmt(s)
	}
}

func (s *ProjectionSelectStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitProjectionSelectStmt(s)
	}
}

func (p *ClickHouseParser) ProjectionSelectStmt() (localctx IProjectionSelectStmtContext) {
	localctx = NewProjectionSelectStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ClickHouseParserRULE_projectionSelectStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1224)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWITH {
		{
			p.SetState(1225)
			p.WithClause()
		}

	}
	{
		p.SetState(1228)
		p.Match(ClickHouseParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1229)
		p.ColumnExprList()
	}
	p.SetState(1231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserGROUP {
		{
			p.SetState(1230)
			p.GroupByClause()
		}

	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserORDER {
		{
			p.SetState(1233)
			p.ProjectionOrderByClause()
		}

	}
	{
		p.SetState(1236)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectUnionStmtContext is an interface to support dynamic dispatch.
type ISelectUnionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectStmtWithParens() []ISelectStmtWithParensContext
	SelectStmtWithParens(i int) ISelectStmtWithParensContext
	AllUNION() []antlr.TerminalNode
	UNION(i int) antlr.TerminalNode
	AllALL() []antlr.TerminalNode
	ALL(i int) antlr.TerminalNode
	AllDISTINCT() []antlr.TerminalNode
	DISTINCT(i int) antlr.TerminalNode

	// IsSelectUnionStmtContext differentiates from other interfaces.
	IsSelectUnionStmtContext()
}

type SelectUnionStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectUnionStmtContext() *SelectUnionStmtContext {
	var p = new(SelectUnionStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_selectUnionStmt
	return p
}

func InitEmptySelectUnionStmtContext(p *SelectUnionStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_selectUnionStmt
}

func (*SelectUnionStmtContext) IsSelectUnionStmtContext() {}

func NewSelectUnionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectUnionStmtContext {
	var p = new(SelectUnionStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_selectUnionStmt

	return p
}

func (s *SelectUnionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectUnionStmtContext) AllSelectStmtWithParens() []ISelectStmtWithParensContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectStmtWithParensContext); ok {
			len++
		}
	}

	tst := make([]ISelectStmtWithParensContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectStmtWithParensContext); ok {
			tst[i] = t.(ISelectStmtWithParensContext)
			i++
		}
	}

	return tst
}

func (s *SelectUnionStmtContext) SelectStmtWithParens(i int) ISelectStmtWithParensContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStmtWithParensContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStmtWithParensContext)
}

func (s *SelectUnionStmtContext) AllUNION() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserUNION)
}

func (s *SelectUnionStmtContext) UNION(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUNION, i)
}

func (s *SelectUnionStmtContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserALL)
}

func (s *SelectUnionStmtContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, i)
}

func (s *SelectUnionStmtContext) AllDISTINCT() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserDISTINCT)
}

func (s *SelectUnionStmtContext) DISTINCT(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTINCT, i)
}

func (s *SelectUnionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectUnionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectUnionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelectUnionStmt(s)
	}
}

func (s *SelectUnionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelectUnionStmt(s)
	}
}

func (p *ClickHouseParser) SelectUnionStmt() (localctx ISelectUnionStmtContext) {
	localctx = NewSelectUnionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ClickHouseParserRULE_selectUnionStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1238)
		p.SelectStmtWithParens()
	}
	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserUNION {
		{
			p.SetState(1239)
			p.Match(ClickHouseParserUNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1240)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserALL || _la == ClickHouseParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1241)
			p.SelectStmtWithParens()
		}

		p.SetState(1246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStmtWithParensContext is an interface to support dynamic dispatch.
type ISelectStmtWithParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectStmt() ISelectStmtContext
	LPAREN() antlr.TerminalNode
	SelectUnionStmt() ISelectUnionStmtContext
	RPAREN() antlr.TerminalNode

	// IsSelectStmtWithParensContext differentiates from other interfaces.
	IsSelectStmtWithParensContext()
}

type SelectStmtWithParensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStmtWithParensContext() *SelectStmtWithParensContext {
	var p = new(SelectStmtWithParensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_selectStmtWithParens
	return p
}

func InitEmptySelectStmtWithParensContext(p *SelectStmtWithParensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_selectStmtWithParens
}

func (*SelectStmtWithParensContext) IsSelectStmtWithParensContext() {}

func NewSelectStmtWithParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStmtWithParensContext {
	var p = new(SelectStmtWithParensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_selectStmtWithParens

	return p
}

func (s *SelectStmtWithParensContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStmtWithParensContext) SelectStmt() ISelectStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStmtContext)
}

func (s *SelectStmtWithParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *SelectStmtWithParensContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *SelectStmtWithParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *SelectStmtWithParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStmtWithParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStmtWithParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelectStmtWithParens(s)
	}
}

func (s *SelectStmtWithParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelectStmtWithParens(s)
	}
}

func (p *ClickHouseParser) SelectStmtWithParens() (localctx ISelectStmtWithParensContext) {
	localctx = NewSelectStmtWithParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ClickHouseParserRULE_selectStmtWithParens)
	p.SetState(1252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserSELECT, ClickHouseParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1247)
			p.SelectStmt()
		}

	case ClickHouseParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1248)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1249)
			p.SelectUnionStmt()
		}
		{
			p.SetState(1250)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStmtContext is an interface to support dynamic dispatch.
type ISelectStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext
	WithClause() IWithClauseContext
	DISTINCT() antlr.TerminalNode
	TopClause() ITopClauseContext
	FromClause() IFromClauseContext
	ArrayJoinClause() IArrayJoinClauseContext
	WindowClause() IWindowClauseContext
	PrewhereClause() IPrewhereClauseContext
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	TOTALS() antlr.TerminalNode
	HavingClause() IHavingClauseContext
	OrderByClause() IOrderByClauseContext
	InterpolateClause() IInterpolateClauseContext
	LimitByClause() ILimitByClauseContext
	LimitClause() ILimitClauseContext
	SettingsClause() ISettingsClauseContext
	CUBE() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode

	// IsSelectStmtContext differentiates from other interfaces.
	IsSelectStmtContext()
}

type SelectStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStmtContext() *SelectStmtContext {
	var p = new(SelectStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_selectStmt
	return p
}

func InitEmptySelectStmtContext(p *SelectStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_selectStmt
}

func (*SelectStmtContext) IsSelectStmtContext() {}

func NewSelectStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStmtContext {
	var p = new(SelectStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_selectStmt

	return p
}

func (s *SelectStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStmtContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSELECT, 0)
}

func (s *SelectStmtContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *SelectStmtContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *SelectStmtContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTINCT, 0)
}

func (s *SelectStmtContext) TopClause() ITopClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopClauseContext)
}

func (s *SelectStmtContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *SelectStmtContext) ArrayJoinClause() IArrayJoinClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayJoinClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayJoinClauseContext)
}

func (s *SelectStmtContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *SelectStmtContext) PrewhereClause() IPrewhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrewhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrewhereClauseContext)
}

func (s *SelectStmtContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SelectStmtContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *SelectStmtContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserWITH)
}

func (s *SelectStmtContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, i)
}

func (s *SelectStmtContext) TOTALS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTOTALS, 0)
}

func (s *SelectStmtContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *SelectStmtContext) OrderByClause() IOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SelectStmtContext) InterpolateClause() IInterpolateClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterpolateClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterpolateClauseContext)
}

func (s *SelectStmtContext) LimitByClause() ILimitByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitByClauseContext)
}

func (s *SelectStmtContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SelectStmtContext) SettingsClause() ISettingsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingsClauseContext)
}

func (s *SelectStmtContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCUBE, 0)
}

func (s *SelectStmtContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLLUP, 0)
}

func (s *SelectStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSelectStmt(s)
	}
}

func (s *SelectStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSelectStmt(s)
	}
}

func (p *ClickHouseParser) SelectStmt() (localctx ISelectStmtContext) {
	localctx = NewSelectStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ClickHouseParserRULE_selectStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWITH {
		{
			p.SetState(1254)
			p.WithClause()
		}

	}
	{
		p.SetState(1257)
		p.Match(ClickHouseParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1259)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1258)
			p.Match(ClickHouseParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1261)
			p.TopClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1264)
		p.ColumnExprList()
	}
	p.SetState(1266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserFROM {
		{
			p.SetState(1265)
			p.FromClause()
		}

	}
	p.SetState(1269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserARRAY || _la == ClickHouseParserINNER || _la == ClickHouseParserLEFT {
		{
			p.SetState(1268)
			p.ArrayJoinClause()
		}

	}
	p.SetState(1272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWINDOW {
		{
			p.SetState(1271)
			p.WindowClause()
		}

	}
	p.SetState(1275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserPREWHERE {
		{
			p.SetState(1274)
			p.PrewhereClause()
		}

	}
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWHERE {
		{
			p.SetState(1277)
			p.WhereClause()
		}

	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserGROUP {
		{
			p.SetState(1280)
			p.GroupByClause()
		}

	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1283)
			p.Match(ClickHouseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1284)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserCUBE || _la == ClickHouseParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWITH {
		{
			p.SetState(1287)
			p.Match(ClickHouseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1288)
			p.Match(ClickHouseParserTOTALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserHAVING {
		{
			p.SetState(1291)
			p.HavingClause()
		}

	}
	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserORDER {
		{
			p.SetState(1294)
			p.OrderByClause()
		}

	}
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserINTERPOLATE {
		{
			p.SetState(1297)
			p.InterpolateClause()
		}

	}
	p.SetState(1301)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1300)
			p.LimitByClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserLIMIT {
		{
			p.SetState(1303)
			p.LimitClause()
		}

	}
	p.SetState(1307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserSETTINGS {
		{
			p.SetState(1306)
			p.SettingsClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	WithExprList() IWithExprListContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *WithClauseContext) WithExprList() IWithExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithExprListContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (p *ClickHouseParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ClickHouseParserRULE_withClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1309)
		p.Match(ClickHouseParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1310)
		p.WithExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithExprListContext is an interface to support dynamic dispatch.
type IWithExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWithExpr() []IWithExprContext
	WithExpr(i int) IWithExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWithExprListContext differentiates from other interfaces.
	IsWithExprListContext()
}

type WithExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithExprListContext() *WithExprListContext {
	var p = new(WithExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_withExprList
	return p
}

func InitEmptyWithExprListContext(p *WithExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_withExprList
}

func (*WithExprListContext) IsWithExprListContext() {}

func NewWithExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithExprListContext {
	var p = new(WithExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_withExprList

	return p
}

func (s *WithExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *WithExprListContext) AllWithExpr() []IWithExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWithExprContext); ok {
			len++
		}
	}

	tst := make([]IWithExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWithExprContext); ok {
			tst[i] = t.(IWithExprContext)
			i++
		}
	}

	return tst
}

func (s *WithExprListContext) WithExpr(i int) IWithExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithExprContext)
}

func (s *WithExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *WithExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *WithExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWithExprList(s)
	}
}

func (s *WithExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWithExprList(s)
	}
}

func (p *ClickHouseParser) WithExprList() (localctx IWithExprListContext) {
	localctx = NewWithExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ClickHouseParserRULE_withExprList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1312)
		p.WithExpr()
	}
	p.SetState(1317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(1313)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1314)
			p.WithExpr()
		}

		p.SetState(1319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithExprContext is an interface to support dynamic dispatch.
type IWithExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWithExprContext differentiates from other interfaces.
	IsWithExprContext()
}

type WithExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithExprContext() *WithExprContext {
	var p = new(WithExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_withExpr
	return p
}

func InitEmptyWithExprContext(p *WithExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_withExpr
}

func (*WithExprContext) IsWithExprContext() {}

func NewWithExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithExprContext {
	var p = new(WithExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_withExpr

	return p
}

func (s *WithExprContext) GetParser() antlr.Parser { return s.parser }

func (s *WithExprContext) CopyAll(ctx *WithExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *WithExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type WithExprExpressionContext struct {
	WithExprContext
}

func NewWithExprExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WithExprExpressionContext {
	var p = new(WithExprExpressionContext)

	InitEmptyWithExprContext(&p.WithExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*WithExprContext))

	return p
}

func (s *WithExprExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithExprExpressionContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *WithExprExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *WithExprExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WithExprExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWithExprExpression(s)
	}
}

func (s *WithExprExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWithExprExpression(s)
	}
}

type WithExprSubqueryContext struct {
	WithExprContext
}

func NewWithExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WithExprSubqueryContext {
	var p = new(WithExprSubqueryContext)

	InitEmptyWithExprContext(&p.WithExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*WithExprContext))

	return p
}

func (s *WithExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithExprSubqueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WithExprSubqueryContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *WithExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *WithExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *WithExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *WithExprSubqueryContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRECURSIVE, 0)
}

func (s *WithExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWithExprSubquery(s)
	}
}

func (s *WithExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWithExprSubquery(s)
	}
}

func (p *ClickHouseParser) WithExpr() (localctx IWithExprContext) {
	localctx = NewWithExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ClickHouseParserRULE_withExpr)
	p.SetState(1333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) {
	case 1:
		localctx = NewWithExprSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1321)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1320)
				p.Match(ClickHouseParserRECURSIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1323)
			p.Identifier()
		}
		{
			p.SetState(1324)
			p.Match(ClickHouseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1325)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1326)
			p.SelectUnionStmt()
		}
		{
			p.SetState(1327)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewWithExprExpressionContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1329)
			p.columnExpr(0)
		}
		{
			p.SetState(1330)
			p.Match(ClickHouseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1331)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopClauseContext is an interface to support dynamic dispatch.
type ITopClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TOP() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	TIES() antlr.TerminalNode

	// IsTopClauseContext differentiates from other interfaces.
	IsTopClauseContext()
}

type TopClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopClauseContext() *TopClauseContext {
	var p = new(TopClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_topClause
	return p
}

func InitEmptyTopClauseContext(p *TopClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_topClause
}

func (*TopClauseContext) IsTopClauseContext() {}

func NewTopClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopClauseContext {
	var p = new(TopClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_topClause

	return p
}

func (s *TopClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TopClauseContext) TOP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTOP, 0)
}

func (s *TopClauseContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *TopClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *TopClauseContext) TIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIES, 0)
}

func (s *TopClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTopClause(s)
	}
}

func (s *TopClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTopClause(s)
	}
}

func (p *ClickHouseParser) TopClause() (localctx ITopClauseContext) {
	localctx = NewTopClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ClickHouseParserRULE_topClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1335)
		p.Match(ClickHouseParserTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1336)
		p.Match(ClickHouseParserDECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1339)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1337)
			p.Match(ClickHouseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1338)
			p.Match(ClickHouseParserTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	JoinExpr() IJoinExprContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *FromClauseContext) JoinExpr() IJoinExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (p *ClickHouseParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ClickHouseParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1341)
		p.Match(ClickHouseParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1342)
		p.joinExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayJoinClauseContext is an interface to support dynamic dispatch.
type IArrayJoinClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext
	LEFT() antlr.TerminalNode
	INNER() antlr.TerminalNode

	// IsArrayJoinClauseContext differentiates from other interfaces.
	IsArrayJoinClauseContext()
}

type ArrayJoinClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayJoinClauseContext() *ArrayJoinClauseContext {
	var p = new(ArrayJoinClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_arrayJoinClause
	return p
}

func InitEmptyArrayJoinClauseContext(p *ArrayJoinClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_arrayJoinClause
}

func (*ArrayJoinClauseContext) IsArrayJoinClauseContext() {}

func NewArrayJoinClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayJoinClauseContext {
	var p = new(ArrayJoinClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_arrayJoinClause

	return p
}

func (s *ArrayJoinClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayJoinClauseContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserARRAY, 0)
}

func (s *ArrayJoinClauseContext) JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJOIN, 0)
}

func (s *ArrayJoinClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ArrayJoinClauseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEFT, 0)
}

func (s *ArrayJoinClauseContext) INNER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINNER, 0)
}

func (s *ArrayJoinClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayJoinClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayJoinClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterArrayJoinClause(s)
	}
}

func (s *ArrayJoinClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitArrayJoinClause(s)
	}
}

func (p *ClickHouseParser) ArrayJoinClause() (localctx IArrayJoinClauseContext) {
	localctx = NewArrayJoinClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ClickHouseParserRULE_arrayJoinClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserINNER || _la == ClickHouseParserLEFT {
		{
			p.SetState(1344)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserINNER || _la == ClickHouseParserLEFT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1347)
		p.Match(ClickHouseParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1348)
		p.Match(ClickHouseParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1349)
		p.ColumnExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW() antlr.TerminalNode
	Identifier() IIdentifierContext
	AS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	WindowExpr() IWindowExprContext
	RPAREN() antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWINDOW, 0)
}

func (s *WindowClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WindowClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *WindowClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *WindowClauseContext) WindowExpr() IWindowExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowExprContext)
}

func (s *WindowClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (p *ClickHouseParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ClickHouseParserRULE_windowClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1351)
		p.Match(ClickHouseParserWINDOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1352)
		p.Identifier()
	}
	{
		p.SetState(1353)
		p.Match(ClickHouseParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1354)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1355)
		p.WindowExpr()
	}
	{
		p.SetState(1356)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrewhereClauseContext is an interface to support dynamic dispatch.
type IPrewhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREWHERE() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsPrewhereClauseContext differentiates from other interfaces.
	IsPrewhereClauseContext()
}

type PrewhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrewhereClauseContext() *PrewhereClauseContext {
	var p = new(PrewhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_prewhereClause
	return p
}

func InitEmptyPrewhereClauseContext(p *PrewhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_prewhereClause
}

func (*PrewhereClauseContext) IsPrewhereClauseContext() {}

func NewPrewhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrewhereClauseContext {
	var p = new(PrewhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_prewhereClause

	return p
}

func (s *PrewhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrewhereClauseContext) PREWHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPREWHERE, 0)
}

func (s *PrewhereClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *PrewhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrewhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrewhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterPrewhereClause(s)
	}
}

func (s *PrewhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitPrewhereClause(s)
	}
}

func (p *ClickHouseParser) PrewhereClause() (localctx IPrewhereClauseContext) {
	localctx = NewPrewhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ClickHouseParserRULE_prewhereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1358)
		p.Match(ClickHouseParserPREWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1359)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *WhereClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (p *ClickHouseParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ClickHouseParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1361)
		p.Match(ClickHouseParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1362)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) CopyAll(ctx *GroupByClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GroupByClauseAllContext struct {
	GroupByClauseContext
}

func NewGroupByClauseAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupByClauseAllContext {
	var p = new(GroupByClauseAllContext)

	InitEmptyGroupByClauseContext(&p.GroupByClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupByClauseContext))

	return p
}

func (s *GroupByClauseAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseAllContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGROUP, 0)
}

func (s *GroupByClauseAllContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *GroupByClauseAllContext) ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, 0)
}

func (s *GroupByClauseAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterGroupByClauseAll(s)
	}
}

func (s *GroupByClauseAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitGroupByClauseAll(s)
	}
}

type GroupByClauseSimpleContext struct {
	GroupByClauseContext
}

func NewGroupByClauseSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupByClauseSimpleContext {
	var p = new(GroupByClauseSimpleContext)

	InitEmptyGroupByClauseContext(&p.GroupByClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupByClauseContext))

	return p
}

func (s *GroupByClauseSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseSimpleContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGROUP, 0)
}

func (s *GroupByClauseSimpleContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *GroupByClauseSimpleContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *GroupByClauseSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterGroupByClauseSimple(s)
	}
}

func (s *GroupByClauseSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitGroupByClauseSimple(s)
	}
}

type GroupByClauseGroupingSetsContext struct {
	GroupByClauseContext
}

func NewGroupByClauseGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupByClauseGroupingSetsContext {
	var p = new(GroupByClauseGroupingSetsContext)

	InitEmptyGroupByClauseContext(&p.GroupByClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupByClauseContext))

	return p
}

func (s *GroupByClauseGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseGroupingSetsContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGROUP, 0)
}

func (s *GroupByClauseGroupingSetsContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *GroupByClauseGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGROUPING, 0)
}

func (s *GroupByClauseGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETS, 0)
}

func (s *GroupByClauseGroupingSetsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *GroupByClauseGroupingSetsContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *GroupByClauseGroupingSetsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *GroupByClauseGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterGroupByClauseGroupingSets(s)
	}
}

func (s *GroupByClauseGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitGroupByClauseGroupingSets(s)
	}
}

type GroupByClauseCubeOrRollupContext struct {
	GroupByClauseContext
}

func NewGroupByClauseCubeOrRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupByClauseCubeOrRollupContext {
	var p = new(GroupByClauseCubeOrRollupContext)

	InitEmptyGroupByClauseContext(&p.GroupByClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupByClauseContext))

	return p
}

func (s *GroupByClauseCubeOrRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseCubeOrRollupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGROUP, 0)
}

func (s *GroupByClauseCubeOrRollupContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *GroupByClauseCubeOrRollupContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *GroupByClauseCubeOrRollupContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *GroupByClauseCubeOrRollupContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *GroupByClauseCubeOrRollupContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCUBE, 0)
}

func (s *GroupByClauseCubeOrRollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLLUP, 0)
}

func (s *GroupByClauseCubeOrRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterGroupByClauseCubeOrRollup(s)
	}
}

func (s *GroupByClauseCubeOrRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitGroupByClauseCubeOrRollup(s)
	}
}

func (p *ClickHouseParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ClickHouseParserRULE_groupByClause)
	var _la int

	p.SetState(1385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGroupByClauseAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1364)
			p.Match(ClickHouseParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1365)
			p.Match(ClickHouseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1366)
			p.Match(ClickHouseParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewGroupByClauseCubeOrRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1367)
			p.Match(ClickHouseParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1368)
			p.Match(ClickHouseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1369)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserCUBE || _la == ClickHouseParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1370)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1371)
			p.ColumnExprList()
		}
		{
			p.SetState(1372)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewGroupByClauseGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1374)
			p.Match(ClickHouseParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1375)
			p.Match(ClickHouseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1376)
			p.Match(ClickHouseParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1377)
			p.Match(ClickHouseParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1378)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1379)
			p.ColumnExprList()
		}
		{
			p.SetState(1380)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewGroupByClauseSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1382)
			p.Match(ClickHouseParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1383)
			p.Match(ClickHouseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1384)
			p.ColumnExprList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	ColumnExpr() IColumnExprContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHAVING, 0)
}

func (s *HavingClauseContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (p *ClickHouseParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ClickHouseParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1387)
		p.Match(ClickHouseParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1388)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	OrderExprList() IOrderExprListContext

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_orderByClause
	return p
}

func InitEmptyOrderByClauseContext(p *OrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_orderByClause
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *OrderByClauseContext) OrderExprList() IOrderExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderExprListContext)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (p *ClickHouseParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ClickHouseParserRULE_orderByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1390)
		p.Match(ClickHouseParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1391)
		p.Match(ClickHouseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1392)
		p.OrderExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterpolateClauseContext is an interface to support dynamic dispatch.
type IInterpolateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERPOLATE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext
	RPAREN() antlr.TerminalNode

	// IsInterpolateClauseContext differentiates from other interfaces.
	IsInterpolateClauseContext()
}

type InterpolateClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterpolateClauseContext() *InterpolateClauseContext {
	var p = new(InterpolateClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_interpolateClause
	return p
}

func InitEmptyInterpolateClauseContext(p *InterpolateClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_interpolateClause
}

func (*InterpolateClauseContext) IsInterpolateClauseContext() {}

func NewInterpolateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolateClauseContext {
	var p = new(InterpolateClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_interpolateClause

	return p
}

func (s *InterpolateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolateClauseContext) INTERPOLATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTERPOLATE, 0)
}

func (s *InterpolateClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *InterpolateClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *InterpolateClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *InterpolateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterInterpolateClause(s)
	}
}

func (s *InterpolateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitInterpolateClause(s)
	}
}

func (p *ClickHouseParser) InterpolateClause() (localctx IInterpolateClauseContext) {
	localctx = NewInterpolateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ClickHouseParserRULE_interpolateClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1394)
		p.Match(ClickHouseParserINTERPOLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1395)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1396)
		p.ColumnExprList()
	}
	{
		p.SetState(1397)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectionOrderByClauseContext is an interface to support dynamic dispatch.
type IProjectionOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext

	// IsProjectionOrderByClauseContext differentiates from other interfaces.
	IsProjectionOrderByClauseContext()
}

type ProjectionOrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionOrderByClauseContext() *ProjectionOrderByClauseContext {
	var p = new(ProjectionOrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_projectionOrderByClause
	return p
}

func InitEmptyProjectionOrderByClauseContext(p *ProjectionOrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_projectionOrderByClause
}

func (*ProjectionOrderByClauseContext) IsProjectionOrderByClauseContext() {}

func NewProjectionOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionOrderByClauseContext {
	var p = new(ProjectionOrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_projectionOrderByClause

	return p
}

func (s *ProjectionOrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionOrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserORDER, 0)
}

func (s *ProjectionOrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *ProjectionOrderByClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ProjectionOrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionOrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionOrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterProjectionOrderByClause(s)
	}
}

func (s *ProjectionOrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitProjectionOrderByClause(s)
	}
}

func (p *ClickHouseParser) ProjectionOrderByClause() (localctx IProjectionOrderByClauseContext) {
	localctx = NewProjectionOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ClickHouseParserRULE_projectionOrderByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1399)
		p.Match(ClickHouseParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1400)
		p.Match(ClickHouseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1401)
		p.ColumnExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitByClauseContext is an interface to support dynamic dispatch.
type ILimitByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	LimitExpr() ILimitExprContext
	BY() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext

	// IsLimitByClauseContext differentiates from other interfaces.
	IsLimitByClauseContext()
}

type LimitByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitByClauseContext() *LimitByClauseContext {
	var p = new(LimitByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_limitByClause
	return p
}

func InitEmptyLimitByClauseContext(p *LimitByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_limitByClause
}

func (*LimitByClauseContext) IsLimitByClauseContext() {}

func NewLimitByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitByClauseContext {
	var p = new(LimitByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_limitByClause

	return p
}

func (s *LimitByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitByClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *LimitByClauseContext) LimitExpr() ILimitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitExprContext)
}

func (s *LimitByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *LimitByClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *LimitByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLimitByClause(s)
	}
}

func (s *LimitByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLimitByClause(s)
	}
}

func (p *ClickHouseParser) LimitByClause() (localctx ILimitByClauseContext) {
	localctx = NewLimitByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ClickHouseParserRULE_limitByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1403)
		p.Match(ClickHouseParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1404)
		p.LimitExpr()
	}
	{
		p.SetState(1405)
		p.Match(ClickHouseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1406)
		p.ColumnExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	LimitExpr() ILimitExprContext
	WITH() antlr.TerminalNode
	TIES() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *LimitClauseContext) LimitExpr() ILimitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitExprContext)
}

func (s *LimitClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *LimitClauseContext) TIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIES, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *ClickHouseParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ClickHouseParserRULE_limitClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1408)
		p.Match(ClickHouseParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1409)
		p.LimitExpr()
	}
	p.SetState(1412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserWITH {
		{
			p.SetState(1410)
			p.Match(ClickHouseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1411)
			p.Match(ClickHouseParserTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISettingsClauseContext is an interface to support dynamic dispatch.
type ISettingsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SETTINGS() antlr.TerminalNode
	SettingExprList() ISettingExprListContext

	// IsSettingsClauseContext differentiates from other interfaces.
	IsSettingsClauseContext()
}

type SettingsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettingsClauseContext() *SettingsClauseContext {
	var p = new(SettingsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settingsClause
	return p
}

func InitEmptySettingsClauseContext(p *SettingsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settingsClause
}

func (*SettingsClauseContext) IsSettingsClauseContext() {}

func NewSettingsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SettingsClauseContext {
	var p = new(SettingsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_settingsClause

	return p
}

func (s *SettingsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SettingsClauseContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTINGS, 0)
}

func (s *SettingsClauseContext) SettingExprList() ISettingExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingExprListContext)
}

func (s *SettingsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SettingsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SettingsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSettingsClause(s)
	}
}

func (s *SettingsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSettingsClause(s)
	}
}

func (p *ClickHouseParser) SettingsClause() (localctx ISettingsClauseContext) {
	localctx = NewSettingsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ClickHouseParserRULE_settingsClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1414)
		p.Match(ClickHouseParserSETTINGS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1415)
		p.SettingExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinExprContext is an interface to support dynamic dispatch.
type IJoinExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinExprContext differentiates from other interfaces.
	IsJoinExprContext()
}

type JoinExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinExprContext() *JoinExprContext {
	var p = new(JoinExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinExpr
	return p
}

func InitEmptyJoinExprContext(p *JoinExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinExpr
}

func (*JoinExprContext) IsJoinExprContext() {}

func NewJoinExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinExprContext {
	var p = new(JoinExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_joinExpr

	return p
}

func (s *JoinExprContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinExprContext) CopyAll(ctx *JoinExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *JoinExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type JoinExprOpContext struct {
	JoinExprContext
}

func NewJoinExprOpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprOpContext {
	var p = new(JoinExprOpContext)

	InitEmptyJoinExprContext(&p.JoinExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprOpContext) AllJoinExpr() []IJoinExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinExprContext); ok {
			len++
		}
	}

	tst := make([]IJoinExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinExprContext); ok {
			tst[i] = t.(IJoinExprContext)
			i++
		}
	}

	return tst
}

func (s *JoinExprOpContext) JoinExpr(i int) IJoinExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *JoinExprOpContext) JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJOIN, 0)
}

func (s *JoinExprOpContext) JoinConstraintClause() IJoinConstraintClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinConstraintClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinConstraintClauseContext)
}

func (s *JoinExprOpContext) JoinOp() IJoinOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinOpContext)
}

func (s *JoinExprOpContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGLOBAL, 0)
}

func (s *JoinExprOpContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOCAL, 0)
}

func (s *JoinExprOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinExprOp(s)
	}
}

func (s *JoinExprOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinExprOp(s)
	}
}

type JoinExprTableContext struct {
	JoinExprContext
}

func NewJoinExprTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprTableContext {
	var p = new(JoinExprTableContext)

	InitEmptyJoinExprContext(&p.JoinExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprTableContext) TableExpr() ITableExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableExprContext)
}

func (s *JoinExprTableContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFINAL, 0)
}

func (s *JoinExprTableContext) SampleClause() ISampleClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleClauseContext)
}

func (s *JoinExprTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinExprTable(s)
	}
}

func (s *JoinExprTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinExprTable(s)
	}
}

type JoinExprParensContext struct {
	JoinExprContext
}

func NewJoinExprParensContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprParensContext {
	var p = new(JoinExprParensContext)

	InitEmptyJoinExprContext(&p.JoinExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *JoinExprParensContext) JoinExpr() IJoinExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *JoinExprParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *JoinExprParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinExprParens(s)
	}
}

func (s *JoinExprParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinExprParens(s)
	}
}

type JoinExprCrossOpContext struct {
	JoinExprContext
}

func NewJoinExprCrossOpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinExprCrossOpContext {
	var p = new(JoinExprCrossOpContext)

	InitEmptyJoinExprContext(&p.JoinExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinExprContext))

	return p
}

func (s *JoinExprCrossOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinExprCrossOpContext) AllJoinExpr() []IJoinExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinExprContext); ok {
			len++
		}
	}

	tst := make([]IJoinExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinExprContext); ok {
			tst[i] = t.(IJoinExprContext)
			i++
		}
	}

	return tst
}

func (s *JoinExprCrossOpContext) JoinExpr(i int) IJoinExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinExprContext)
}

func (s *JoinExprCrossOpContext) JoinOpCross() IJoinOpCrossContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinOpCrossContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinOpCrossContext)
}

func (s *JoinExprCrossOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinExprCrossOp(s)
	}
}

func (s *JoinExprCrossOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinExprCrossOp(s)
	}
}

func (p *ClickHouseParser) JoinExpr() (localctx IJoinExprContext) {
	return p.joinExpr(0)
}

func (p *ClickHouseParser) joinExpr(_p int) (localctx IJoinExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewJoinExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IJoinExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 148
	p.EnterRecursionRule(localctx, 148, ClickHouseParserRULE_joinExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinExprTableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1418)
			p.tableExpr(0)
		}
		p.SetState(1420)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1419)
				p.Match(ClickHouseParserFINAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1422)
				p.SampleClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewJoinExprParensContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1425)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1426)
			p.joinExpr(0)
		}
		{
			p.SetState(1427)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1446)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) {
			case 1:
				localctx = NewJoinExprCrossOpContext(p, NewJoinExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_joinExpr)
				p.SetState(1431)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(1432)
					p.JoinOpCross()
				}
				{
					p.SetState(1433)
					p.joinExpr(4)
				}

			case 2:
				localctx = NewJoinExprOpContext(p, NewJoinExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_joinExpr)
				p.SetState(1435)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				p.SetState(1437)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == ClickHouseParserGLOBAL || _la == ClickHouseParserLOCAL {
					{
						p.SetState(1436)
						_la = p.GetTokenStream().LA(1)

						if !(_la == ClickHouseParserGLOBAL || _la == ClickHouseParserLOCAL) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				p.SetState(1440)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8992) != 0) || ((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&34361835521) != 0) || _la == ClickHouseParserRIGHT || _la == ClickHouseParserSEMI {
					{
						p.SetState(1439)
						p.JoinOp()
					}

				}
				{
					p.SetState(1442)
					p.Match(ClickHouseParserJOIN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1443)
					p.joinExpr(0)
				}
				{
					p.SetState(1444)
					p.JoinConstraintClause()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinOpContext is an interface to support dynamic dispatch.
type IJoinOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinOpContext differentiates from other interfaces.
	IsJoinOpContext()
}

type JoinOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinOpContext() *JoinOpContext {
	var p = new(JoinOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinOp
	return p
}

func InitEmptyJoinOpContext(p *JoinOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinOp
}

func (*JoinOpContext) IsJoinOpContext() {}

func NewJoinOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinOpContext {
	var p = new(JoinOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_joinOp

	return p
}

func (s *JoinOpContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinOpContext) CopyAll(ctx *JoinOpContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *JoinOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type JoinOpFullContext struct {
	JoinOpContext
}

func NewJoinOpFullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinOpFullContext {
	var p = new(JoinOpFullContext)

	InitEmptyJoinOpContext(&p.JoinOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinOpContext))

	return p
}

func (s *JoinOpFullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpFullContext) FULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFULL, 0)
}

func (s *JoinOpFullContext) OUTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTER, 0)
}

func (s *JoinOpFullContext) ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, 0)
}

func (s *JoinOpFullContext) ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANY, 0)
}

func (s *JoinOpFullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinOpFull(s)
	}
}

func (s *JoinOpFullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinOpFull(s)
	}
}

type JoinOpInnerContext struct {
	JoinOpContext
}

func NewJoinOpInnerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinOpInnerContext {
	var p = new(JoinOpInnerContext)

	InitEmptyJoinOpContext(&p.JoinOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinOpContext))

	return p
}

func (s *JoinOpInnerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpInnerContext) INNER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINNER, 0)
}

func (s *JoinOpInnerContext) ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, 0)
}

func (s *JoinOpInnerContext) ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANY, 0)
}

func (s *JoinOpInnerContext) ASOF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASOF, 0)
}

func (s *JoinOpInnerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinOpInner(s)
	}
}

func (s *JoinOpInnerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinOpInner(s)
	}
}

type JoinOpLeftRightContext struct {
	JoinOpContext
}

func NewJoinOpLeftRightContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinOpLeftRightContext {
	var p = new(JoinOpLeftRightContext)

	InitEmptyJoinOpContext(&p.JoinOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinOpContext))

	return p
}

func (s *JoinOpLeftRightContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpLeftRightContext) LEFT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEFT, 0)
}

func (s *JoinOpLeftRightContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRIGHT, 0)
}

func (s *JoinOpLeftRightContext) OUTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTER, 0)
}

func (s *JoinOpLeftRightContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSEMI, 0)
}

func (s *JoinOpLeftRightContext) ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, 0)
}

func (s *JoinOpLeftRightContext) ANTI() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANTI, 0)
}

func (s *JoinOpLeftRightContext) ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANY, 0)
}

func (s *JoinOpLeftRightContext) ASOF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASOF, 0)
}

func (s *JoinOpLeftRightContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinOpLeftRight(s)
	}
}

func (s *JoinOpLeftRightContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinOpLeftRight(s)
	}
}

func (p *ClickHouseParser) JoinOp() (localctx IJoinOpContext) {
	localctx = NewJoinOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ClickHouseParserRULE_joinOp)
	var _la int

	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinOpInnerContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1452)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8736) != 0 {
				{
					p.SetState(1451)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8736) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1454)
				p.Match(ClickHouseParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(1455)
				p.Match(ClickHouseParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1457)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8736) != 0 {
				{
					p.SetState(1456)
					_la = p.GetTokenStream().LA(1)

					if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8736) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		case 3:
			{
				p.SetState(1459)
				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8736) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		localctx = NewJoinOpLeftRightContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1476)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1463)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8992) != 0) || _la == ClickHouseParserSEMI {
				{
					p.SetState(1462)
					_la = p.GetTokenStream().LA(1)

					if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8992) != 0) || _la == ClickHouseParserSEMI) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1465)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserLEFT || _la == ClickHouseParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(1467)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOUTER {
				{
					p.SetState(1466)
					p.Match(ClickHouseParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case 2:
			{
				p.SetState(1469)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserLEFT || _la == ClickHouseParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(1471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOUTER {
				{
					p.SetState(1470)
					p.Match(ClickHouseParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1474)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8992) != 0) || _la == ClickHouseParserSEMI {
				{
					p.SetState(1473)
					_la = p.GetTokenStream().LA(1)

					if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8992) != 0) || _la == ClickHouseParserSEMI) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 3:
		localctx = NewJoinOpFullContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1479)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserALL || _la == ClickHouseParserANY {
				{
					p.SetState(1478)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ClickHouseParserALL || _la == ClickHouseParserANY) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(1481)
				p.Match(ClickHouseParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1483)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOUTER {
				{
					p.SetState(1482)
					p.Match(ClickHouseParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case 2:
			{
				p.SetState(1485)
				p.Match(ClickHouseParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1487)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserOUTER {
				{
					p.SetState(1486)
					p.Match(ClickHouseParserOUTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1490)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserALL || _la == ClickHouseParserANY {
				{
					p.SetState(1489)
					_la = p.GetTokenStream().LA(1)

					if !(_la == ClickHouseParserALL || _la == ClickHouseParserANY) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinOpCrossContext is an interface to support dynamic dispatch.
type IJoinOpCrossContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CROSS() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsJoinOpCrossContext differentiates from other interfaces.
	IsJoinOpCrossContext()
}

type JoinOpCrossContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinOpCrossContext() *JoinOpCrossContext {
	var p = new(JoinOpCrossContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinOpCross
	return p
}

func InitEmptyJoinOpCrossContext(p *JoinOpCrossContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinOpCross
}

func (*JoinOpCrossContext) IsJoinOpCrossContext() {}

func NewJoinOpCrossContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinOpCrossContext {
	var p = new(JoinOpCrossContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_joinOpCross

	return p
}

func (s *JoinOpCrossContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinOpCrossContext) CROSS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCROSS, 0)
}

func (s *JoinOpCrossContext) JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJOIN, 0)
}

func (s *JoinOpCrossContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGLOBAL, 0)
}

func (s *JoinOpCrossContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOCAL, 0)
}

func (s *JoinOpCrossContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, 0)
}

func (s *JoinOpCrossContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOpCrossContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinOpCrossContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinOpCross(s)
	}
}

func (s *JoinOpCrossContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinOpCross(s)
	}
}

func (p *ClickHouseParser) JoinOpCross() (localctx IJoinOpCrossContext) {
	localctx = NewJoinOpCrossContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ClickHouseParserRULE_joinOpCross)
	var _la int

	p.SetState(1502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserCROSS, ClickHouseParserGLOBAL, ClickHouseParserLOCAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserGLOBAL || _la == ClickHouseParserLOCAL {
			{
				p.SetState(1496)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserGLOBAL || _la == ClickHouseParserLOCAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1499)
			p.Match(ClickHouseParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1500)
			p.Match(ClickHouseParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ClickHouseParserCOMMA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1501)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinConstraintClauseContext is an interface to support dynamic dispatch.
type IJoinConstraintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext
	USING() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsJoinConstraintClauseContext differentiates from other interfaces.
	IsJoinConstraintClauseContext()
}

type JoinConstraintClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinConstraintClauseContext() *JoinConstraintClauseContext {
	var p = new(JoinConstraintClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinConstraintClause
	return p
}

func InitEmptyJoinConstraintClauseContext(p *JoinConstraintClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_joinConstraintClause
}

func (*JoinConstraintClauseContext) IsJoinConstraintClauseContext() {}

func NewJoinConstraintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinConstraintClauseContext {
	var p = new(JoinConstraintClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_joinConstraintClause

	return p
}

func (s *JoinConstraintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinConstraintClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserON, 0)
}

func (s *JoinConstraintClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *JoinConstraintClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSING, 0)
}

func (s *JoinConstraintClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *JoinConstraintClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *JoinConstraintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinConstraintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinConstraintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterJoinConstraintClause(s)
	}
}

func (s *JoinConstraintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitJoinConstraintClause(s)
	}
}

func (p *ClickHouseParser) JoinConstraintClause() (localctx IJoinConstraintClauseContext) {
	localctx = NewJoinConstraintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ClickHouseParserRULE_joinConstraintClause)
	p.SetState(1513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1504)
			p.Match(ClickHouseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1505)
			p.ColumnExprList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1506)
			p.Match(ClickHouseParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1507)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1508)
			p.ColumnExprList()
		}
		{
			p.SetState(1509)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1511)
			p.Match(ClickHouseParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1512)
			p.ColumnExprList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleClauseContext is an interface to support dynamic dispatch.
type ISampleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	AllRatioExpr() []IRatioExprContext
	RatioExpr(i int) IRatioExprContext
	OFFSET() antlr.TerminalNode

	// IsSampleClauseContext differentiates from other interfaces.
	IsSampleClauseContext()
}

type SampleClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleClauseContext() *SampleClauseContext {
	var p = new(SampleClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sampleClause
	return p
}

func InitEmptySampleClauseContext(p *SampleClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_sampleClause
}

func (*SampleClauseContext) IsSampleClauseContext() {}

func NewSampleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleClauseContext {
	var p = new(SampleClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_sampleClause

	return p
}

func (s *SampleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSAMPLE, 0)
}

func (s *SampleClauseContext) AllRatioExpr() []IRatioExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRatioExprContext); ok {
			len++
		}
	}

	tst := make([]IRatioExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRatioExprContext); ok {
			tst[i] = t.(IRatioExprContext)
			i++
		}
	}

	return tst
}

func (s *SampleClauseContext) RatioExpr(i int) IRatioExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRatioExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRatioExprContext)
}

func (s *SampleClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOFFSET, 0)
}

func (s *SampleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSampleClause(s)
	}
}

func (s *SampleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSampleClause(s)
	}
}

func (p *ClickHouseParser) SampleClause() (localctx ISampleClauseContext) {
	localctx = NewSampleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ClickHouseParserRULE_sampleClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1515)
		p.Match(ClickHouseParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1516)
		p.RatioExpr()
	}
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1517)
			p.Match(ClickHouseParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1518)
			p.RatioExpr()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitExprContext is an interface to support dynamic dispatch.
type ILimitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnExpr() []IColumnExprContext
	ColumnExpr(i int) IColumnExprContext
	COMMA() antlr.TerminalNode
	OFFSET() antlr.TerminalNode

	// IsLimitExprContext differentiates from other interfaces.
	IsLimitExprContext()
}

type LimitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitExprContext() *LimitExprContext {
	var p = new(LimitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_limitExpr
	return p
}

func InitEmptyLimitExprContext(p *LimitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_limitExpr
}

func (*LimitExprContext) IsLimitExprContext() {}

func NewLimitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitExprContext {
	var p = new(LimitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_limitExpr

	return p
}

func (s *LimitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitExprContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *LimitExprContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *LimitExprContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, 0)
}

func (s *LimitExprContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOFFSET, 0)
}

func (s *LimitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLimitExpr(s)
	}
}

func (s *LimitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLimitExpr(s)
	}
}

func (p *ClickHouseParser) LimitExpr() (localctx ILimitExprContext) {
	localctx = NewLimitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ClickHouseParserRULE_limitExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.columnExpr(0)
	}
	p.SetState(1524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserOFFSET || _la == ClickHouseParserCOMMA {
		{
			p.SetState(1522)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserOFFSET || _la == ClickHouseParserCOMMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1523)
			p.columnExpr(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderExprListContext is an interface to support dynamic dispatch.
type IOrderExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOrderExpr() []IOrderExprContext
	OrderExpr(i int) IOrderExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsOrderExprListContext differentiates from other interfaces.
	IsOrderExprListContext()
}

type OrderExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderExprListContext() *OrderExprListContext {
	var p = new(OrderExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_orderExprList
	return p
}

func InitEmptyOrderExprListContext(p *OrderExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_orderExprList
}

func (*OrderExprListContext) IsOrderExprListContext() {}

func NewOrderExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderExprListContext {
	var p = new(OrderExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_orderExprList

	return p
}

func (s *OrderExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderExprListContext) AllOrderExpr() []IOrderExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderExprContext); ok {
			len++
		}
	}

	tst := make([]IOrderExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderExprContext); ok {
			tst[i] = t.(IOrderExprContext)
			i++
		}
	}

	return tst
}

func (s *OrderExprListContext) OrderExpr(i int) IOrderExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderExprContext)
}

func (s *OrderExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *OrderExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *OrderExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOrderExprList(s)
	}
}

func (s *OrderExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOrderExprList(s)
	}
}

func (p *ClickHouseParser) OrderExprList() (localctx IOrderExprListContext) {
	localctx = NewOrderExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ClickHouseParserRULE_orderExprList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1526)
		p.OrderExpr()
	}
	p.SetState(1531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1527)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1528)
				p.OrderExpr()
			}

		}
		p.SetState(1533)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderExprContext is an interface to support dynamic dispatch.
type IOrderExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnExpr() []IColumnExprContext
	ColumnExpr(i int) IColumnExprContext
	NULLS() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	WITH() antlr.TerminalNode
	FILL() antlr.TerminalNode
	ASCENDING() antlr.TerminalNode
	DESCENDING() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	STEP() antlr.TerminalNode

	// IsOrderExprContext differentiates from other interfaces.
	IsOrderExprContext()
}

type OrderExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderExprContext() *OrderExprContext {
	var p = new(OrderExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_orderExpr
	return p
}

func InitEmptyOrderExprContext(p *OrderExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_orderExpr
}

func (*OrderExprContext) IsOrderExprContext() {}

func NewOrderExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderExprContext {
	var p = new(OrderExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_orderExpr

	return p
}

func (s *OrderExprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderExprContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *OrderExprContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *OrderExprContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULLS, 0)
}

func (s *OrderExprContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLLATE, 0)
}

func (s *OrderExprContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *OrderExprContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *OrderExprContext) FILL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFILL, 0)
}

func (s *OrderExprContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASCENDING, 0)
}

func (s *OrderExprContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESCENDING, 0)
}

func (s *OrderExprContext) DESC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESC, 0)
}

func (s *OrderExprContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFIRST, 0)
}

func (s *OrderExprContext) LAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLAST, 0)
}

func (s *OrderExprContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *OrderExprContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *OrderExprContext) STEP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTEP, 0)
}

func (s *OrderExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterOrderExpr(s)
	}
}

func (s *OrderExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitOrderExpr(s)
	}
}

func (p *ClickHouseParser) OrderExpr() (localctx IOrderExprContext) {
	localctx = NewOrderExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ClickHouseParserRULE_orderExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1534)
		p.columnExpr(0)
	}
	p.SetState(1536)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1535)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&422212465070080) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1540)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1538)
			p.Match(ClickHouseParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1539)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserFIRST || _la == ClickHouseParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1542)
			p.Match(ClickHouseParserCOLLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1543)
			p.StringLiteral()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1560)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1546)
			p.Match(ClickHouseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1547)
			p.Match(ClickHouseParserFILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1550)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1548)
				p.Match(ClickHouseParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1549)
				p.columnExpr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1554)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1552)
				p.Match(ClickHouseParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1553)
				p.columnExpr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1558)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1556)
				p.Match(ClickHouseParserSTEP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1557)
				p.columnExpr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRatioExprContext is an interface to support dynamic dispatch.
type IRatioExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNumberLiteral() []INumberLiteralContext
	NumberLiteral(i int) INumberLiteralContext
	SLASH() antlr.TerminalNode

	// IsRatioExprContext differentiates from other interfaces.
	IsRatioExprContext()
}

type RatioExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRatioExprContext() *RatioExprContext {
	var p = new(RatioExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ratioExpr
	return p
}

func InitEmptyRatioExprContext(p *RatioExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_ratioExpr
}

func (*RatioExprContext) IsRatioExprContext() {}

func NewRatioExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RatioExprContext {
	var p = new(RatioExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_ratioExpr

	return p
}

func (s *RatioExprContext) GetParser() antlr.Parser { return s.parser }

func (s *RatioExprContext) AllNumberLiteral() []INumberLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberLiteralContext); ok {
			len++
		}
	}

	tst := make([]INumberLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberLiteralContext); ok {
			tst[i] = t.(INumberLiteralContext)
			i++
		}
	}

	return tst
}

func (s *RatioExprContext) NumberLiteral(i int) INumberLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *RatioExprContext) SLASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSLASH, 0)
}

func (s *RatioExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RatioExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RatioExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterRatioExpr(s)
	}
}

func (s *RatioExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitRatioExpr(s)
	}
}

func (p *ClickHouseParser) RatioExpr() (localctx IRatioExprContext) {
	localctx = NewRatioExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ClickHouseParserRULE_ratioExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1562)
		p.NumberLiteral()
	}
	p.SetState(1565)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1563)
			p.Match(ClickHouseParserSLASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1564)
			p.NumberLiteral()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISettingExprListContext is an interface to support dynamic dispatch.
type ISettingExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSettingExpr() []ISettingExprContext
	SettingExpr(i int) ISettingExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSettingExprListContext differentiates from other interfaces.
	IsSettingExprListContext()
}

type SettingExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettingExprListContext() *SettingExprListContext {
	var p = new(SettingExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settingExprList
	return p
}

func InitEmptySettingExprListContext(p *SettingExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settingExprList
}

func (*SettingExprListContext) IsSettingExprListContext() {}

func NewSettingExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SettingExprListContext {
	var p = new(SettingExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_settingExprList

	return p
}

func (s *SettingExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *SettingExprListContext) AllSettingExpr() []ISettingExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISettingExprContext); ok {
			len++
		}
	}

	tst := make([]ISettingExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISettingExprContext); ok {
			tst[i] = t.(ISettingExprContext)
			i++
		}
	}

	return tst
}

func (s *SettingExprListContext) SettingExpr(i int) ISettingExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingExprContext)
}

func (s *SettingExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *SettingExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *SettingExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SettingExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SettingExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSettingExprList(s)
	}
}

func (s *SettingExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSettingExprList(s)
	}
}

func (p *ClickHouseParser) SettingExprList() (localctx ISettingExprListContext) {
	localctx = NewSettingExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ClickHouseParserRULE_settingExprList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1567)
		p.SettingExpr()
	}
	p.SetState(1572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1568)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1569)
				p.SettingExpr()
			}

		}
		p.SetState(1574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISettingExprContext is an interface to support dynamic dispatch.
type ISettingExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ_SINGLE() antlr.TerminalNode
	Literal() ILiteralContext

	// IsSettingExprContext differentiates from other interfaces.
	IsSettingExprContext()
}

type SettingExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySettingExprContext() *SettingExprContext {
	var p = new(SettingExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settingExpr
	return p
}

func InitEmptySettingExprContext(p *SettingExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_settingExpr
}

func (*SettingExprContext) IsSettingExprContext() {}

func NewSettingExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SettingExprContext {
	var p = new(SettingExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_settingExpr

	return p
}

func (s *SettingExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SettingExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SettingExprContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *SettingExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SettingExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SettingExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SettingExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSettingExpr(s)
	}
}

func (s *SettingExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSettingExpr(s)
	}
}

func (p *ClickHouseParser) SettingExpr() (localctx ISettingExprContext) {
	localctx = NewSettingExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ClickHouseParserRULE_settingExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1575)
		p.Identifier()
	}
	{
		p.SetState(1576)
		p.Match(ClickHouseParserEQ_SINGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1577)
		p.Literal()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowExprContext is an interface to support dynamic dispatch.
type IWindowExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WinPartitionByClause() IWinPartitionByClauseContext
	WinOrderByClause() IWinOrderByClauseContext
	WinFrameClause() IWinFrameClauseContext

	// IsWindowExprContext differentiates from other interfaces.
	IsWindowExprContext()
}

type WindowExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowExprContext() *WindowExprContext {
	var p = new(WindowExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_windowExpr
	return p
}

func InitEmptyWindowExprContext(p *WindowExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_windowExpr
}

func (*WindowExprContext) IsWindowExprContext() {}

func NewWindowExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowExprContext {
	var p = new(WindowExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_windowExpr

	return p
}

func (s *WindowExprContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowExprContext) WinPartitionByClause() IWinPartitionByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinPartitionByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinPartitionByClauseContext)
}

func (s *WindowExprContext) WinOrderByClause() IWinOrderByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinOrderByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinOrderByClauseContext)
}

func (s *WindowExprContext) WinFrameClause() IWinFrameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinFrameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinFrameClauseContext)
}

func (s *WindowExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWindowExpr(s)
	}
}

func (s *WindowExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWindowExpr(s)
	}
}

func (p *ClickHouseParser) WindowExpr() (localctx IWindowExprContext) {
	localctx = NewWindowExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ClickHouseParserRULE_windowExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserPARTITION {
		{
			p.SetState(1579)
			p.WinPartitionByClause()
		}

	}
	p.SetState(1583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserORDER {
		{
			p.SetState(1582)
			p.WinOrderByClause()
		}

	}
	p.SetState(1586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserRANGE || _la == ClickHouseParserROWS {
		{
			p.SetState(1585)
			p.WinFrameClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinPartitionByClauseContext is an interface to support dynamic dispatch.
type IWinPartitionByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	ColumnExprList() IColumnExprListContext

	// IsWinPartitionByClauseContext differentiates from other interfaces.
	IsWinPartitionByClauseContext()
}

type WinPartitionByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinPartitionByClauseContext() *WinPartitionByClauseContext {
	var p = new(WinPartitionByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winPartitionByClause
	return p
}

func InitEmptyWinPartitionByClauseContext(p *WinPartitionByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winPartitionByClause
}

func (*WinPartitionByClauseContext) IsWinPartitionByClauseContext() {}

func NewWinPartitionByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinPartitionByClauseContext {
	var p = new(WinPartitionByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_winPartitionByClause

	return p
}

func (s *WinPartitionByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WinPartitionByClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPARTITION, 0)
}

func (s *WinPartitionByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *WinPartitionByClauseContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *WinPartitionByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinPartitionByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WinPartitionByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWinPartitionByClause(s)
	}
}

func (s *WinPartitionByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWinPartitionByClause(s)
	}
}

func (p *ClickHouseParser) WinPartitionByClause() (localctx IWinPartitionByClauseContext) {
	localctx = NewWinPartitionByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ClickHouseParserRULE_winPartitionByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1588)
		p.Match(ClickHouseParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1589)
		p.Match(ClickHouseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1590)
		p.ColumnExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinOrderByClauseContext is an interface to support dynamic dispatch.
type IWinOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	OrderExprList() IOrderExprListContext

	// IsWinOrderByClauseContext differentiates from other interfaces.
	IsWinOrderByClauseContext()
}

type WinOrderByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinOrderByClauseContext() *WinOrderByClauseContext {
	var p = new(WinOrderByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winOrderByClause
	return p
}

func InitEmptyWinOrderByClauseContext(p *WinOrderByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winOrderByClause
}

func (*WinOrderByClauseContext) IsWinOrderByClauseContext() {}

func NewWinOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinOrderByClauseContext {
	var p = new(WinOrderByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_winOrderByClause

	return p
}

func (s *WinOrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WinOrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserORDER, 0)
}

func (s *WinOrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *WinOrderByClauseContext) OrderExprList() IOrderExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderExprListContext)
}

func (s *WinOrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinOrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WinOrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWinOrderByClause(s)
	}
}

func (s *WinOrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWinOrderByClause(s)
	}
}

func (p *ClickHouseParser) WinOrderByClause() (localctx IWinOrderByClauseContext) {
	localctx = NewWinOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ClickHouseParserRULE_winOrderByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1592)
		p.Match(ClickHouseParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1593)
		p.Match(ClickHouseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1594)
		p.OrderExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinFrameClauseContext is an interface to support dynamic dispatch.
type IWinFrameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WinFrameExtend() IWinFrameExtendContext
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsWinFrameClauseContext differentiates from other interfaces.
	IsWinFrameClauseContext()
}

type WinFrameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinFrameClauseContext() *WinFrameClauseContext {
	var p = new(WinFrameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winFrameClause
	return p
}

func InitEmptyWinFrameClauseContext(p *WinFrameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winFrameClause
}

func (*WinFrameClauseContext) IsWinFrameClauseContext() {}

func NewWinFrameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinFrameClauseContext {
	var p = new(WinFrameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_winFrameClause

	return p
}

func (s *WinFrameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WinFrameClauseContext) WinFrameExtend() IWinFrameExtendContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinFrameExtendContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinFrameExtendContext)
}

func (s *WinFrameClauseContext) ROWS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROWS, 0)
}

func (s *WinFrameClauseContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRANGE, 0)
}

func (s *WinFrameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinFrameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WinFrameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWinFrameClause(s)
	}
}

func (s *WinFrameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWinFrameClause(s)
	}
}

func (p *ClickHouseParser) WinFrameClause() (localctx IWinFrameClauseContext) {
	localctx = NewWinFrameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ClickHouseParserRULE_winFrameClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1596)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserRANGE || _la == ClickHouseParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1597)
		p.WinFrameExtend()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinFrameExtendContext is an interface to support dynamic dispatch.
type IWinFrameExtendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWinFrameExtendContext differentiates from other interfaces.
	IsWinFrameExtendContext()
}

type WinFrameExtendContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinFrameExtendContext() *WinFrameExtendContext {
	var p = new(WinFrameExtendContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winFrameExtend
	return p
}

func InitEmptyWinFrameExtendContext(p *WinFrameExtendContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winFrameExtend
}

func (*WinFrameExtendContext) IsWinFrameExtendContext() {}

func NewWinFrameExtendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinFrameExtendContext {
	var p = new(WinFrameExtendContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_winFrameExtend

	return p
}

func (s *WinFrameExtendContext) GetParser() antlr.Parser { return s.parser }

func (s *WinFrameExtendContext) CopyAll(ctx *WinFrameExtendContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *WinFrameExtendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinFrameExtendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type FrameStartContext struct {
	WinFrameExtendContext
}

func NewFrameStartContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FrameStartContext {
	var p = new(FrameStartContext)

	InitEmptyWinFrameExtendContext(&p.WinFrameExtendContext)
	p.parser = parser
	p.CopyAll(ctx.(*WinFrameExtendContext))

	return p
}

func (s *FrameStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameStartContext) WinFrameBound() IWinFrameBoundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinFrameBoundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinFrameBoundContext)
}

func (s *FrameStartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFrameStart(s)
	}
}

func (s *FrameStartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFrameStart(s)
	}
}

type FrameBetweenContext struct {
	WinFrameExtendContext
}

func NewFrameBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FrameBetweenContext {
	var p = new(FrameBetweenContext)

	InitEmptyWinFrameExtendContext(&p.WinFrameExtendContext)
	p.parser = parser
	p.CopyAll(ctx.(*WinFrameExtendContext))

	return p
}

func (s *FrameBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBETWEEN, 0)
}

func (s *FrameBetweenContext) AllWinFrameBound() []IWinFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWinFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IWinFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWinFrameBoundContext); ok {
			tst[i] = t.(IWinFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *FrameBetweenContext) WinFrameBound(i int) IWinFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWinFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWinFrameBoundContext)
}

func (s *FrameBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAND, 0)
}

func (s *FrameBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFrameBetween(s)
	}
}

func (s *FrameBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFrameBetween(s)
	}
}

func (p *ClickHouseParser) WinFrameExtend() (localctx IWinFrameExtendContext) {
	localctx = NewWinFrameExtendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ClickHouseParserRULE_winFrameExtend)
	p.SetState(1605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserCURRENT, ClickHouseParserINF, ClickHouseParserNAN_SQL, ClickHouseParserUNBOUNDED, ClickHouseParserFLOATING_LITERAL, ClickHouseParserOCTAL_LITERAL, ClickHouseParserDECIMAL_LITERAL, ClickHouseParserHEXADECIMAL_NUMERIC_LITERAL, ClickHouseParserBINARY_NUMERIC_LITERAL, ClickHouseParserDASH, ClickHouseParserDOT, ClickHouseParserPLUS:
		localctx = NewFrameStartContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1599)
			p.WinFrameBound()
		}

	case ClickHouseParserBETWEEN:
		localctx = NewFrameBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1600)
			p.Match(ClickHouseParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1601)
			p.WinFrameBound()
		}
		{
			p.SetState(1602)
			p.Match(ClickHouseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1603)
			p.WinFrameBound()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWinFrameBoundContext is an interface to support dynamic dispatch.
type IWinFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CURRENT() antlr.TerminalNode
	ROW() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	NumberLiteral() INumberLiteralContext

	// IsWinFrameBoundContext differentiates from other interfaces.
	IsWinFrameBoundContext()
}

type WinFrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWinFrameBoundContext() *WinFrameBoundContext {
	var p = new(WinFrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winFrameBound
	return p
}

func InitEmptyWinFrameBoundContext(p *WinFrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_winFrameBound
}

func (*WinFrameBoundContext) IsWinFrameBoundContext() {}

func NewWinFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WinFrameBoundContext {
	var p = new(WinFrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_winFrameBound

	return p
}

func (s *WinFrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *WinFrameBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCURRENT, 0)
}

func (s *WinFrameBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROW, 0)
}

func (s *WinFrameBoundContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUNBOUNDED, 0)
}

func (s *WinFrameBoundContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRECEDING, 0)
}

func (s *WinFrameBoundContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFOLLOWING, 0)
}

func (s *WinFrameBoundContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *WinFrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WinFrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WinFrameBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWinFrameBound(s)
	}
}

func (s *WinFrameBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWinFrameBound(s)
	}
}

func (p *ClickHouseParser) WinFrameBound() (localctx IWinFrameBoundContext) {
	localctx = NewWinFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ClickHouseParserRULE_winFrameBound)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1607)
			p.Match(ClickHouseParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1608)
			p.Match(ClickHouseParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1609)
			p.Match(ClickHouseParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1610)
			p.Match(ClickHouseParserPRECEDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(1611)
			p.Match(ClickHouseParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1612)
			p.Match(ClickHouseParserFOLLOWING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(1613)
			p.NumberLiteral()
		}
		{
			p.SetState(1614)
			p.Match(ClickHouseParserPRECEDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(1616)
			p.NumberLiteral()
		}
		{
			p.SetState(1617)
			p.Match(ClickHouseParserFOLLOWING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStmtContext is an interface to support dynamic dispatch.
type ISetStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	SettingExprList() ISettingExprListContext

	// IsSetStmtContext differentiates from other interfaces.
	IsSetStmtContext()
}

type SetStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStmtContext() *SetStmtContext {
	var p = new(SetStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_setStmt
	return p
}

func InitEmptySetStmtContext(p *SetStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_setStmt
}

func (*SetStmtContext) IsSetStmtContext() {}

func NewSetStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStmtContext {
	var p = new(SetStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_setStmt

	return p
}

func (s *SetStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStmtContext) SET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSET, 0)
}

func (s *SetStmtContext) SettingExprList() ISettingExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISettingExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISettingExprListContext)
}

func (s *SetStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSetStmt(s)
	}
}

func (s *SetStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSetStmt(s)
	}
}

func (p *ClickHouseParser) SetStmt() (localctx ISetStmtContext) {
	localctx = NewSetStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ClickHouseParserRULE_setStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1621)
		p.Match(ClickHouseParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1622)
		p.SettingExprList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStmtContext is an interface to support dynamic dispatch.
type IShowStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsShowStmtContext differentiates from other interfaces.
	IsShowStmtContext()
}

type ShowStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStmtContext() *ShowStmtContext {
	var p = new(ShowStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_showStmt
	return p
}

func InitEmptyShowStmtContext(p *ShowStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_showStmt
}

func (*ShowStmtContext) IsShowStmtContext() {}

func NewShowStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStmtContext {
	var p = new(ShowStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_showStmt

	return p
}

func (s *ShowStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStmtContext) CopyAll(ctx *ShowStmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ShowStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowCreateUserStmtContext struct {
	ShowStmtContext
}

func NewShowCreateUserStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateUserStmtContext {
	var p = new(ShowCreateUserStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateUserStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateUserStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateUserStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateUserStmtContext) USER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSER, 0)
}

func (s *ShowCreateUserStmtContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCURRENT_USER, 0)
}

func (s *ShowCreateUserStmtContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowCreateUserStmtContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateUserStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ShowCreateUserStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ShowCreateUserStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateUserStmt(s)
	}
}

func (s *ShowCreateUserStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateUserStmt(s)
	}
}

type ShowMergesStmtContext struct {
	ShowStmtContext
}

func NewShowMergesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowMergesStmtContext {
	var p = new(ShowMergesStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowMergesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMergesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowMergesStmtContext) MERGES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMERGES, 0)
}

func (s *ShowMergesStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowMergesStmtContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *ShowMergesStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *ShowMergesStmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ShowMergesStmtContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ShowMergesStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ShowMergesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowMergesStmt(s)
	}
}

func (s *ShowMergesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowMergesStmt(s)
	}
}

type ShowTablesStmtContext struct {
	ShowStmtContext
}

func NewShowTablesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesStmtContext {
	var p = new(ShowTablesStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowTablesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowTablesStmtContext) TABLES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLES, 0)
}

func (s *ShowTablesStmtContext) FULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFULL, 0)
}

func (s *ShowTablesStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *ShowTablesStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *ShowTablesStmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *ShowTablesStmtContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ShowTablesStmtContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *ShowTablesStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *ShowTablesStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ShowTablesStmtContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *ShowTablesStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowTablesStmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ShowTablesStmtContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ShowTablesStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ShowTablesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowTablesStmt(s)
	}
}

func (s *ShowTablesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowTablesStmt(s)
	}
}

type ShowColumnsStmtContext struct {
	ShowStmtContext
}

func NewShowColumnsStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsStmtContext {
	var p = new(ShowColumnsStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowColumnsStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowColumnsStmtContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMNS, 0)
}

func (s *ShowColumnsStmtContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFIELDS, 0)
}

func (s *ShowColumnsStmtContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserFROM)
}

func (s *ShowColumnsStmtContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, i)
}

func (s *ShowColumnsStmtContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserIN)
}

func (s *ShowColumnsStmtContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, i)
}

func (s *ShowColumnsStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ShowColumnsStmtContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXTENDED, 0)
}

func (s *ShowColumnsStmtContext) FULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFULL, 0)
}

func (s *ShowColumnsStmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *ShowColumnsStmtContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ShowColumnsStmtContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *ShowColumnsStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *ShowColumnsStmtContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowColumnsStmtContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowColumnsStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowColumnsStmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ShowColumnsStmtContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ShowColumnsStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ShowColumnsStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowColumnsStmt(s)
	}
}

func (s *ShowColumnsStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowColumnsStmt(s)
	}
}

type ShowClusterStmtContext struct {
	ShowStmtContext
}

func NewShowClusterStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowClusterStmtContext {
	var p = new(ShowClusterStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowClusterStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowClusterStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowClusterStmtContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLUSTER, 0)
}

func (s *ShowClusterStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowClusterStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowClusterStmt(s)
	}
}

func (s *ShowClusterStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowClusterStmt(s)
	}
}

type ShowSettingsStmtContext struct {
	ShowStmtContext
}

func NewShowSettingsStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSettingsStmtContext {
	var p = new(ShowSettingsStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowSettingsStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSettingsStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowSettingsStmtContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTINGS, 0)
}

func (s *ShowSettingsStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowSettingsStmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ShowSettingsStmtContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ShowSettingsStmtContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCHANGED, 0)
}

func (s *ShowSettingsStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowSettingsStmt(s)
	}
}

func (s *ShowSettingsStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowSettingsStmt(s)
	}
}

type ShowQuotaStmtContext struct {
	ShowStmtContext
}

func NewShowQuotaStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQuotaStmtContext {
	var p = new(ShowQuotaStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowQuotaStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQuotaStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowQuotaStmtContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUOTA, 0)
}

func (s *ShowQuotaStmtContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCURRENT, 0)
}

func (s *ShowQuotaStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowQuotaStmt(s)
	}
}

func (s *ShowQuotaStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowQuotaStmt(s)
	}
}

type ShowCreateViewStmtContext struct {
	ShowStmtContext
}

func NewShowCreateViewStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateViewStmtContext {
	var p = new(ShowCreateViewStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateViewStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateViewStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateViewStmtContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *ShowCreateViewStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ShowCreateViewStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateViewStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateViewStmt(s)
	}
}

func (s *ShowCreateViewStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateViewStmt(s)
	}
}

type ShowSettingStmtContext struct {
	ShowStmtContext
}

func NewShowSettingStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSettingStmtContext {
	var p = new(ShowSettingStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowSettingStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSettingStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowSettingStmtContext) SETTING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTING, 0)
}

func (s *ShowSettingStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowSettingStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowSettingStmt(s)
	}
}

func (s *ShowSettingStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowSettingStmt(s)
	}
}

type ShowAccessStmtContext struct {
	ShowStmtContext
}

func NewShowAccessStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAccessStmtContext {
	var p = new(ShowAccessStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowAccessStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAccessStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowAccessStmtContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserACCESS, 0)
}

func (s *ShowAccessStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowAccessStmt(s)
	}
}

func (s *ShowAccessStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowAccessStmt(s)
	}
}

type ShowClustersStmtContext struct {
	ShowStmtContext
}

func NewShowClustersStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowClustersStmtContext {
	var p = new(ShowClustersStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowClustersStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowClustersStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowClustersStmtContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLUSTERS, 0)
}

func (s *ShowClustersStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowClustersStmtContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *ShowClustersStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *ShowClustersStmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ShowClustersStmtContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ShowClustersStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ShowClustersStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowClustersStmt(s)
	}
}

func (s *ShowClustersStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowClustersStmt(s)
	}
}

type ShowIndexStmtContext struct {
	ShowStmtContext
}

func NewShowIndexStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexStmtContext {
	var p = new(ShowIndexStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowIndexStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowIndexStmtContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *ShowIndexStmtContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEXES, 0)
}

func (s *ShowIndexStmtContext) INDICES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDICES, 0)
}

func (s *ShowIndexStmtContext) KEYS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEYS, 0)
}

func (s *ShowIndexStmtContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserFROM)
}

func (s *ShowIndexStmtContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, i)
}

func (s *ShowIndexStmtContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserIN)
}

func (s *ShowIndexStmtContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, i)
}

func (s *ShowIndexStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ShowIndexStmtContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXTENDED, 0)
}

func (s *ShowIndexStmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *ShowIndexStmtContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ShowIndexStmtContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowIndexStmtContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowIndexStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowIndexStmt(s)
	}
}

func (s *ShowIndexStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowIndexStmt(s)
	}
}

type ShowFunctionsStmtContext struct {
	ShowStmtContext
}

func NewShowFunctionsStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsStmtContext {
	var p = new(ShowFunctionsStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowFunctionsStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowFunctionsStmtContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFUNCTIONS, 0)
}

func (s *ShowFunctionsStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowFunctionsStmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ShowFunctionsStmtContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ShowFunctionsStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowFunctionsStmt(s)
	}
}

func (s *ShowFunctionsStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowFunctionsStmt(s)
	}
}

type ShowPoliciesStmtContext struct {
	ShowStmtContext
}

func NewShowPoliciesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPoliciesStmtContext {
	var p = new(ShowPoliciesStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowPoliciesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPoliciesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowPoliciesStmtContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPOLICIES, 0)
}

func (s *ShowPoliciesStmtContext) ROW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROW, 0)
}

func (s *ShowPoliciesStmtContext) ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserON, 0)
}

func (s *ShowPoliciesStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ShowPoliciesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowPoliciesStmt(s)
	}
}

func (s *ShowPoliciesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowPoliciesStmt(s)
	}
}

type ShowCreatePolicyStmtContext struct {
	ShowStmtContext
}

func NewShowCreatePolicyStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreatePolicyStmtContext {
	var p = new(ShowCreatePolicyStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreatePolicyStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreatePolicyStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreatePolicyStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreatePolicyStmtContext) POLICY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPOLICY, 0)
}

func (s *ShowCreatePolicyStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreatePolicyStmtContext) ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserON, 0)
}

func (s *ShowCreatePolicyStmtContext) AllTableIdentifier() []ITableIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITableIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableIdentifierContext); ok {
			tst[i] = t.(ITableIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowCreatePolicyStmtContext) TableIdentifier(i int) ITableIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ShowCreatePolicyStmtContext) ROW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROW, 0)
}

func (s *ShowCreatePolicyStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ShowCreatePolicyStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ShowCreatePolicyStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreatePolicyStmt(s)
	}
}

func (s *ShowCreatePolicyStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreatePolicyStmt(s)
	}
}

type ShowCreateQuotaStmtContext struct {
	ShowStmtContext
}

func NewShowCreateQuotaStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateQuotaStmtContext {
	var p = new(ShowCreateQuotaStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateQuotaStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateQuotaStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateQuotaStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateQuotaStmtContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUOTA, 0)
}

func (s *ShowCreateQuotaStmtContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCURRENT, 0)
}

func (s *ShowCreateQuotaStmtContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowCreateQuotaStmtContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateQuotaStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ShowCreateQuotaStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ShowCreateQuotaStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateQuotaStmt(s)
	}
}

func (s *ShowCreateQuotaStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateQuotaStmt(s)
	}
}

type ShowPrivilegesStmtContext struct {
	ShowStmtContext
}

func NewShowPrivilegesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPrivilegesStmtContext {
	var p = new(ShowPrivilegesStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowPrivilegesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPrivilegesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowPrivilegesStmtContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRIVILEGES, 0)
}

func (s *ShowPrivilegesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowPrivilegesStmt(s)
	}
}

func (s *ShowPrivilegesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowPrivilegesStmt(s)
	}
}

type ShowCreateDatabaseStmtContext struct {
	ShowStmtContext
}

func NewShowCreateDatabaseStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDatabaseStmtContext {
	var p = new(ShowCreateDatabaseStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateDatabaseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDatabaseStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateDatabaseStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *ShowCreateDatabaseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *ShowCreateDatabaseStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateDatabaseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateDatabaseStmt(s)
	}
}

func (s *ShowCreateDatabaseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateDatabaseStmt(s)
	}
}

type ShowDatabasesStmtContext struct {
	ShowStmtContext
}

func NewShowDatabasesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDatabasesStmtContext {
	var p = new(ShowDatabasesStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowDatabasesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabasesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowDatabasesStmtContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASES, 0)
}

func (s *ShowDatabasesStmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *ShowDatabasesStmtContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ShowDatabasesStmtContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *ShowDatabasesStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *ShowDatabasesStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowDatabasesStmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ShowDatabasesStmtContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ShowDatabasesStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ShowDatabasesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowDatabasesStmt(s)
	}
}

func (s *ShowDatabasesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowDatabasesStmt(s)
	}
}

type ShowCreateProfileStmtContext struct {
	ShowStmtContext
}

func NewShowCreateProfileStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateProfileStmtContext {
	var p = new(ShowCreateProfileStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateProfileStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateProfileStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateProfileStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateProfileStmtContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROFILE, 0)
}

func (s *ShowCreateProfileStmtContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowCreateProfileStmtContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateProfileStmtContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTINGS, 0)
}

func (s *ShowCreateProfileStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ShowCreateProfileStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ShowCreateProfileStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateProfileStmt(s)
	}
}

func (s *ShowCreateProfileStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateProfileStmt(s)
	}
}

type ShowCreateTableStmtContext struct {
	ShowStmtContext
}

func NewShowCreateTableStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableStmtContext {
	var p = new(ShowCreateTableStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateTableStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateTableStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ShowCreateTableStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *ShowCreateTableStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateTableStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *ShowCreateTableStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateTableStmt(s)
	}
}

func (s *ShowCreateTableStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateTableStmt(s)
	}
}

type ShowDictionariesStmtContext struct {
	ShowStmtContext
}

func NewShowDictionariesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDictionariesStmtContext {
	var p = new(ShowDictionariesStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowDictionariesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDictionariesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowDictionariesStmtContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARIES, 0)
}

func (s *ShowDictionariesStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ShowDictionariesStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *ShowDictionariesStmtContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *ShowDictionariesStmtContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ShowDictionariesStmtContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *ShowDictionariesStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *ShowDictionariesStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ShowDictionariesStmtContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ShowDictionariesStmtContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ShowDictionariesStmtContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ShowDictionariesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowDictionariesStmt(s)
	}
}

func (s *ShowDictionariesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowDictionariesStmt(s)
	}
}

type ShowProfilesStmtContext struct {
	ShowStmtContext
}

func NewShowProfilesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProfilesStmtContext {
	var p = new(ShowProfilesStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowProfilesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfilesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowProfilesStmtContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROFILES, 0)
}

func (s *ShowProfilesStmtContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTINGS, 0)
}

func (s *ShowProfilesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowProfilesStmt(s)
	}
}

func (s *ShowProfilesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowProfilesStmt(s)
	}
}

type ShowCreateDictionaryStmtContext struct {
	ShowStmtContext
}

func NewShowCreateDictionaryStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDictionaryStmtContext {
	var p = new(ShowCreateDictionaryStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateDictionaryStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDictionaryStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateDictionaryStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateDictionaryStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *ShowCreateDictionaryStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ShowCreateDictionaryStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateDictionaryStmt(s)
	}
}

func (s *ShowCreateDictionaryStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateDictionaryStmt(s)
	}
}

type ShowGrantsStmtContext struct {
	ShowStmtContext
}

func NewShowGrantsStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsStmtContext {
	var p = new(ShowGrantsStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowGrantsStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowGrantsStmtContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGRANTS, 0)
}

func (s *ShowGrantsStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFOR, 0)
}

func (s *ShowGrantsStmtContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowGrantsStmtContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowGrantsStmtContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *ShowGrantsStmtContext) IMPLICIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIMPLICIT, 0)
}

func (s *ShowGrantsStmtContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFINAL, 0)
}

func (s *ShowGrantsStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ShowGrantsStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ShowGrantsStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowGrantsStmt(s)
	}
}

func (s *ShowGrantsStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowGrantsStmt(s)
	}
}

type ShowQuotasStmtContext struct {
	ShowStmtContext
}

func NewShowQuotasStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQuotasStmtContext {
	var p = new(ShowQuotasStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowQuotasStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQuotasStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowQuotasStmtContext) QUOTAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUOTAS, 0)
}

func (s *ShowQuotasStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowQuotasStmt(s)
	}
}

func (s *ShowQuotasStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowQuotasStmt(s)
	}
}

type ShowRolesStmtContext struct {
	ShowStmtContext
}

func NewShowRolesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRolesStmtContext {
	var p = new(ShowRolesStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowRolesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowRolesStmtContext) ROLES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLES, 0)
}

func (s *ShowRolesStmtContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCURRENT, 0)
}

func (s *ShowRolesStmtContext) ENABLED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserENABLED, 0)
}

func (s *ShowRolesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowRolesStmt(s)
	}
}

func (s *ShowRolesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowRolesStmt(s)
	}
}

type ShowEnginesStmtContext struct {
	ShowStmtContext
}

func NewShowEnginesStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEnginesStmtContext {
	var p = new(ShowEnginesStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowEnginesStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEnginesStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowEnginesStmtContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserENGINES, 0)
}

func (s *ShowEnginesStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowEnginesStmt(s)
	}
}

func (s *ShowEnginesStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowEnginesStmt(s)
	}
}

type ShowProcessListStmtContext struct {
	ShowStmtContext
}

func NewShowProcessListStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcessListStmtContext {
	var p = new(ShowProcessListStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowProcessListStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcessListStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowProcessListStmtContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROCESSLIST, 0)
}

func (s *ShowProcessListStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowProcessListStmt(s)
	}
}

func (s *ShowProcessListStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowProcessListStmt(s)
	}
}

type ShowUsersStmtContext struct {
	ShowStmtContext
}

func NewShowUsersStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowUsersStmtContext {
	var p = new(ShowUsersStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowUsersStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUsersStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowUsersStmtContext) USERS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSERS, 0)
}

func (s *ShowUsersStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowUsersStmt(s)
	}
}

func (s *ShowUsersStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowUsersStmt(s)
	}
}

type ShowFilesystemCachesContext struct {
	ShowStmtContext
}

func NewShowFilesystemCachesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFilesystemCachesContext {
	var p = new(ShowFilesystemCachesContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowFilesystemCachesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFilesystemCachesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowFilesystemCachesContext) FILESYSTEM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFILESYSTEM, 0)
}

func (s *ShowFilesystemCachesContext) CACHES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCACHES, 0)
}

func (s *ShowFilesystemCachesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowFilesystemCaches(s)
	}
}

func (s *ShowFilesystemCachesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowFilesystemCaches(s)
	}
}

type ShowCreateRoleStmtContext struct {
	ShowStmtContext
}

func NewShowCreateRoleStmtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateRoleStmtContext {
	var p = new(ShowCreateRoleStmtContext)

	InitEmptyShowStmtContext(&p.ShowStmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowStmtContext))

	return p
}

func (s *ShowCreateRoleStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRoleStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *ShowCreateRoleStmtContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *ShowCreateRoleStmtContext) ROLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLE, 0)
}

func (s *ShowCreateRoleStmtContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowCreateRoleStmtContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateRoleStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ShowCreateRoleStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ShowCreateRoleStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterShowCreateRoleStmt(s)
	}
}

func (s *ShowCreateRoleStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitShowCreateRoleStmt(s)
	}
}

func (p *ClickHouseParser) ShowStmt() (localctx IShowStmtContext) {
	localctx = NewShowStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ClickHouseParserRULE_showStmt)
	var _la int

	p.SetState(1930)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowCreateDatabaseStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1624)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCREATE {
			{
				p.SetState(1625)
				p.Match(ClickHouseParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1628)
			p.Match(ClickHouseParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1629)
			p.DatabaseIdentifier()
		}

	case 2:
		localctx = NewShowCreateDictionaryStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1630)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1631)
			p.Match(ClickHouseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1632)
			p.Match(ClickHouseParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1633)
			p.TableIdentifier()
		}

	case 3:
		localctx = NewShowCreateViewStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1634)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCREATE {
			{
				p.SetState(1635)
				p.Match(ClickHouseParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1638)
			p.Match(ClickHouseParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1639)
			p.TableIdentifier()
		}

	case 4:
		localctx = NewShowDatabasesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1640)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1641)
			p.Match(ClickHouseParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserILIKE, ClickHouseParserLIKE, ClickHouseParserNOT:
			p.SetState(1643)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserNOT {
				{
					p.SetState(1642)
					p.Match(ClickHouseParserNOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1645)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1646)
				p.StringLiteral()
			}

		case ClickHouseParserWHERE:
			{
				p.SetState(1647)
				p.Match(ClickHouseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1648)
				p.columnExpr(0)
			}

		case ClickHouseParserEOF, ClickHouseParserFORMAT, ClickHouseParserINTO, ClickHouseParserLIMIT, ClickHouseParserSEMICOLON:

		default:
		}
		p.SetState(1653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserLIMIT {
			{
				p.SetState(1651)
				p.Match(ClickHouseParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1652)
				p.Match(ClickHouseParserDECIMAL_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewShowDictionariesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1655)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1656)
			p.Match(ClickHouseParserDICTIONARIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFROM {
			{
				p.SetState(1657)
				p.Match(ClickHouseParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1658)
				p.DatabaseIdentifier()
			}

		}
		p.SetState(1668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserILIKE, ClickHouseParserLIKE, ClickHouseParserNOT:
			p.SetState(1662)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserNOT {
				{
					p.SetState(1661)
					p.Match(ClickHouseParserNOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1664)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1665)
				p.StringLiteral()
			}

		case ClickHouseParserWHERE:
			{
				p.SetState(1666)
				p.Match(ClickHouseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1667)
				p.columnExpr(0)
			}

		case ClickHouseParserEOF, ClickHouseParserFORMAT, ClickHouseParserINTO, ClickHouseParserLIMIT, ClickHouseParserSEMICOLON:

		default:
		}
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserLIMIT {
			{
				p.SetState(1670)
				p.Match(ClickHouseParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1671)
				p.Match(ClickHouseParserDECIMAL_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewShowTablesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1674)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1676)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFULL {
			{
				p.SetState(1675)
				p.Match(ClickHouseParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserTEMPORARY {
			{
				p.SetState(1678)
				p.Match(ClickHouseParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1681)
			p.Match(ClickHouseParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFROM || _la == ClickHouseParserIN {
			{
				p.SetState(1682)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserFROM || _la == ClickHouseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1683)
				p.DatabaseIdentifier()
			}

		}
		p.SetState(1693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserILIKE, ClickHouseParserLIKE, ClickHouseParserNOT:
			p.SetState(1687)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserNOT {
				{
					p.SetState(1686)
					p.Match(ClickHouseParserNOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1689)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1690)
				p.StringLiteral()
			}

		case ClickHouseParserWHERE:
			{
				p.SetState(1691)
				p.Match(ClickHouseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1692)
				p.columnExpr(0)
			}

		case ClickHouseParserEOF, ClickHouseParserFORMAT, ClickHouseParserINTO, ClickHouseParserLIMIT, ClickHouseParserSEMICOLON:

		default:
		}
		p.SetState(1697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserLIMIT {
			{
				p.SetState(1695)
				p.Match(ClickHouseParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1696)
				p.Match(ClickHouseParserDECIMAL_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		localctx = NewShowColumnsStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1699)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserEXTENDED {
			{
				p.SetState(1700)
				p.Match(ClickHouseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFULL {
			{
				p.SetState(1703)
				p.Match(ClickHouseParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1706)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserCOLUMNS || _la == ClickHouseParserFIELDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1707)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserFROM || _la == ClickHouseParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1708)
				p.TableIdentifier()
			}

		case 2:
			{
				p.SetState(1709)
				p.Identifier()
			}
			{
				p.SetState(1710)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserFROM || _la == ClickHouseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1711)
				p.Identifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserILIKE, ClickHouseParserLIKE, ClickHouseParserNOT:
			p.SetState(1716)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserNOT {
				{
					p.SetState(1715)
					p.Match(ClickHouseParserNOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1718)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1719)
				p.StringLiteral()
			}

		case ClickHouseParserWHERE:
			{
				p.SetState(1720)
				p.Match(ClickHouseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1721)
				p.columnExpr(0)
			}

		case ClickHouseParserEOF, ClickHouseParserFORMAT, ClickHouseParserINTO, ClickHouseParserLIMIT, ClickHouseParserSEMICOLON:

		default:
		}
		p.SetState(1726)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserLIMIT {
			{
				p.SetState(1724)
				p.Match(ClickHouseParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1725)
				p.Match(ClickHouseParserDECIMAL_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 8:
		localctx = NewShowIndexStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1728)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1730)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserEXTENDED {
			{
				p.SetState(1729)
				p.Match(ClickHouseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1732)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-98)) & ^0x3f) == 0 && ((int64(1)<<(_la-98))&16391) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1733)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserFROM || _la == ClickHouseParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1734)
				p.TableIdentifier()
			}

		case 2:
			{
				p.SetState(1735)
				p.Identifier()
			}
			{
				p.SetState(1736)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserFROM || _la == ClickHouseParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1737)
				p.Identifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserWHERE {
			{
				p.SetState(1741)
				p.Match(ClickHouseParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1742)
				p.columnExpr(0)
			}

		}

	case 9:
		localctx = NewShowProcessListStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1745)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1746)
			p.Match(ClickHouseParserPROCESSLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewShowGrantsStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1747)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1748)
			p.Match(ClickHouseParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFOR {
			{
				p.SetState(1749)
				p.Match(ClickHouseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1750)
				p.Identifier()
			}
			p.SetState(1755)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ClickHouseParserCOMMA {
				{
					p.SetState(1751)
					p.Match(ClickHouseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1752)
					p.Identifier()
				}

				p.SetState(1757)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserWITH {
			{
				p.SetState(1760)
				p.Match(ClickHouseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1761)
				p.Match(ClickHouseParserIMPLICIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFINAL {
			{
				p.SetState(1764)
				p.Match(ClickHouseParserFINAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewShowCreateUserStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1767)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1768)
			p.Match(ClickHouseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1769)
			p.Match(ClickHouseParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1779)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1770)
				p.Identifier()
			}
			p.SetState(1775)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ClickHouseParserCOMMA {
				{
					p.SetState(1771)
					p.Match(ClickHouseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1772)
					p.Identifier()
				}

				p.SetState(1777)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1778)
				p.Match(ClickHouseParserCURRENT_USER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 12:
		localctx = NewShowCreateRoleStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1781)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1782)
			p.Match(ClickHouseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1783)
			p.Match(ClickHouseParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1784)
			p.Identifier()
		}
		p.SetState(1789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1785)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1786)
				p.Identifier()
			}

			p.SetState(1791)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 13:
		localctx = NewShowCreatePolicyStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1792)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1793)
			p.Match(ClickHouseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserROW {
			{
				p.SetState(1794)
				p.Match(ClickHouseParserROW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1797)
			p.Match(ClickHouseParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1798)
			p.Identifier()
		}
		{
			p.SetState(1799)
			p.Match(ClickHouseParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1800)
			p.TableIdentifier()
		}
		p.SetState(1805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1801)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1802)
				p.TableIdentifier()
			}

			p.SetState(1807)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 14:
		localctx = NewShowCreateQuotaStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1808)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1809)
			p.Match(ClickHouseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1810)
			p.Match(ClickHouseParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1820)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1811)
				p.Identifier()
			}
			p.SetState(1816)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ClickHouseParserCOMMA {
				{
					p.SetState(1812)
					p.Match(ClickHouseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1813)
					p.Identifier()
				}

				p.SetState(1818)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case 2:
			{
				p.SetState(1819)
				p.Match(ClickHouseParserCURRENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 15:
		localctx = NewShowCreateProfileStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1822)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1823)
			p.Match(ClickHouseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserSETTINGS {
			{
				p.SetState(1824)
				p.Match(ClickHouseParserSETTINGS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1827)
			p.Match(ClickHouseParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1828)
			p.Identifier()
		}
		p.SetState(1833)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(1829)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1830)
				p.Identifier()
			}

			p.SetState(1835)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 16:
		localctx = NewShowUsersStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1836)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1837)
			p.Match(ClickHouseParserUSERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewShowRolesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1838)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCURRENT || _la == ClickHouseParserENABLED {
			{
				p.SetState(1839)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserCURRENT || _la == ClickHouseParserENABLED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1842)
			p.Match(ClickHouseParserROLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewShowProfilesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1843)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserSETTINGS {
			{
				p.SetState(1844)
				p.Match(ClickHouseParserSETTINGS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1847)
			p.Match(ClickHouseParserPROFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewShowPoliciesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1848)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserROW {
			{
				p.SetState(1849)
				p.Match(ClickHouseParserROW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1852)
			p.Match(ClickHouseParserPOLICIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserON {
			{
				p.SetState(1853)
				p.Match(ClickHouseParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1854)
				p.TableIdentifier()
			}

		}

	case 20:
		localctx = NewShowQuotasStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1857)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1858)
			p.Match(ClickHouseParserQUOTAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewShowQuotaStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1859)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1861)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCURRENT {
			{
				p.SetState(1860)
				p.Match(ClickHouseParserCURRENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1863)
			p.Match(ClickHouseParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		localctx = NewShowAccessStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1864)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1865)
			p.Match(ClickHouseParserACCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewShowClusterStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1866)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1867)
			p.Match(ClickHouseParserCLUSTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1868)
			p.StringLiteral()
		}

	case 24:
		localctx = NewShowClustersStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1869)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1870)
			p.Match(ClickHouseParserCLUSTERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&17592202821633) != 0 {
			p.SetState(1872)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserNOT {
				{
					p.SetState(1871)
					p.Match(ClickHouseParserNOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1874)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1875)
				p.StringLiteral()
			}

		}
		p.SetState(1880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserLIMIT {
			{
				p.SetState(1878)
				p.Match(ClickHouseParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1879)
				p.Match(ClickHouseParserDECIMAL_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 25:
		localctx = NewShowSettingsStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1882)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1884)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserCHANGED {
			{
				p.SetState(1883)
				p.Match(ClickHouseParserCHANGED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1886)
			p.Match(ClickHouseParserSETTINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1887)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1888)
			p.StringLiteral()
		}

	case 26:
		localctx = NewShowSettingStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1889)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1890)
			p.Match(ClickHouseParserSETTING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1891)
			p.StringLiteral()
		}

	case 27:
		localctx = NewShowFilesystemCachesContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1892)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1893)
			p.Match(ClickHouseParserFILESYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1894)
			p.Match(ClickHouseParserCACHES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		localctx = NewShowEnginesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1895)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1896)
			p.Match(ClickHouseParserENGINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		localctx = NewShowFunctionsStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1897)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1898)
			p.Match(ClickHouseParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE {
			{
				p.SetState(1899)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1900)
				p.StringLiteral()
			}

		}

	case 30:
		localctx = NewShowMergesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1903)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1904)
			p.Match(ClickHouseParserMERGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&17592202821633) != 0 {
			p.SetState(1906)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserNOT {
				{
					p.SetState(1905)
					p.Match(ClickHouseParserNOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1908)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1909)
				p.StringLiteral()
			}

		}
		p.SetState(1914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserLIMIT {
			{
				p.SetState(1912)
				p.Match(ClickHouseParserLIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1913)
				p.Match(ClickHouseParserDECIMAL_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 31:
		localctx = NewShowPrivilegesStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1916)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1917)
			p.Match(ClickHouseParserPRIVILEGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		localctx = NewShowCreateTableStmtContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1918)
			p.Match(ClickHouseParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1927)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1919)
				p.Match(ClickHouseParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1920)
				p.Match(ClickHouseParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1922)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 265, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1921)
					p.Match(ClickHouseParserTEMPORARY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(1925)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1924)
					p.Match(ClickHouseParserTABLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1929)
			p.TableIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISystemStmtContext is an interface to support dynamic dispatch.
type ISystemStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYSTEM() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	TableIdentifier() ITableIdentifierContext
	LOGS() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	DICTIONARIES() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	START() antlr.TerminalNode
	STOP() antlr.TerminalNode
	SENDS() antlr.TerminalNode
	FETCHES() antlr.TerminalNode
	MERGES() antlr.TerminalNode
	TTL() antlr.TerminalNode
	REPLICATED() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	REPLICA() antlr.TerminalNode

	// IsSystemStmtContext differentiates from other interfaces.
	IsSystemStmtContext()
}

type SystemStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemStmtContext() *SystemStmtContext {
	var p = new(SystemStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_systemStmt
	return p
}

func InitEmptySystemStmtContext(p *SystemStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_systemStmt
}

func (*SystemStmtContext) IsSystemStmtContext() {}

func NewSystemStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemStmtContext {
	var p = new(SystemStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_systemStmt

	return p
}

func (s *SystemStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemStmtContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYSTEM, 0)
}

func (s *SystemStmtContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFLUSH, 0)
}

func (s *SystemStmtContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTRIBUTED, 0)
}

func (s *SystemStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *SystemStmtContext) LOGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOGS, 0)
}

func (s *SystemStmtContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRELOAD, 0)
}

func (s *SystemStmtContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARIES, 0)
}

func (s *SystemStmtContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *SystemStmtContext) START() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTART, 0)
}

func (s *SystemStmtContext) STOP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTOP, 0)
}

func (s *SystemStmtContext) SENDS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSENDS, 0)
}

func (s *SystemStmtContext) FETCHES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFETCHES, 0)
}

func (s *SystemStmtContext) MERGES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMERGES, 0)
}

func (s *SystemStmtContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *SystemStmtContext) REPLICATED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICATED, 0)
}

func (s *SystemStmtContext) SYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNC, 0)
}

func (s *SystemStmtContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICA, 0)
}

func (s *SystemStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterSystemStmt(s)
	}
}

func (s *SystemStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitSystemStmt(s)
	}
}

func (p *ClickHouseParser) SystemStmt() (localctx ISystemStmtContext) {
	localctx = NewSystemStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ClickHouseParserRULE_systemStmt)
	var _la int

	p.SetState(1966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1932)
			p.Match(ClickHouseParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1933)
			p.Match(ClickHouseParserFLUSH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1934)
			p.Match(ClickHouseParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1935)
			p.TableIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1936)
			p.Match(ClickHouseParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1937)
			p.Match(ClickHouseParserFLUSH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1938)
			p.Match(ClickHouseParserLOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1939)
			p.Match(ClickHouseParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1940)
			p.Match(ClickHouseParserRELOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1941)
			p.Match(ClickHouseParserDICTIONARIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1942)
			p.Match(ClickHouseParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1943)
			p.Match(ClickHouseParserRELOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1944)
			p.Match(ClickHouseParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1945)
			p.TableIdentifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1946)
			p.Match(ClickHouseParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1947)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserSTART || _la == ClickHouseParserSTOP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserDISTRIBUTED:
			{
				p.SetState(1948)
				p.Match(ClickHouseParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1949)
				p.Match(ClickHouseParserSENDS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case ClickHouseParserFETCHES:
			{
				p.SetState(1950)
				p.Match(ClickHouseParserFETCHES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case ClickHouseParserMERGES, ClickHouseParserTTL:
			p.SetState(1952)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ClickHouseParserTTL {
				{
					p.SetState(1951)
					p.Match(ClickHouseParserTTL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1954)
				p.Match(ClickHouseParserMERGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1957)
			p.TableIdentifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1958)
			p.Match(ClickHouseParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1959)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserSTART || _la == ClickHouseParserSTOP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1960)
			p.Match(ClickHouseParserREPLICATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1961)
			p.Match(ClickHouseParserSENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1962)
			p.Match(ClickHouseParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1963)
			p.Match(ClickHouseParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1964)
			p.Match(ClickHouseParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1965)
			p.TableIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateStmtContext is an interface to support dynamic dispatch.
type ITruncateStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TableIdentifier() ITableIdentifierContext
	TEMPORARY() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	ClusterClause() IClusterClauseContext

	// IsTruncateStmtContext differentiates from other interfaces.
	IsTruncateStmtContext()
}

type TruncateStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateStmtContext() *TruncateStmtContext {
	var p = new(TruncateStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_truncateStmt
	return p
}

func InitEmptyTruncateStmtContext(p *TruncateStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_truncateStmt
}

func (*TruncateStmtContext) IsTruncateStmtContext() {}

func NewTruncateStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateStmtContext {
	var p = new(TruncateStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_truncateStmt

	return p
}

func (s *TruncateStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateStmtContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRUNCATE, 0)
}

func (s *TruncateStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *TruncateStmtContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *TruncateStmtContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *TruncateStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *TruncateStmtContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *TruncateStmtContext) ClusterClause() IClusterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusterClauseContext)
}

func (s *TruncateStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTruncateStmt(s)
	}
}

func (s *TruncateStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTruncateStmt(s)
	}
}

func (p *ClickHouseParser) TruncateStmt() (localctx ITruncateStmtContext) {
	localctx = NewTruncateStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ClickHouseParserRULE_truncateStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1968)
		p.Match(ClickHouseParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1970)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1969)
			p.Match(ClickHouseParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1973)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 273, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1972)
			p.Match(ClickHouseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1977)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1975)
			p.Match(ClickHouseParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1976)
			p.Match(ClickHouseParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1979)
		p.TableIdentifier()
	}
	p.SetState(1981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserON {
		{
			p.SetState(1980)
			p.ClusterClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseStmtContext is an interface to support dynamic dispatch.
type IUseStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	DatabaseIdentifier() IDatabaseIdentifierContext

	// IsUseStmtContext differentiates from other interfaces.
	IsUseStmtContext()
}

type UseStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStmtContext() *UseStmtContext {
	var p = new(UseStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_useStmt
	return p
}

func InitEmptyUseStmtContext(p *UseStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_useStmt
}

func (*UseStmtContext) IsUseStmtContext() {}

func NewUseStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStmtContext {
	var p = new(UseStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_useStmt

	return p
}

func (s *UseStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStmtContext) USE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSE, 0)
}

func (s *UseStmtContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *UseStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterUseStmt(s)
	}
}

func (s *UseStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitUseStmt(s)
	}
}

func (p *ClickHouseParser) UseStmt() (localctx IUseStmtContext) {
	localctx = NewUseStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ClickHouseParserRULE_useStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1983)
		p.Match(ClickHouseParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1984)
		p.DatabaseIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWatchStmtContext is an interface to support dynamic dispatch.
type IWatchStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WATCH() antlr.TerminalNode
	TableIdentifier() ITableIdentifierContext
	EVENTS() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode

	// IsWatchStmtContext differentiates from other interfaces.
	IsWatchStmtContext()
}

type WatchStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWatchStmtContext() *WatchStmtContext {
	var p = new(WatchStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_watchStmt
	return p
}

func InitEmptyWatchStmtContext(p *WatchStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_watchStmt
}

func (*WatchStmtContext) IsWatchStmtContext() {}

func NewWatchStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WatchStmtContext {
	var p = new(WatchStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_watchStmt

	return p
}

func (s *WatchStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WatchStmtContext) WATCH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWATCH, 0)
}

func (s *WatchStmtContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *WatchStmtContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEVENTS, 0)
}

func (s *WatchStmtContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *WatchStmtContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *WatchStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WatchStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WatchStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterWatchStmt(s)
	}
}

func (s *WatchStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitWatchStmt(s)
	}
}

func (p *ClickHouseParser) WatchStmt() (localctx IWatchStmtContext) {
	localctx = NewWatchStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ClickHouseParserRULE_watchStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1986)
		p.Match(ClickHouseParserWATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1987)
		p.TableIdentifier()
	}
	p.SetState(1989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserEVENTS {
		{
			p.SetState(1988)
			p.Match(ClickHouseParserEVENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserLIMIT {
		{
			p.SetState(1991)
			p.Match(ClickHouseParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1992)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnTypeExprContext is an interface to support dynamic dispatch.
type IColumnTypeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnTypeExprContext differentiates from other interfaces.
	IsColumnTypeExprContext()
}

type ColumnTypeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnTypeExprContext() *ColumnTypeExprContext {
	var p = new(ColumnTypeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnTypeExpr
	return p
}

func InitEmptyColumnTypeExprContext(p *ColumnTypeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnTypeExpr
}

func (*ColumnTypeExprContext) IsColumnTypeExprContext() {}

func NewColumnTypeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnTypeExprContext {
	var p = new(ColumnTypeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnTypeExpr

	return p
}

func (s *ColumnTypeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnTypeExprContext) CopyAll(ctx *ColumnTypeExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnTypeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnTypeExprNestedContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprNestedContext {
	var p = new(ColumnTypeExprNestedContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprNestedContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnTypeExprNestedContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprNestedContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnTypeExprNestedContext) AllColumnTypeExpr() []IColumnTypeExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnTypeExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnTypeExprContext); ok {
			tst[i] = t.(IColumnTypeExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnTypeExprNestedContext) ColumnTypeExpr(i int) IColumnTypeExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnTypeExprNestedContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnTypeExprNestedContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnTypeExprNestedContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnTypeExprNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprNested(s)
	}
}

func (s *ColumnTypeExprNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprNested(s)
	}
}

type ColumnTypeExprParamContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprParamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprParamContext {
	var p = new(ColumnTypeExprParamContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprParamContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprParamContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnTypeExprParamContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnTypeExprParamContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnTypeExprParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprParam(s)
	}
}

func (s *ColumnTypeExprParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprParam(s)
	}
}

type ColumnTypeExprSimpleContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprSimpleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprSimpleContext {
	var p = new(ColumnTypeExprSimpleContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprSimpleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprSimple(s)
	}
}

func (s *ColumnTypeExprSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprSimple(s)
	}
}

type ColumnTypeExprComplexContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprComplexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprComplexContext {
	var p = new(ColumnTypeExprComplexContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprComplexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprComplexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprComplexContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnTypeExprComplexContext) AllColumnTypeExpr() []IColumnTypeExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnTypeExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnTypeExprContext); ok {
			tst[i] = t.(IColumnTypeExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnTypeExprComplexContext) ColumnTypeExpr(i int) IColumnTypeExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnTypeExprComplexContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnTypeExprComplexContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnTypeExprComplexContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnTypeExprComplexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprComplex(s)
	}
}

func (s *ColumnTypeExprComplexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprComplex(s)
	}
}

type ColumnTypeExprEnumContext struct {
	ColumnTypeExprContext
}

func NewColumnTypeExprEnumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnTypeExprEnumContext {
	var p = new(ColumnTypeExprEnumContext)

	InitEmptyColumnTypeExprContext(&p.ColumnTypeExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnTypeExprContext))

	return p
}

func (s *ColumnTypeExprEnumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnTypeExprEnumContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnTypeExprEnumContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnTypeExprEnumContext) AllEnumValue() []IEnumValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumValueContext); ok {
			len++
		}
	}

	tst := make([]IEnumValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumValueContext); ok {
			tst[i] = t.(IEnumValueContext)
			i++
		}
	}

	return tst
}

func (s *ColumnTypeExprEnumContext) EnumValue(i int) IEnumValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *ColumnTypeExprEnumContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnTypeExprEnumContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnTypeExprEnumContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnTypeExprEnumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnTypeExprEnum(s)
	}
}

func (s *ColumnTypeExprEnumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnTypeExprEnum(s)
	}
}

func (p *ClickHouseParser) ColumnTypeExpr() (localctx IColumnTypeExprContext) {
	localctx = NewColumnTypeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ClickHouseParserRULE_columnTypeExpr)
	var _la int

	p.SetState(2042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnTypeExprSimpleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1995)
			p.Identifier()
		}

	case 2:
		localctx = NewColumnTypeExprNestedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1996)
			p.Identifier()
		}
		{
			p.SetState(1997)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1998)
			p.Identifier()
		}
		{
			p.SetState(1999)
			p.ColumnTypeExpr()
		}
		p.SetState(2006)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(2000)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2001)
				p.Identifier()
			}
			{
				p.SetState(2002)
				p.ColumnTypeExpr()
			}

			p.SetState(2008)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2009)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewColumnTypeExprEnumContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2011)
			p.Identifier()
		}
		{
			p.SetState(2012)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2013)
			p.EnumValue()
		}
		p.SetState(2018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(2014)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2015)
				p.EnumValue()
			}

			p.SetState(2020)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2021)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewColumnTypeExprComplexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2023)
			p.Identifier()
		}
		{
			p.SetState(2024)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2025)
			p.ColumnTypeExpr()
		}
		p.SetState(2030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(2026)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2027)
				p.ColumnTypeExpr()
			}

			p.SetState(2032)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2033)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewColumnTypeExprParamContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2035)
			p.Identifier()
		}
		{
			p.SetState(2036)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4557642822898941953) != 0) || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&69) != 0) {
			{
				p.SetState(2037)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(2040)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnExprListContext is an interface to support dynamic dispatch.
type IColumnExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnsExpr() []IColumnsExprContext
	ColumnsExpr(i int) IColumnsExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnExprListContext differentiates from other interfaces.
	IsColumnExprListContext()
}

type ColumnExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnExprListContext() *ColumnExprListContext {
	var p = new(ColumnExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnExprList
	return p
}

func InitEmptyColumnExprListContext(p *ColumnExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnExprList
}

func (*ColumnExprListContext) IsColumnExprListContext() {}

func NewColumnExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnExprListContext {
	var p = new(ColumnExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnExprList

	return p
}

func (s *ColumnExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnExprListContext) AllColumnsExpr() []IColumnsExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnsExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnsExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnsExprContext); ok {
			tst[i] = t.(IColumnsExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprListContext) ColumnsExpr(i int) IColumnsExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsExprContext)
}

func (s *ColumnExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprList(s)
	}
}

func (s *ColumnExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprList(s)
	}
}

func (p *ClickHouseParser) ColumnExprList() (localctx IColumnExprListContext) {
	localctx = NewColumnExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ClickHouseParserRULE_columnExprList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2044)
		p.ColumnsExpr()
	}
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2045)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2046)
				p.ColumnsExpr()
			}

		}
		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnsExprContext is an interface to support dynamic dispatch.
type IColumnsExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnsExprContext differentiates from other interfaces.
	IsColumnsExprContext()
}

type ColumnsExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsExprContext() *ColumnsExprContext {
	var p = new(ColumnsExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnsExpr
	return p
}

func InitEmptyColumnsExprContext(p *ColumnsExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnsExpr
}

func (*ColumnsExprContext) IsColumnsExprContext() {}

func NewColumnsExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsExprContext {
	var p = new(ColumnsExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnsExpr

	return p
}

func (s *ColumnsExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsExprContext) CopyAll(ctx *ColumnsExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnsExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnsExprColumnContext struct {
	ColumnsExprContext
}

func NewColumnsExprColumnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnsExprColumnContext {
	var p = new(ColumnsExprColumnContext)

	InitEmptyColumnsExprContext(&p.ColumnsExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnsExprContext))

	return p
}

func (s *ColumnsExprColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprColumnContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnsExprColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnsExprColumn(s)
	}
}

func (s *ColumnsExprColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnsExprColumn(s)
	}
}

type ColumnsExprAsteriskContext struct {
	ColumnsExprContext
}

func NewColumnsExprAsteriskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnsExprAsteriskContext {
	var p = new(ColumnsExprAsteriskContext)

	InitEmptyColumnsExprContext(&p.ColumnsExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnsExprContext))

	return p
}

func (s *ColumnsExprAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASTERISK, 0)
}

func (s *ColumnsExprAsteriskContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ColumnsExprAsteriskContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *ColumnsExprAsteriskContext) ColumnExceptExpr() IColumnExceptExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExceptExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExceptExprContext)
}

func (s *ColumnsExprAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnsExprAsterisk(s)
	}
}

func (s *ColumnsExprAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnsExprAsterisk(s)
	}
}

type ColumnsExprSubqueryContext struct {
	ColumnsExprContext
}

func NewColumnsExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnsExprSubqueryContext {
	var p = new(ColumnsExprSubqueryContext)

	InitEmptyColumnsExprContext(&p.ColumnsExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnsExprContext))

	return p
}

func (s *ColumnsExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnsExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *ColumnsExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnsExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnsExprSubquery(s)
	}
}

func (s *ColumnsExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnsExprSubquery(s)
	}
}

func (p *ClickHouseParser) ColumnsExpr() (localctx IColumnsExprContext) {
	localctx = NewColumnsExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ClickHouseParserRULE_columnsExpr)
	var _la int

	p.SetState(2066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnsExprAsteriskContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-137438953473) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606851329) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&175921860444159) != 0) {
			{
				p.SetState(2052)
				p.TableIdentifier()
			}
			{
				p.SetState(2053)
				p.Match(ClickHouseParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2057)
			p.Match(ClickHouseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2059)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2058)
				p.ColumnExceptExpr()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewColumnsExprSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2061)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2062)
			p.SelectUnionStmt()
		}
		{
			p.SetState(2063)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewColumnsExprColumnContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2065)
			p.columnExpr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnExprContext is an interface to support dynamic dispatch.
type IColumnExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnExprContext differentiates from other interfaces.
	IsColumnExprContext()
}

type ColumnExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnExprContext() *ColumnExprContext {
	var p = new(ColumnExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnExpr
	return p
}

func InitEmptyColumnExprContext(p *ColumnExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnExpr
}

func (*ColumnExprContext) IsColumnExprContext() {}

func NewColumnExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnExprContext {
	var p = new(ColumnExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnExpr

	return p
}

func (s *ColumnExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnExprContext) CopyAll(ctx *ColumnExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnExprTernaryOpContext struct {
	ColumnExprContext
}

func NewColumnExprTernaryOpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTernaryOpContext {
	var p = new(ColumnExprTernaryOpContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTernaryOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTernaryOpContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprTernaryOpContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprTernaryOpContext) QUERY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUERY, 0)
}

func (s *ColumnExprTernaryOpContext) COLON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLON, 0)
}

func (s *ColumnExprTernaryOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTernaryOp(s)
	}
}

func (s *ColumnExprTernaryOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTernaryOp(s)
	}
}

type ColumnExprAliasContext struct {
	ColumnExprContext
}

func NewColumnExprAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprAliasContext {
	var p = new(ColumnExprAliasContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprAliasContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprAliasContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *ColumnExprAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *ColumnExprAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprAlias(s)
	}
}

func (s *ColumnExprAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprAlias(s)
	}
}

type ColumnExprExtractContext struct {
	ColumnExprContext
}

func NewColumnExprExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprExtractContext {
	var p = new(ColumnExprExtractContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXTRACT, 0)
}

func (s *ColumnExprExtractContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprExtractContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *ColumnExprExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ColumnExprExtractContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprExtractContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprExtract(s)
	}
}

func (s *ColumnExprExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprExtract(s)
	}
}

type ColumnExprNegateContext struct {
	ColumnExprContext
}

func NewColumnExprNegateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprNegateContext {
	var p = new(ColumnExprNegateContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprNegateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprNegateContext) DASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDASH, 0)
}

func (s *ColumnExprNegateContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprNegateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprNegate(s)
	}
}

func (s *ColumnExprNegateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprNegate(s)
	}
}

type ColumnExprSubqueryContext struct {
	ColumnExprContext
}

func NewColumnExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprSubqueryContext {
	var p = new(ColumnExprSubqueryContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *ColumnExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprSubquery(s)
	}
}

func (s *ColumnExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprSubquery(s)
	}
}

type ColumnExprLiteralContext struct {
	ColumnExprContext
}

func NewColumnExprLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprLiteralContext {
	var p = new(ColumnExprLiteralContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ColumnExprLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprLiteral(s)
	}
}

func (s *ColumnExprLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprLiteral(s)
	}
}

type ColumnExprArrayContext struct {
	ColumnExprContext
}

func NewColumnExprArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprArrayContext {
	var p = new(ColumnExprArrayContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprArrayContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLBRACKET, 0)
}

func (s *ColumnExprArrayContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRBRACKET, 0)
}

func (s *ColumnExprArrayContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprArray(s)
	}
}

func (s *ColumnExprArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprArray(s)
	}
}

type ColumnExprSubstringContext struct {
	ColumnExprContext
}

func NewColumnExprSubstringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprSubstringContext {
	var p = new(ColumnExprSubstringContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprSubstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprSubstringContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSUBSTRING, 0)
}

func (s *ColumnExprSubstringContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprSubstringContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprSubstringContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprSubstringContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ColumnExprSubstringContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprSubstringContext) FOR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFOR, 0)
}

func (s *ColumnExprSubstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprSubstring(s)
	}
}

func (s *ColumnExprSubstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprSubstring(s)
	}
}

type ColumnExprCastContext struct {
	ColumnExprContext
}

func NewColumnExprCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprCastContext {
	var p = new(ColumnExprCastContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprCastContext) CAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCAST, 0)
}

func (s *ColumnExprCastContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprCastContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprCastContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *ColumnExprCastContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnExprCastContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprCast(s)
	}
}

func (s *ColumnExprCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprCast(s)
	}
}

type ColumnExprOrContext struct {
	ColumnExprContext
}

func NewColumnExprOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprOrContext {
	var p = new(ColumnExprOrContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprOrContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprOrContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprOrContext) OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOR, 0)
}

func (s *ColumnExprOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprOr(s)
	}
}

func (s *ColumnExprOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprOr(s)
	}
}

type ColumnExprCastSymbolContext struct {
	ColumnExprContext
}

func NewColumnExprCastSymbolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprCastSymbolContext {
	var p = new(ColumnExprCastSymbolContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprCastSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprCastSymbolContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprCastSymbolContext) DOUBLE_COLON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOUBLE_COLON, 0)
}

func (s *ColumnExprCastSymbolContext) ColumnTypeExpr() IColumnTypeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnTypeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnTypeExprContext)
}

func (s *ColumnExprCastSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprCastSymbol(s)
	}
}

func (s *ColumnExprCastSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprCastSymbol(s)
	}
}

type ColumnExprPrecedence1Context struct {
	ColumnExprContext
}

func NewColumnExprPrecedence1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprPrecedence1Context {
	var p = new(ColumnExprPrecedence1Context)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprPrecedence1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprPrecedence1Context) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprPrecedence1Context) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprPrecedence1Context) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASTERISK, 0)
}

func (s *ColumnExprPrecedence1Context) SLASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSLASH, 0)
}

func (s *ColumnExprPrecedence1Context) PERCENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPERCENT, 0)
}

func (s *ColumnExprPrecedence1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprPrecedence1(s)
	}
}

func (s *ColumnExprPrecedence1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprPrecedence1(s)
	}
}

type ColumnExprPrecedence2Context struct {
	ColumnExprContext
}

func NewColumnExprPrecedence2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprPrecedence2Context {
	var p = new(ColumnExprPrecedence2Context)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprPrecedence2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprPrecedence2Context) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprPrecedence2Context) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprPrecedence2Context) PLUS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPLUS, 0)
}

func (s *ColumnExprPrecedence2Context) DASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDASH, 0)
}

func (s *ColumnExprPrecedence2Context) CONCAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCONCAT, 0)
}

func (s *ColumnExprPrecedence2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprPrecedence2(s)
	}
}

func (s *ColumnExprPrecedence2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprPrecedence2(s)
	}
}

type ColumnExprPrecedence3Context struct {
	ColumnExprContext
}

func NewColumnExprPrecedence3Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprPrecedence3Context {
	var p = new(ColumnExprPrecedence3Context)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprPrecedence3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprPrecedence3Context) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprPrecedence3Context) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprPrecedence3Context) EQ_DOUBLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_DOUBLE, 0)
}

func (s *ColumnExprPrecedence3Context) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *ColumnExprPrecedence3Context) NOT_EQ() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT_EQ, 0)
}

func (s *ColumnExprPrecedence3Context) LE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLE, 0)
}

func (s *ColumnExprPrecedence3Context) GE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGE, 0)
}

func (s *ColumnExprPrecedence3Context) LT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLT, 0)
}

func (s *ColumnExprPrecedence3Context) GT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGT, 0)
}

func (s *ColumnExprPrecedence3Context) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *ColumnExprPrecedence3Context) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *ColumnExprPrecedence3Context) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *ColumnExprPrecedence3Context) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGLOBAL, 0)
}

func (s *ColumnExprPrecedence3Context) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ColumnExprPrecedence3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprPrecedence3(s)
	}
}

func (s *ColumnExprPrecedence3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprPrecedence3(s)
	}
}

type ColumnExprIntervalContext struct {
	ColumnExprContext
}

func NewColumnExprIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprIntervalContext {
	var p = new(ColumnExprIntervalContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprIntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTERVAL, 0)
}

func (s *ColumnExprIntervalContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprIntervalContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *ColumnExprIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprInterval(s)
	}
}

func (s *ColumnExprIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprInterval(s)
	}
}

type ColumnExprIsNullContext struct {
	ColumnExprContext
}

func NewColumnExprIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprIsNullContext {
	var p = new(ColumnExprIsNullContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprIsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprIsNullContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprIsNullContext) IS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIS, 0)
}

func (s *ColumnExprIsNullContext) NULL_SQL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULL_SQL, 0)
}

func (s *ColumnExprIsNullContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ColumnExprIsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprIsNull(s)
	}
}

func (s *ColumnExprIsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprIsNull(s)
	}
}

type ColumnExprWinFunctionTargetContext struct {
	ColumnExprContext
}

func NewColumnExprWinFunctionTargetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprWinFunctionTargetContext {
	var p = new(ColumnExprWinFunctionTargetContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprWinFunctionTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprWinFunctionTargetContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprWinFunctionTargetContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprWinFunctionTargetContext) OVER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOVER, 0)
}

func (s *ColumnExprWinFunctionTargetContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprWinFunctionTargetContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprWinFunctionTargetContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprWinFunctionTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprWinFunctionTarget(s)
	}
}

func (s *ColumnExprWinFunctionTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprWinFunctionTarget(s)
	}
}

type ColumnExprTrimContext struct {
	ColumnExprContext
}

func NewColumnExprTrimContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTrimContext {
	var p = new(ColumnExprTrimContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTrimContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTrimContext) TRIM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRIM, 0)
}

func (s *ColumnExprTrimContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprTrimContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ColumnExprTrimContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *ColumnExprTrimContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprTrimContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprTrimContext) BOTH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBOTH, 0)
}

func (s *ColumnExprTrimContext) LEADING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEADING, 0)
}

func (s *ColumnExprTrimContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRAILING, 0)
}

func (s *ColumnExprTrimContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTrim(s)
	}
}

func (s *ColumnExprTrimContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTrim(s)
	}
}

type ColumnExprTupleContext struct {
	ColumnExprContext
}

func NewColumnExprTupleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTupleContext {
	var p = new(ColumnExprTupleContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTupleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprTupleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprTupleContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTuple(s)
	}
}

func (s *ColumnExprTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTuple(s)
	}
}

type ColumnExprArrayAccessContext struct {
	ColumnExprContext
}

func NewColumnExprArrayAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprArrayAccessContext {
	var p = new(ColumnExprArrayAccessContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprArrayAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprArrayAccessContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprArrayAccessContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprArrayAccessContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLBRACKET, 0)
}

func (s *ColumnExprArrayAccessContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRBRACKET, 0)
}

func (s *ColumnExprArrayAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprArrayAccess(s)
	}
}

func (s *ColumnExprArrayAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprArrayAccess(s)
	}
}

type ColumnExprBetweenContext struct {
	ColumnExprContext
}

func NewColumnExprBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprBetweenContext {
	var p = new(ColumnExprBetweenContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprBetweenContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprBetweenContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBETWEEN, 0)
}

func (s *ColumnExprBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAND, 0)
}

func (s *ColumnExprBetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ColumnExprBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprBetween(s)
	}
}

func (s *ColumnExprBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprBetween(s)
	}
}

type ColumnExprParensContext struct {
	ColumnExprContext
}

func NewColumnExprParensContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprParensContext {
	var p = new(ColumnExprParensContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprParensContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExprParensContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprParensContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExprParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprParens(s)
	}
}

func (s *ColumnExprParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprParens(s)
	}
}

type ColumnExprTimestampContext struct {
	ColumnExprContext
}

func NewColumnExprTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTimestampContext {
	var p = new(ColumnExprTimestampContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTimestampContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMESTAMP, 0)
}

func (s *ColumnExprTimestampContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ColumnExprTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTimestamp(s)
	}
}

func (s *ColumnExprTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTimestamp(s)
	}
}

type ColumnExprAndContext struct {
	ColumnExprContext
}

func NewColumnExprAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprAndContext {
	var p = new(ColumnExprAndContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprAndContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprAndContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprAndContext) AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAND, 0)
}

func (s *ColumnExprAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprAnd(s)
	}
}

func (s *ColumnExprAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprAnd(s)
	}
}

type ColumnExprTupleAccessContext struct {
	ColumnExprContext
}

func NewColumnExprTupleAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprTupleAccessContext {
	var p = new(ColumnExprTupleAccessContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprTupleAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprTupleAccessContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprTupleAccessContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *ColumnExprTupleAccessContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *ColumnExprTupleAccessContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ColumnExprTupleAccessContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprTupleAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprTupleAccess(s)
	}
}

func (s *ColumnExprTupleAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprTupleAccess(s)
	}
}

type ColumnExprCaseContext struct {
	ColumnExprContext
}

func NewColumnExprCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprCaseContext {
	var p = new(ColumnExprCaseContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCASE, 0)
}

func (s *ColumnExprCaseContext) END() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEND, 0)
}

func (s *ColumnExprCaseContext) AllColumnExpr() []IColumnExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnExprContext); ok {
			tst[i] = t.(IColumnExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExprCaseContext) ColumnExpr(i int) IColumnExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprCaseContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserWHEN)
}

func (s *ColumnExprCaseContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHEN, i)
}

func (s *ColumnExprCaseContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserTHEN)
}

func (s *ColumnExprCaseContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTHEN, i)
}

func (s *ColumnExprCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserELSE, 0)
}

func (s *ColumnExprCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprCase(s)
	}
}

func (s *ColumnExprCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprCase(s)
	}
}

type ColumnExprDateContext struct {
	ColumnExprContext
}

func NewColumnExprDateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprDateContext {
	var p = new(ColumnExprDateContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprDateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprDateContext) DATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATE, 0)
}

func (s *ColumnExprDateContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ColumnExprDateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprDate(s)
	}
}

func (s *ColumnExprDateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprDate(s)
	}
}

type ColumnExprNotContext struct {
	ColumnExprContext
}

func NewColumnExprNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprNotContext {
	var p = new(ColumnExprNotContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *ColumnExprNotContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnExprNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprNot(s)
	}
}

func (s *ColumnExprNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprNot(s)
	}
}

type ColumnExprWinFunctionContext struct {
	ColumnExprContext
}

func NewColumnExprWinFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprWinFunctionContext {
	var p = new(ColumnExprWinFunctionContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprWinFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprWinFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprWinFunctionContext) OVER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOVER, 0)
}

func (s *ColumnExprWinFunctionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *ColumnExprWinFunctionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *ColumnExprWinFunctionContext) WindowExpr() IWindowExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowExprContext)
}

func (s *ColumnExprWinFunctionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserRPAREN)
}

func (s *ColumnExprWinFunctionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, i)
}

func (s *ColumnExprWinFunctionContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprWinFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprWinFunction(s)
	}
}

func (s *ColumnExprWinFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprWinFunction(s)
	}
}

type ColumnExprIdentifierContext struct {
	ColumnExprContext
}

func NewColumnExprIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprIdentifierContext {
	var p = new(ColumnExprIdentifierContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprIdentifierContext) ColumnIdentifier() IColumnIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnIdentifierContext)
}

func (s *ColumnExprIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprIdentifier(s)
	}
}

func (s *ColumnExprIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprIdentifier(s)
	}
}

type ColumnExprFunctionContext struct {
	ColumnExprContext
}

func NewColumnExprFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprFunctionContext {
	var p = new(ColumnExprFunctionContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExprFunctionContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserLPAREN)
}

func (s *ColumnExprFunctionContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, i)
}

func (s *ColumnExprFunctionContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserRPAREN)
}

func (s *ColumnExprFunctionContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, i)
}

func (s *ColumnExprFunctionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTINCT, 0)
}

func (s *ColumnExprFunctionContext) ColumnArgList() IColumnArgListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnArgListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnArgListContext)
}

func (s *ColumnExprFunctionContext) ColumnExprList() IColumnExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprListContext)
}

func (s *ColumnExprFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprFunction(s)
	}
}

func (s *ColumnExprFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprFunction(s)
	}
}

type ColumnExprAsteriskContext struct {
	ColumnExprContext
}

func NewColumnExprAsteriskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExprAsteriskContext {
	var p = new(ColumnExprAsteriskContext)

	InitEmptyColumnExprContext(&p.ColumnExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExprContext))

	return p
}

func (s *ColumnExprAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExprAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASTERISK, 0)
}

func (s *ColumnExprAsteriskContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ColumnExprAsteriskContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *ColumnExprAsteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExprAsterisk(s)
	}
}

func (s *ColumnExprAsteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExprAsterisk(s)
	}
}

func (p *ClickHouseParser) ColumnExpr() (localctx IColumnExprContext) {
	return p.columnExpr(0)
}

func (p *ClickHouseParser) columnExpr(_p int) (localctx IColumnExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewColumnExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IColumnExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 200
	p.EnterRecursionRule(localctx, 200, ClickHouseParserRULE_columnExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnExprCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(2069)
			p.Match(ClickHouseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2071)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2070)
				p.columnExpr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == ClickHouseParserWHEN {
			{
				p.SetState(2073)
				p.Match(ClickHouseParserWHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2074)
				p.columnExpr(0)
			}
			{
				p.SetState(2075)
				p.Match(ClickHouseParserTHEN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2076)
				p.columnExpr(0)
			}

			p.SetState(2080)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserELSE {
			{
				p.SetState(2082)
				p.Match(ClickHouseParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2083)
				p.columnExpr(0)
			}

		}
		{
			p.SetState(2086)
			p.Match(ClickHouseParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewColumnExprCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2088)
			p.Match(ClickHouseParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2089)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2090)
			p.columnExpr(0)
		}
		{
			p.SetState(2091)
			p.Match(ClickHouseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2092)
			p.ColumnTypeExpr()
		}
		{
			p.SetState(2093)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewColumnExprDateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2095)
			p.Match(ClickHouseParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2096)
			p.StringLiteral()
		}

	case 4:
		localctx = NewColumnExprExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2097)
			p.Match(ClickHouseParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2098)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2099)
			p.Interval()
		}
		{
			p.SetState(2100)
			p.Match(ClickHouseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2101)
			p.columnExpr(0)
		}
		{
			p.SetState(2102)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewColumnExprIntervalContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2104)
			p.Match(ClickHouseParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2105)
			p.columnExpr(0)
		}
		{
			p.SetState(2106)
			p.Interval()
		}

	case 6:
		localctx = NewColumnExprSubstringContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2108)
			p.Match(ClickHouseParserSUBSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2109)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2110)
			p.columnExpr(0)
		}
		{
			p.SetState(2111)
			p.Match(ClickHouseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2112)
			p.columnExpr(0)
		}
		p.SetState(2115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ClickHouseParserFOR {
			{
				p.SetState(2113)
				p.Match(ClickHouseParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2114)
				p.columnExpr(0)
			}

		}
		{
			p.SetState(2117)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewColumnExprTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2119)
			p.Match(ClickHouseParserTIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2120)
			p.StringLiteral()
		}

	case 8:
		localctx = NewColumnExprTrimContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2121)
			p.Match(ClickHouseParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2122)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2123)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserBOTH || _la == ClickHouseParserLEADING || _la == ClickHouseParserTRAILING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2124)
			p.StringLiteral()
		}
		{
			p.SetState(2125)
			p.Match(ClickHouseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2126)
			p.columnExpr(0)
		}
		{
			p.SetState(2127)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewColumnExprNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2129)
			p.Match(ClickHouseParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2130)
			p.columnExpr(22)
		}

	case 10:
		localctx = NewColumnExprWinFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2131)
			p.Identifier()
		}

		{
			p.SetState(2132)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2134)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4557642822898941953) != 0) || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&69) != 0) {
			{
				p.SetState(2133)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(2136)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(2138)
			p.Match(ClickHouseParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2139)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2140)
			p.WindowExpr()
		}
		{
			p.SetState(2141)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewColumnExprWinFunctionTargetContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2143)
			p.Identifier()
		}

		{
			p.SetState(2144)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2146)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4557642822898941953) != 0) || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&69) != 0) {
			{
				p.SetState(2145)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(2148)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(2150)
			p.Match(ClickHouseParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2151)
			p.Identifier()
		}

	case 12:
		localctx = NewColumnExprFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2153)
			p.Identifier()
		}
		p.SetState(2159)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2154)
				p.Match(ClickHouseParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2156)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4557642822898941953) != 0) || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&69) != 0) {
				{
					p.SetState(2155)
					p.ColumnExprList()
				}

			}
			{
				p.SetState(2158)
				p.Match(ClickHouseParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2161)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2163)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2162)
				p.Match(ClickHouseParserDISTINCT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4557642822898941953) != 0) || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&69) != 0) {
			{
				p.SetState(2165)
				p.ColumnArgList()
			}

		}
		{
			p.SetState(2168)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewColumnExprLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2170)
			p.Literal()
		}

	case 14:
		localctx = NewColumnExprNegateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2171)
			p.Match(ClickHouseParserDASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2172)
			p.columnExpr(15)
		}

	case 15:
		localctx = NewColumnExprAsteriskContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(2176)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-137438953473) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606851329) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&175921860444159) != 0) {
			{
				p.SetState(2173)
				p.TableIdentifier()
			}
			{
				p.SetState(2174)
				p.Match(ClickHouseParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2178)
			p.Match(ClickHouseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewColumnExprSubqueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2179)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2180)
			p.SelectUnionStmt()
		}
		{
			p.SetState(2181)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewColumnExprParensContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2183)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2184)
			p.columnExpr(0)
		}
		{
			p.SetState(2185)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewColumnExprTupleContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2187)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2189)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4557642822898941953) != 0) || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&69) != 0) {
			{
				p.SetState(2188)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(2191)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewColumnExprArrayContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2192)
			p.Match(ClickHouseParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4557642822898941953) != 0) || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&69) != 0) {
			{
				p.SetState(2193)
				p.ColumnExprList()
			}

		}
		{
			p.SetState(2196)
			p.Match(ClickHouseParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewColumnExprIdentifierContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2197)
			p.ColumnIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 310, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2276)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) {
			case 1:
				localctx = NewColumnExprBetweenContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2200)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				p.SetState(2202)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == ClickHouseParserNOT {
					{
						p.SetState(2201)
						p.Match(ClickHouseParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(2204)
					p.Match(ClickHouseParserBETWEEN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2205)
					p.columnExpr(0)
				}
				{
					p.SetState(2206)
					p.Match(ClickHouseParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2207)
					p.columnExpr(24)
				}

			case 2:
				localctx = NewColumnExprPrecedence1Context(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2209)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(2210)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-247)) & ^0x3f) == 0 && ((int64(1)<<(_la-247))&268959745) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2211)
					p.columnExpr(15)
				}

			case 3:
				localctx = NewColumnExprPrecedence2Context(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2212)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(2213)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-253)) & ^0x3f) == 0 && ((int64(1)<<(_la-253))&16387) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2214)
					p.columnExpr(14)
				}

			case 4:
				localctx = NewColumnExprPrecedence3Context(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2215)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				p.SetState(2234)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(2216)
						p.Match(ClickHouseParserEQ_DOUBLE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					{
						p.SetState(2217)
						p.Match(ClickHouseParserEQ_SINGLE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 3:
					{
						p.SetState(2218)
						p.Match(ClickHouseParserNOT_EQ)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 4:
					{
						p.SetState(2219)
						p.Match(ClickHouseParserLE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 5:
					{
						p.SetState(2220)
						p.Match(ClickHouseParserGE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 6:
					{
						p.SetState(2221)
						p.Match(ClickHouseParserLT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 7:
					{
						p.SetState(2222)
						p.Match(ClickHouseParserGT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 8:
					p.SetState(2224)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == ClickHouseParserGLOBAL {
						{
							p.SetState(2223)
							p.Match(ClickHouseParserGLOBAL)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					p.SetState(2227)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == ClickHouseParserNOT {
						{
							p.SetState(2226)
							p.Match(ClickHouseParserNOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(2229)
						p.Match(ClickHouseParserIN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 9:
					p.SetState(2231)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == ClickHouseParserNOT {
						{
							p.SetState(2230)
							p.Match(ClickHouseParserNOT)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(2233)
						_la = p.GetTokenStream().LA(1)

						if !(_la == ClickHouseParserILIKE || _la == ClickHouseParserLIKE) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				{
					p.SetState(2236)
					p.columnExpr(13)
				}

			case 5:
				localctx = NewColumnExprAndContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2237)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(2238)
					p.Match(ClickHouseParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2239)
					p.columnExpr(11)
				}

			case 6:
				localctx = NewColumnExprOrContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2240)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(2241)
					p.Match(ClickHouseParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2242)
					p.columnExpr(10)
				}

			case 7:
				localctx = NewColumnExprTernaryOpContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2243)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(2244)
					p.Match(ClickHouseParserQUERY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2245)
					p.columnExpr(0)
				}
				{
					p.SetState(2246)
					p.Match(ClickHouseParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2247)
					p.columnExpr(8)
				}

			case 8:
				localctx = NewColumnExprCastSymbolContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2249)

				if !(p.Precpred(p.GetParserRuleContext(), 30)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 30)", ""))
					goto errorExit
				}
				{
					p.SetState(2250)
					p.Match(ClickHouseParserDOUBLE_COLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2251)
					p.ColumnTypeExpr()
				}

			case 9:
				localctx = NewColumnExprArrayAccessContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2252)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(2253)
					p.Match(ClickHouseParserLBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2254)
					p.columnExpr(0)
				}
				{
					p.SetState(2255)
					p.Match(ClickHouseParserRBRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 10:
				localctx = NewColumnExprTupleAccessContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2257)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(2258)
					p.Match(ClickHouseParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2262)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case ClickHouseParserDECIMAL_LITERAL:
					{
						p.SetState(2259)
						p.Match(ClickHouseParserDECIMAL_LITERAL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case ClickHouseParserHEXADECIMAL_STRING_LITERAL, ClickHouseParserBINARY_STRING_LITERAL, ClickHouseParserSTRING_LITERAL:
					{
						p.SetState(2260)
						p.StringLiteral()
					}

				case ClickHouseParserACCESS, ClickHouseParserADD, ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCACHES, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCLUSTERS, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOLUMNS, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserCURRENT, ClickHouseParserCURRENT_USER, ClickHouseParserCHANGED, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDAY, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserENABLED, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserENGINES, ClickHouseParserESTIMATE, ClickHouseParserEVENTS, ClickHouseParserEXCEPT, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTENDED, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFIELDS, ClickHouseParserFILESYSTEM, ClickHouseParserFILL, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOLLOWING, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserFUNCTIONS, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGRANTS, ClickHouseParserGROUP, ClickHouseParserGROUPING, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserHOUR, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIMPLICIT, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINDEXES, ClickHouseParserINDICES, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERPOLATE, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKEYS, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMICROSECOND, ClickHouseParserMILLISECOND, ClickHouseParserMIN, ClickHouseParserMINUTE, ClickHouseParserMODIFY, ClickHouseParserMONTH, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNANOSECOND, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserOVER, ClickHouseParserOVERRIDE, ClickHouseParserPARTITION, ClickHouseParserPIPELINE, ClickHouseParserPLAN, ClickHouseParserPOLICY, ClickHouseParserPOLICIES, ClickHouseParserPOPULATE, ClickHouseParserPRECEDING, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserPRIVILEGES, ClickHouseParserPROCESSLIST, ClickHouseParserPROFILE, ClickHouseParserPROFILES, ClickHouseParserPROJECTION, ClickHouseParserQUARTER, ClickHouseParserQUOTA, ClickHouseParserQUOTAS, ClickHouseParserRANGE, ClickHouseParserRECURSIVE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLE, ClickHouseParserROLES, ClickHouseParserROLLUP, ClickHouseParserROW, ClickHouseParserROWS, ClickHouseParserSAMPLE, ClickHouseParserSECOND, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTING, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserSTEP, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTREE, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNBOUNDED, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSER, ClickHouseParserUSERS, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWEEK, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWINDOW, ClickHouseParserWITH, ClickHouseParserYEAR, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE, ClickHouseParserIDENTIFIER:
					{
						p.SetState(2261)
						p.Identifier()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 11:
				localctx = NewColumnExprIsNullContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2264)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(2265)
					p.Match(ClickHouseParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2267)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == ClickHouseParserNOT {
					{
						p.SetState(2266)
						p.Match(ClickHouseParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(2269)
					p.Match(ClickHouseParserNULL_SQL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 12:
				localctx = NewColumnExprAliasContext(p, NewColumnExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_columnExpr)
				p.SetState(2270)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				p.SetState(2274)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALTER, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBOTH, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCODEC, ClickHouseParserCOLUMN, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCUBE, ClickHouseParserCURRENT, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserENGINE, ClickHouseParserEVENTS, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFLUSH, ClickHouseParserFOLLOWING, ClickHouseParserFREEZE, ClickHouseParserFUNCTION, ClickHouseParserGRANULARITY, ClickHouseParserHIERARCHICAL, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserINDEX, ClickHouseParserINJECTIVE, ClickHouseParserINSERT, ClickHouseParserIS_OBJECT_ID, ClickHouseParserKEY, ClickHouseParserKILL, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLIFETIME, ClickHouseParserLIVE, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMIN, ClickHouseParserMODIFY, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNO, ClickHouseParserOPTIMIZE, ClickHouseParserOUTFILE, ClickHouseParserOVER, ClickHouseParserPARTITION, ClickHouseParserPOPULATE, ClickHouseParserPRECEDING, ClickHouseParserPRIMARY, ClickHouseParserRANGE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserROLLUP, ClickHouseParserROW, ClickHouseParserSELECT, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNBOUNDED, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserIDENTIFIER:
					{
						p.SetState(2271)
						p.Alias()
					}

				case ClickHouseParserAS:
					{
						p.SetState(2272)
						p.Match(ClickHouseParserAS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(2273)
						p.Identifier()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 310, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnArgListContext is an interface to support dynamic dispatch.
type IColumnArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnArgExpr() []IColumnArgExprContext
	ColumnArgExpr(i int) IColumnArgExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnArgListContext differentiates from other interfaces.
	IsColumnArgListContext()
}

type ColumnArgListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnArgListContext() *ColumnArgListContext {
	var p = new(ColumnArgListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnArgList
	return p
}

func InitEmptyColumnArgListContext(p *ColumnArgListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnArgList
}

func (*ColumnArgListContext) IsColumnArgListContext() {}

func NewColumnArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnArgListContext {
	var p = new(ColumnArgListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnArgList

	return p
}

func (s *ColumnArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnArgListContext) AllColumnArgExpr() []IColumnArgExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnArgExprContext); ok {
			len++
		}
	}

	tst := make([]IColumnArgExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnArgExprContext); ok {
			tst[i] = t.(IColumnArgExprContext)
			i++
		}
	}

	return tst
}

func (s *ColumnArgListContext) ColumnArgExpr(i int) IColumnArgExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnArgExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnArgExprContext)
}

func (s *ColumnArgListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnArgListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnArgList(s)
	}
}

func (s *ColumnArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnArgList(s)
	}
}

func (p *ClickHouseParser) ColumnArgList() (localctx IColumnArgListContext) {
	localctx = NewColumnArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ClickHouseParserRULE_columnArgList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2281)
		p.ColumnArgExpr()
	}
	p.SetState(2286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(2282)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2283)
			p.ColumnArgExpr()
		}

		p.SetState(2288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnArgExprContext is an interface to support dynamic dispatch.
type IColumnArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnLambdaExpr() IColumnLambdaExprContext
	ColumnExpr() IColumnExprContext

	// IsColumnArgExprContext differentiates from other interfaces.
	IsColumnArgExprContext()
}

type ColumnArgExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnArgExprContext() *ColumnArgExprContext {
	var p = new(ColumnArgExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnArgExpr
	return p
}

func InitEmptyColumnArgExprContext(p *ColumnArgExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnArgExpr
}

func (*ColumnArgExprContext) IsColumnArgExprContext() {}

func NewColumnArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnArgExprContext {
	var p = new(ColumnArgExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnArgExpr

	return p
}

func (s *ColumnArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnArgExprContext) ColumnLambdaExpr() IColumnLambdaExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnLambdaExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnLambdaExprContext)
}

func (s *ColumnArgExprContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnArgExpr(s)
	}
}

func (s *ColumnArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnArgExpr(s)
	}
}

func (p *ClickHouseParser) ColumnArgExpr() (localctx IColumnArgExprContext) {
	localctx = NewColumnArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ClickHouseParserRULE_columnArgExpr)
	p.SetState(2291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2289)
			p.ColumnLambdaExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2290)
			p.columnExpr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnLambdaExprContext is an interface to support dynamic dispatch.
type IColumnLambdaExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARROW() antlr.TerminalNode
	ColumnExpr() IColumnExprContext
	LPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnLambdaExprContext differentiates from other interfaces.
	IsColumnLambdaExprContext()
}

type ColumnLambdaExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnLambdaExprContext() *ColumnLambdaExprContext {
	var p = new(ColumnLambdaExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnLambdaExpr
	return p
}

func InitEmptyColumnLambdaExprContext(p *ColumnLambdaExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnLambdaExpr
}

func (*ColumnLambdaExprContext) IsColumnLambdaExprContext() {}

func NewColumnLambdaExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnLambdaExprContext {
	var p = new(ColumnLambdaExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnLambdaExpr

	return p
}

func (s *ColumnLambdaExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnLambdaExprContext) ARROW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserARROW, 0)
}

func (s *ColumnLambdaExprContext) ColumnExpr() IColumnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnExprContext)
}

func (s *ColumnLambdaExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnLambdaExprContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnLambdaExprContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnLambdaExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnLambdaExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnLambdaExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnLambdaExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnLambdaExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnLambdaExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnLambdaExpr(s)
	}
}

func (s *ColumnLambdaExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnLambdaExpr(s)
	}
}

func (p *ClickHouseParser) ColumnLambdaExpr() (localctx IColumnLambdaExprContext) {
	localctx = NewColumnLambdaExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ClickHouseParserRULE_columnLambdaExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserLPAREN:
		{
			p.SetState(2293)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2294)
			p.Identifier()
		}
		p.SetState(2299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(2295)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2296)
				p.Identifier()
			}

			p.SetState(2301)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2302)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ClickHouseParserACCESS, ClickHouseParserADD, ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCACHES, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCLUSTERS, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOLUMNS, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserCURRENT, ClickHouseParserCURRENT_USER, ClickHouseParserCHANGED, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDAY, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserENABLED, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserENGINES, ClickHouseParserESTIMATE, ClickHouseParserEVENTS, ClickHouseParserEXCEPT, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTENDED, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFIELDS, ClickHouseParserFILESYSTEM, ClickHouseParserFILL, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOLLOWING, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserFUNCTIONS, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGRANTS, ClickHouseParserGROUP, ClickHouseParserGROUPING, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserHOUR, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIMPLICIT, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINDEXES, ClickHouseParserINDICES, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERPOLATE, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKEYS, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMICROSECOND, ClickHouseParserMILLISECOND, ClickHouseParserMIN, ClickHouseParserMINUTE, ClickHouseParserMODIFY, ClickHouseParserMONTH, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNANOSECOND, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserOVER, ClickHouseParserOVERRIDE, ClickHouseParserPARTITION, ClickHouseParserPIPELINE, ClickHouseParserPLAN, ClickHouseParserPOLICY, ClickHouseParserPOLICIES, ClickHouseParserPOPULATE, ClickHouseParserPRECEDING, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserPRIVILEGES, ClickHouseParserPROCESSLIST, ClickHouseParserPROFILE, ClickHouseParserPROFILES, ClickHouseParserPROJECTION, ClickHouseParserQUARTER, ClickHouseParserQUOTA, ClickHouseParserQUOTAS, ClickHouseParserRANGE, ClickHouseParserRECURSIVE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLE, ClickHouseParserROLES, ClickHouseParserROLLUP, ClickHouseParserROW, ClickHouseParserROWS, ClickHouseParserSAMPLE, ClickHouseParserSECOND, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTING, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserSTEP, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTREE, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNBOUNDED, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSER, ClickHouseParserUSERS, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWEEK, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWINDOW, ClickHouseParserWITH, ClickHouseParserYEAR, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE, ClickHouseParserIDENTIFIER:
		{
			p.SetState(2304)
			p.Identifier()
		}
		p.SetState(2309)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ClickHouseParserCOMMA {
			{
				p.SetState(2305)
				p.Match(ClickHouseParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2306)
				p.Identifier()
			}

			p.SetState(2311)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2314)
		p.Match(ClickHouseParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2315)
		p.columnExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnIdentifierContext is an interface to support dynamic dispatch.
type IColumnIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedIdentifier() INestedIdentifierContext
	TableIdentifier() ITableIdentifierContext
	DOT() antlr.TerminalNode

	// IsColumnIdentifierContext differentiates from other interfaces.
	IsColumnIdentifierContext()
}

type ColumnIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnIdentifierContext() *ColumnIdentifierContext {
	var p = new(ColumnIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnIdentifier
	return p
}

func InitEmptyColumnIdentifierContext(p *ColumnIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnIdentifier
}

func (*ColumnIdentifierContext) IsColumnIdentifierContext() {}

func NewColumnIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnIdentifierContext {
	var p = new(ColumnIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnIdentifier

	return p
}

func (s *ColumnIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnIdentifierContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *ColumnIdentifierContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *ColumnIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *ColumnIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnIdentifier(s)
	}
}

func (s *ColumnIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnIdentifier(s)
	}
}

func (p *ClickHouseParser) ColumnIdentifier() (localctx IColumnIdentifierContext) {
	localctx = NewColumnIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ClickHouseParserRULE_columnIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2320)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2317)
			p.TableIdentifier()
		}
		{
			p.SetState(2318)
			p.Match(ClickHouseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2322)
		p.NestedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedIdentifierContext is an interface to support dynamic dispatch.
type INestedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsNestedIdentifierContext differentiates from other interfaces.
	IsNestedIdentifierContext()
}

type NestedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedIdentifierContext() *NestedIdentifierContext {
	var p = new(NestedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_nestedIdentifier
	return p
}

func InitEmptyNestedIdentifierContext(p *NestedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_nestedIdentifier
}

func (*NestedIdentifierContext) IsNestedIdentifierContext() {}

func NewNestedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedIdentifierContext {
	var p = new(NestedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_nestedIdentifier

	return p
}

func (s *NestedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedIdentifierContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *NestedIdentifierContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NestedIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserDOT)
}

func (s *NestedIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, i)
}

func (s *NestedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterNestedIdentifier(s)
	}
}

func (s *NestedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitNestedIdentifier(s)
	}
}

func (p *ClickHouseParser) NestedIdentifier() (localctx INestedIdentifierContext) {
	localctx = NewNestedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ClickHouseParserRULE_nestedIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2324)
		p.Identifier()
	}
	p.SetState(2329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2325)
				p.Match(ClickHouseParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2326)
				p.Identifier()
			}

		}
		p.SetState(2331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnExceptExprContext is an interface to support dynamic dispatch.
type IColumnExceptExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsColumnExceptExprContext differentiates from other interfaces.
	IsColumnExceptExprContext()
}

type ColumnExceptExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnExceptExprContext() *ColumnExceptExprContext {
	var p = new(ColumnExceptExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnExceptExpr
	return p
}

func InitEmptyColumnExceptExprContext(p *ColumnExceptExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_columnExceptExpr
}

func (*ColumnExceptExprContext) IsColumnExceptExprContext() {}

func NewColumnExceptExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnExceptExprContext {
	var p = new(ColumnExceptExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_columnExceptExpr

	return p
}

func (s *ColumnExceptExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnExceptExprContext) CopyAll(ctx *ColumnExceptExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ColumnExceptExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExceptExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ColumnExceptExprRegexpContext struct {
	ColumnExceptExprContext
}

func NewColumnExceptExprRegexpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExceptExprRegexpContext {
	var p = new(ColumnExceptExprRegexpContext)

	InitEmptyColumnExceptExprContext(&p.ColumnExceptExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExceptExprContext))

	return p
}

func (s *ColumnExceptExprRegexpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExceptExprRegexpContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXCEPT, 0)
}

func (s *ColumnExceptExprRegexpContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ColumnExceptExprRegexpContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExceptExprRegexpContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExceptExprRegexpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExceptExprRegexp(s)
	}
}

func (s *ColumnExceptExprRegexpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExceptExprRegexp(s)
	}
}

type ColumnExceptExprIdentifiersContext struct {
	ColumnExceptExprContext
}

func NewColumnExceptExprIdentifiersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnExceptExprIdentifiersContext {
	var p = new(ColumnExceptExprIdentifiersContext)

	InitEmptyColumnExceptExprContext(&p.ColumnExceptExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ColumnExceptExprContext))

	return p
}

func (s *ColumnExceptExprIdentifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnExceptExprIdentifiersContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXCEPT, 0)
}

func (s *ColumnExceptExprIdentifiersContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnExceptExprIdentifiersContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnExceptExprIdentifiersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *ColumnExceptExprIdentifiersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *ColumnExceptExprIdentifiersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *ColumnExceptExprIdentifiersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *ColumnExceptExprIdentifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterColumnExceptExprIdentifiers(s)
	}
}

func (s *ColumnExceptExprIdentifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitColumnExceptExprIdentifiers(s)
	}
}

func (p *ClickHouseParser) ColumnExceptExpr() (localctx IColumnExceptExprContext) {
	localctx = NewColumnExceptExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ClickHouseParserRULE_columnExceptExpr)
	var _la int

	p.SetState(2355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext()) {
	case 1:
		localctx = NewColumnExceptExprRegexpContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2332)
			p.Match(ClickHouseParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserHEXADECIMAL_STRING_LITERAL, ClickHouseParserBINARY_STRING_LITERAL, ClickHouseParserSTRING_LITERAL:
			{
				p.SetState(2333)
				p.StringLiteral()
			}

		case ClickHouseParserLPAREN:
			{
				p.SetState(2334)
				p.Match(ClickHouseParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2335)
				p.StringLiteral()
			}
			{
				p.SetState(2336)
				p.Match(ClickHouseParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewColumnExceptExprIdentifiersContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2340)
			p.Match(ClickHouseParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ClickHouseParserACCESS, ClickHouseParserADD, ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCACHES, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCLUSTERS, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOLUMNS, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserCURRENT, ClickHouseParserCURRENT_USER, ClickHouseParserCHANGED, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDAY, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserENABLED, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserENGINES, ClickHouseParserESTIMATE, ClickHouseParserEVENTS, ClickHouseParserEXCEPT, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTENDED, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFIELDS, ClickHouseParserFILESYSTEM, ClickHouseParserFILL, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOLLOWING, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserFUNCTIONS, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGRANTS, ClickHouseParserGROUP, ClickHouseParserGROUPING, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserHOUR, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIMPLICIT, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINDEXES, ClickHouseParserINDICES, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERPOLATE, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKEYS, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMICROSECOND, ClickHouseParserMILLISECOND, ClickHouseParserMIN, ClickHouseParserMINUTE, ClickHouseParserMODIFY, ClickHouseParserMONTH, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNANOSECOND, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserOVER, ClickHouseParserOVERRIDE, ClickHouseParserPARTITION, ClickHouseParserPIPELINE, ClickHouseParserPLAN, ClickHouseParserPOLICY, ClickHouseParserPOLICIES, ClickHouseParserPOPULATE, ClickHouseParserPRECEDING, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserPRIVILEGES, ClickHouseParserPROCESSLIST, ClickHouseParserPROFILE, ClickHouseParserPROFILES, ClickHouseParserPROJECTION, ClickHouseParserQUARTER, ClickHouseParserQUOTA, ClickHouseParserQUOTAS, ClickHouseParserRANGE, ClickHouseParserRECURSIVE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLE, ClickHouseParserROLES, ClickHouseParserROLLUP, ClickHouseParserROW, ClickHouseParserROWS, ClickHouseParserSAMPLE, ClickHouseParserSECOND, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTING, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserSTEP, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTREE, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNBOUNDED, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSER, ClickHouseParserUSERS, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWEEK, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWINDOW, ClickHouseParserWITH, ClickHouseParserYEAR, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE, ClickHouseParserIDENTIFIER:
			{
				p.SetState(2341)
				p.Identifier()
			}

		case ClickHouseParserLPAREN:
			{
				p.SetState(2342)
				p.Match(ClickHouseParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2343)
				p.Identifier()
			}
			p.SetState(2348)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ClickHouseParserCOMMA {
				{
					p.SetState(2344)
					p.Match(ClickHouseParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2345)
					p.Identifier()
				}

				p.SetState(2350)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2351)
				p.Match(ClickHouseParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableExprContext is an interface to support dynamic dispatch.
type ITableExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTableExprContext differentiates from other interfaces.
	IsTableExprContext()
}

type TableExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableExprContext() *TableExprContext {
	var p = new(TableExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableExpr
	return p
}

func InitEmptyTableExprContext(p *TableExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableExpr
}

func (*TableExprContext) IsTableExprContext() {}

func NewTableExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableExprContext {
	var p = new(TableExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableExpr

	return p
}

func (s *TableExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableExprContext) CopyAll(ctx *TableExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableExprIdentifierContext struct {
	TableExprContext
}

func NewTableExprIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprIdentifierContext {
	var p = new(TableExprIdentifierContext)

	InitEmptyTableExprContext(&p.TableExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableExprContext))

	return p
}

func (s *TableExprIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprIdentifierContext) TableIdentifier() ITableIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableIdentifierContext)
}

func (s *TableExprIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableExprIdentifier(s)
	}
}

func (s *TableExprIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableExprIdentifier(s)
	}
}

type TableExprSubqueryContext struct {
	TableExprContext
}

func NewTableExprSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprSubqueryContext {
	var p = new(TableExprSubqueryContext)

	InitEmptyTableExprContext(&p.TableExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableExprContext))

	return p
}

func (s *TableExprSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprSubqueryContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *TableExprSubqueryContext) SelectUnionStmt() ISelectUnionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectUnionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectUnionStmtContext)
}

func (s *TableExprSubqueryContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *TableExprSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableExprSubquery(s)
	}
}

func (s *TableExprSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableExprSubquery(s)
	}
}

type TableExprAliasContext struct {
	TableExprContext
}

func NewTableExprAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprAliasContext {
	var p = new(TableExprAliasContext)

	InitEmptyTableExprContext(&p.TableExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableExprContext))

	return p
}

func (s *TableExprAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprAliasContext) TableExpr() ITableExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableExprContext)
}

func (s *TableExprAliasContext) Alias() IAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *TableExprAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *TableExprAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableExprAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableExprAlias(s)
	}
}

func (s *TableExprAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableExprAlias(s)
	}
}

type TableExprFunctionContext struct {
	TableExprContext
}

func NewTableExprFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableExprFunctionContext {
	var p = new(TableExprFunctionContext)

	InitEmptyTableExprContext(&p.TableExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*TableExprContext))

	return p
}

func (s *TableExprFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableExprFunctionContext) TableFunctionExpr() ITableFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *TableExprFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableExprFunction(s)
	}
}

func (s *TableExprFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableExprFunction(s)
	}
}

func (p *ClickHouseParser) TableExpr() (localctx ITableExprContext) {
	return p.tableExpr(0)
}

func (p *ClickHouseParser) tableExpr(_p int) (localctx ITableExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTableExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITableExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 214
	p.EnterRecursionRule(localctx, 214, ClickHouseParserRULE_tableExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableExprIdentifierContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(2358)
			p.TableIdentifier()
		}

	case 2:
		localctx = NewTableExprFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2359)
			p.TableFunctionExpr()
		}

	case 3:
		localctx = NewTableExprSubqueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(2360)
			p.Match(ClickHouseParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2361)
			p.SelectUnionStmt()
		}
		{
			p.SetState(2362)
			p.Match(ClickHouseParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTableExprAliasContext(p, NewTableExprContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, ClickHouseParserRULE_tableExpr)
			p.SetState(2366)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			p.SetState(2370)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALTER, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBOTH, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCODEC, ClickHouseParserCOLUMN, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCUBE, ClickHouseParserCURRENT, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserENGINE, ClickHouseParserEVENTS, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFLUSH, ClickHouseParserFOLLOWING, ClickHouseParserFREEZE, ClickHouseParserFUNCTION, ClickHouseParserGRANULARITY, ClickHouseParserHIERARCHICAL, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserINDEX, ClickHouseParserINJECTIVE, ClickHouseParserINSERT, ClickHouseParserIS_OBJECT_ID, ClickHouseParserKEY, ClickHouseParserKILL, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLIFETIME, ClickHouseParserLIVE, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMIN, ClickHouseParserMODIFY, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNO, ClickHouseParserOPTIMIZE, ClickHouseParserOUTFILE, ClickHouseParserOVER, ClickHouseParserPARTITION, ClickHouseParserPOPULATE, ClickHouseParserPRECEDING, ClickHouseParserPRIMARY, ClickHouseParserRANGE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserROLLUP, ClickHouseParserROW, ClickHouseParserSELECT, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNBOUNDED, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserIDENTIFIER:
				{
					p.SetState(2367)
					p.Alias()
				}

			case ClickHouseParserAS:
				{
					p.SetState(2368)
					p.Match(ClickHouseParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2369)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(2376)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableFunctionExprContext is an interface to support dynamic dispatch.
type ITableFunctionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TableArgList() ITableArgListContext

	// IsTableFunctionExprContext differentiates from other interfaces.
	IsTableFunctionExprContext()
}

type TableFunctionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFunctionExprContext() *TableFunctionExprContext {
	var p = new(TableFunctionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableFunctionExpr
	return p
}

func InitEmptyTableFunctionExprContext(p *TableFunctionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableFunctionExpr
}

func (*TableFunctionExprContext) IsTableFunctionExprContext() {}

func NewTableFunctionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFunctionExprContext {
	var p = new(TableFunctionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableFunctionExpr

	return p
}

func (s *TableFunctionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFunctionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableFunctionExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLPAREN, 0)
}

func (s *TableFunctionExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRPAREN, 0)
}

func (s *TableFunctionExprContext) TableArgList() ITableArgListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableArgListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableArgListContext)
}

func (s *TableFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableFunctionExpr(s)
	}
}

func (s *TableFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableFunctionExpr(s)
	}
}

func (p *ClickHouseParser) TableFunctionExpr() (localctx ITableFunctionExprContext) {
	localctx = NewTableFunctionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ClickHouseParserRULE_tableFunctionExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2377)
		p.Identifier()
	}
	{
		p.SetState(2378)
		p.Match(ClickHouseParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-1) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606846977) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-4593671619917905921) != 0) || _la == ClickHouseParserPLUS {
		{
			p.SetState(2379)
			p.TableArgList()
		}

	}
	{
		p.SetState(2382)
		p.Match(ClickHouseParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableIdentifierContext is an interface to support dynamic dispatch.
type ITableIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DatabaseIdentifier() IDatabaseIdentifierContext
	DOT() antlr.TerminalNode

	// IsTableIdentifierContext differentiates from other interfaces.
	IsTableIdentifierContext()
}

type TableIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableIdentifierContext() *TableIdentifierContext {
	var p = new(TableIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableIdentifier
	return p
}

func InitEmptyTableIdentifierContext(p *TableIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableIdentifier
}

func (*TableIdentifierContext) IsTableIdentifierContext() {}

func NewTableIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIdentifierContext {
	var p = new(TableIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableIdentifier

	return p
}

func (s *TableIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableIdentifierContext) DatabaseIdentifier() IDatabaseIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseIdentifierContext)
}

func (s *TableIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *TableIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableIdentifier(s)
	}
}

func (s *TableIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableIdentifier(s)
	}
}

func (p *ClickHouseParser) TableIdentifier() (localctx ITableIdentifierContext) {
	localctx = NewTableIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, ClickHouseParserRULE_tableIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2387)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2384)
			p.DatabaseIdentifier()
		}
		{
			p.SetState(2385)
			p.Match(ClickHouseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2389)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableArgListContext is an interface to support dynamic dispatch.
type ITableArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableArgExpr() []ITableArgExprContext
	TableArgExpr(i int) ITableArgExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableArgListContext differentiates from other interfaces.
	IsTableArgListContext()
}

type TableArgListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableArgListContext() *TableArgListContext {
	var p = new(TableArgListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableArgList
	return p
}

func InitEmptyTableArgListContext(p *TableArgListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableArgList
}

func (*TableArgListContext) IsTableArgListContext() {}

func NewTableArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableArgListContext {
	var p = new(TableArgListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableArgList

	return p
}

func (s *TableArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableArgListContext) AllTableArgExpr() []ITableArgExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableArgExprContext); ok {
			len++
		}
	}

	tst := make([]ITableArgExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableArgExprContext); ok {
			tst[i] = t.(ITableArgExprContext)
			i++
		}
	}

	return tst
}

func (s *TableArgListContext) TableArgExpr(i int) ITableArgExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableArgExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableArgExprContext)
}

func (s *TableArgListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserCOMMA)
}

func (s *TableArgListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMA, i)
}

func (s *TableArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableArgList(s)
	}
}

func (s *TableArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableArgList(s)
	}
}

func (p *ClickHouseParser) TableArgList() (localctx ITableArgListContext) {
	localctx = NewTableArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, ClickHouseParserRULE_tableArgList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2391)
		p.TableArgExpr()
	}
	p.SetState(2396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ClickHouseParserCOMMA {
		{
			p.SetState(2392)
			p.Match(ClickHouseParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2393)
			p.TableArgExpr()
		}

		p.SetState(2398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableArgExprContext is an interface to support dynamic dispatch.
type ITableArgExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableFunctionExpr() ITableFunctionExprContext
	Literal() ILiteralContext
	NestedIdentifier() INestedIdentifierContext

	// IsTableArgExprContext differentiates from other interfaces.
	IsTableArgExprContext()
}

type TableArgExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableArgExprContext() *TableArgExprContext {
	var p = new(TableArgExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableArgExpr
	return p
}

func InitEmptyTableArgExprContext(p *TableArgExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_tableArgExpr
}

func (*TableArgExprContext) IsTableArgExprContext() {}

func NewTableArgExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableArgExprContext {
	var p = new(TableArgExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_tableArgExpr

	return p
}

func (s *TableArgExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TableArgExprContext) TableFunctionExpr() ITableFunctionExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionExprContext)
}

func (s *TableArgExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *TableArgExprContext) NestedIdentifier() INestedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedIdentifierContext)
}

func (s *TableArgExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableArgExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableArgExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterTableArgExpr(s)
	}
}

func (s *TableArgExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitTableArgExpr(s)
	}
}

func (p *ClickHouseParser) TableArgExpr() (localctx ITableArgExprContext) {
	localctx = NewTableArgExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, ClickHouseParserRULE_tableArgExpr)
	p.SetState(2402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 328, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2399)
			p.TableFunctionExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2400)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2401)
			p.NestedIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabaseIdentifierContext is an interface to support dynamic dispatch.
type IDatabaseIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsDatabaseIdentifierContext differentiates from other interfaces.
	IsDatabaseIdentifierContext()
}

type DatabaseIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseIdentifierContext() *DatabaseIdentifierContext {
	var p = new(DatabaseIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_databaseIdentifier
	return p
}

func InitEmptyDatabaseIdentifierContext(p *DatabaseIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_databaseIdentifier
}

func (*DatabaseIdentifierContext) IsDatabaseIdentifierContext() {}

func NewDatabaseIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseIdentifierContext {
	var p = new(DatabaseIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_databaseIdentifier

	return p
}

func (s *DatabaseIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DatabaseIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterDatabaseIdentifier(s)
	}
}

func (s *DatabaseIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitDatabaseIdentifier(s)
	}
}

func (p *ClickHouseParser) DatabaseIdentifier() (localctx IDatabaseIdentifierContext) {
	localctx = NewDatabaseIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, ClickHouseParserRULE_databaseIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2404)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatingLiteralContext is an interface to support dynamic dispatch.
type IFloatingLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOATING_LITERAL() antlr.TerminalNode
	DOT() antlr.TerminalNode
	AllDECIMAL_LITERAL() []antlr.TerminalNode
	DECIMAL_LITERAL(i int) antlr.TerminalNode
	OCTAL_LITERAL() antlr.TerminalNode

	// IsFloatingLiteralContext differentiates from other interfaces.
	IsFloatingLiteralContext()
}

type FloatingLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatingLiteralContext() *FloatingLiteralContext {
	var p = new(FloatingLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_floatingLiteral
	return p
}

func InitEmptyFloatingLiteralContext(p *FloatingLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_floatingLiteral
}

func (*FloatingLiteralContext) IsFloatingLiteralContext() {}

func NewFloatingLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatingLiteralContext {
	var p = new(FloatingLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_floatingLiteral

	return p
}

func (s *FloatingLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatingLiteralContext) FLOATING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFLOATING_LITERAL, 0)
}

func (s *FloatingLiteralContext) DOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDOT, 0)
}

func (s *FloatingLiteralContext) AllDECIMAL_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(ClickHouseParserDECIMAL_LITERAL)
}

func (s *FloatingLiteralContext) DECIMAL_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, i)
}

func (s *FloatingLiteralContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOCTAL_LITERAL, 0)
}

func (s *FloatingLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatingLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatingLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterFloatingLiteral(s)
	}
}

func (s *FloatingLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitFloatingLiteral(s)
	}
}

func (p *ClickHouseParser) FloatingLiteral() (localctx IFloatingLiteralContext) {
	localctx = NewFloatingLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, ClickHouseParserRULE_floatingLiteral)
	var _la int

	p.SetState(2414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserFLOATING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2406)
			p.Match(ClickHouseParserFLOATING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ClickHouseParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2407)
			p.Match(ClickHouseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2408)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserOCTAL_LITERAL || _la == ClickHouseParserDECIMAL_LITERAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case ClickHouseParserDECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2409)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2410)
			p.Match(ClickHouseParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2412)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2411)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ClickHouseParserOCTAL_LITERAL || _la == ClickHouseParserDECIMAL_LITERAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FloatingLiteral() IFloatingLiteralContext
	OCTAL_LITERAL() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode
	HEXADECIMAL_NUMERIC_LITERAL() antlr.TerminalNode
	BINARY_NUMERIC_LITERAL() antlr.TerminalNode
	INF() antlr.TerminalNode
	NAN_SQL() antlr.TerminalNode
	PLUS() antlr.TerminalNode
	DASH() antlr.TerminalNode

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) FloatingLiteral() IFloatingLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatingLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatingLiteralContext)
}

func (s *NumberLiteralContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOCTAL_LITERAL, 0)
}

func (s *NumberLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDECIMAL_LITERAL, 0)
}

func (s *NumberLiteralContext) HEXADECIMAL_NUMERIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHEXADECIMAL_NUMERIC_LITERAL, 0)
}

func (s *NumberLiteralContext) BINARY_NUMERIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBINARY_NUMERIC_LITERAL, 0)
}

func (s *NumberLiteralContext) INF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINF, 0)
}

func (s *NumberLiteralContext) NAN_SQL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNAN_SQL, 0)
}

func (s *NumberLiteralContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPLUS, 0)
}

func (s *NumberLiteralContext) DASH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDASH, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (p *ClickHouseParser) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, ClickHouseParserRULE_numberLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ClickHouseParserDASH || _la == ClickHouseParserPLUS {
		{
			p.SetState(2416)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ClickHouseParserDASH || _la == ClickHouseParserPLUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2419)
			p.FloatingLiteral()
		}

	case 2:
		{
			p.SetState(2420)
			p.Match(ClickHouseParserOCTAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(2421)
			p.Match(ClickHouseParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(2422)
			p.Match(ClickHouseParserHEXADECIMAL_NUMERIC_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(2423)
			p.Match(ClickHouseParserBINARY_NUMERIC_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		{
			p.SetState(2424)
			p.Match(ClickHouseParserINF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		{
			p.SetState(2425)
			p.Match(ClickHouseParserNAN_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEXADECIMAL_STRING_LITERAL() antlr.TerminalNode
	BINARY_STRING_LITERAL() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) HEXADECIMAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHEXADECIMAL_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) BINARY_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBINARY_STRING_LITERAL, 0)
}

func (s *StringLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTRING_LITERAL, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *ClickHouseParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, ClickHouseParserRULE_stringLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2428)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-237)) & ^0x3f) == 0 && ((int64(1)<<(_la-237))&259) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumberLiteral() INumberLiteralContext
	JSON_FALSE() antlr.TerminalNode
	JSON_TRUE() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	NULL_SQL() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) JSON_FALSE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJSON_FALSE, 0)
}

func (s *LiteralContext) JSON_TRUE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJSON_TRUE, 0)
}

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) NULL_SQL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULL_SQL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *ClickHouseParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, ClickHouseParserRULE_literal)
	p.SetState(2435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserINF, ClickHouseParserNAN_SQL, ClickHouseParserFLOATING_LITERAL, ClickHouseParserOCTAL_LITERAL, ClickHouseParserDECIMAL_LITERAL, ClickHouseParserHEXADECIMAL_NUMERIC_LITERAL, ClickHouseParserBINARY_NUMERIC_LITERAL, ClickHouseParserDASH, ClickHouseParserDOT, ClickHouseParserPLUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2430)
			p.NumberLiteral()
		}

	case ClickHouseParserJSON_FALSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2431)
			p.Match(ClickHouseParserJSON_FALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ClickHouseParserJSON_TRUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2432)
			p.Match(ClickHouseParserJSON_TRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ClickHouseParserHEXADECIMAL_STRING_LITERAL, ClickHouseParserBINARY_STRING_LITERAL, ClickHouseParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2433)
			p.StringLiteral()
		}

	case ClickHouseParserNULL_SQL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2434)
			p.Match(ClickHouseParserNULL_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NANOSECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	DAY() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	YEAR() antlr.TerminalNode

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) NANOSECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNANOSECOND, 0)
}

func (s *IntervalContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMICROSECOND, 0)
}

func (s *IntervalContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMILLISECOND, 0)
}

func (s *IntervalContext) SECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSECOND, 0)
}

func (s *IntervalContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMINUTE, 0)
}

func (s *IntervalContext) HOUR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHOUR, 0)
}

func (s *IntervalContext) DAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDAY, 0)
}

func (s *IntervalContext) WEEK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWEEK, 0)
}

func (s *IntervalContext) MONTH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMONTH, 0)
}

func (s *IntervalContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUARTER, 0)
}

func (s *IntervalContext) YEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserYEAR, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *ClickHouseParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, ClickHouseParserRULE_interval)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2437)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ClickHouseParserDAY || _la == ClickHouseParserHOUR || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&36028934457917995) != 0) || _la == ClickHouseParserWEEK || _la == ClickHouseParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCESS() antlr.TerminalNode
	ADD() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	ALL() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	AND() antlr.TerminalNode
	ANTI() antlr.TerminalNode
	ANY() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AS() antlr.TerminalNode
	ASCENDING() antlr.TerminalNode
	ASOF() antlr.TerminalNode
	AST() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	ATTACH() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	BOTH() antlr.TerminalNode
	BY() antlr.TerminalNode
	CACHES() antlr.TerminalNode
	CASE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	CODEC() antlr.TerminalNode
	COLLATE() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	CHANGED() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DEDUPLICATE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DELAY() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCENDING() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DETACH() antlr.TerminalNode
	DICTIONARIES() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	DROP() antlr.TerminalNode
	ELSE() antlr.TerminalNode
	ENABLED() antlr.TerminalNode
	END() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ESTIMATE() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXPRESSION() antlr.TerminalNode
	EXTENDED() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	FETCHES() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILESYSTEM() antlr.TerminalNode
	FILL() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FREEZE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANULARITY() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	HAVING() antlr.TerminalNode
	HIERARCHICAL() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	ID() antlr.TerminalNode
	IF() antlr.TerminalNode
	ILIKE() antlr.TerminalNode
	IMPLICIT() antlr.TerminalNode
	IN() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INDICES() antlr.TerminalNode
	INJECTIVE() antlr.TerminalNode
	INNER() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	INTERPOLATE() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	INTO() antlr.TerminalNode
	IS() antlr.TerminalNode
	IS_OBJECT_ID() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	JSON_FALSE() antlr.TerminalNode
	JSON_TRUE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	KEYS() antlr.TerminalNode
	KILL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LAYOUT() antlr.TerminalNode
	LEADING() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIFETIME() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	LIVE() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	MATERIALIZE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MERGES() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MOVE() antlr.TerminalNode
	MUTATION() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOT() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ON() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	OR() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	OVER() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	PIPELINE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	POLICY() antlr.TerminalNode
	POLICIES() antlr.TerminalNode
	POPULATE() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PREWHERE() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILES() antlr.TerminalNode
	PROJECTION() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	QUOTAS() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	RECURSIVE() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	REPLICATED() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROW() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SENDS() antlr.TerminalNode
	SET() antlr.TerminalNode
	SETTING() antlr.TerminalNode
	SETTINGS() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	START() antlr.TerminalNode
	STOP() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYNTAX() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	STEP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEST() antlr.TerminalNode
	THEN() antlr.TerminalNode
	TIES() antlr.TerminalNode
	TIMEOUT() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TO() antlr.TerminalNode
	TOP() antlr.TerminalNode
	TOTALS() antlr.TerminalNode
	TRAILING() antlr.TerminalNode
	TREE() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TTL() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNION() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USE() antlr.TerminalNode
	USER() antlr.TerminalNode
	USERS() antlr.TerminalNode
	USING() antlr.TerminalNode
	UUID() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	WATCH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	WINDOW() antlr.TerminalNode
	WITH() antlr.TerminalNode
	YEAR() antlr.TerminalNode

	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserACCESS, 0)
}

func (s *KeywordContext) ADD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserADD, 0)
}

func (s *KeywordContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAFTER, 0)
}

func (s *KeywordContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALIAS, 0)
}

func (s *KeywordContext) ALL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALL, 0)
}

func (s *KeywordContext) ALTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALTER, 0)
}

func (s *KeywordContext) AND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAND, 0)
}

func (s *KeywordContext) ANTI() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANTI, 0)
}

func (s *KeywordContext) ANY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserANY, 0)
}

func (s *KeywordContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserARRAY, 0)
}

func (s *KeywordContext) AS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAS, 0)
}

func (s *KeywordContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASCENDING, 0)
}

func (s *KeywordContext) ASOF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASOF, 0)
}

func (s *KeywordContext) AST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAST, 0)
}

func (s *KeywordContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASYNC, 0)
}

func (s *KeywordContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *KeywordContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBETWEEN, 0)
}

func (s *KeywordContext) BOTH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBOTH, 0)
}

func (s *KeywordContext) BY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBY, 0)
}

func (s *KeywordContext) CACHES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCACHES, 0)
}

func (s *KeywordContext) CASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCASE, 0)
}

func (s *KeywordContext) CAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCAST, 0)
}

func (s *KeywordContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCHECK, 0)
}

func (s *KeywordContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLEAR, 0)
}

func (s *KeywordContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLUSTER, 0)
}

func (s *KeywordContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLUSTERS, 0)
}

func (s *KeywordContext) CODEC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCODEC, 0)
}

func (s *KeywordContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLLATE, 0)
}

func (s *KeywordContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *KeywordContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMNS, 0)
}

func (s *KeywordContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *KeywordContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCONSTRAINT, 0)
}

func (s *KeywordContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *KeywordContext) CROSS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCROSS, 0)
}

func (s *KeywordContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCUBE, 0)
}

func (s *KeywordContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCURRENT, 0)
}

func (s *KeywordContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCURRENT_USER, 0)
}

func (s *KeywordContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCHANGED, 0)
}

func (s *KeywordContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *KeywordContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASES, 0)
}

func (s *KeywordContext) DATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATE, 0)
}

func (s *KeywordContext) DAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDAY, 0)
}

func (s *KeywordContext) DEDUPLICATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEDUPLICATE, 0)
}

func (s *KeywordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEFAULT, 0)
}

func (s *KeywordContext) DELAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELAY, 0)
}

func (s *KeywordContext) DELETE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELETE, 0)
}

func (s *KeywordContext) DESC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESC, 0)
}

func (s *KeywordContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESCENDING, 0)
}

func (s *KeywordContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESCRIBE, 0)
}

func (s *KeywordContext) DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDETACH, 0)
}

func (s *KeywordContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARIES, 0)
}

func (s *KeywordContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *KeywordContext) DISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISK, 0)
}

func (s *KeywordContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTINCT, 0)
}

func (s *KeywordContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTRIBUTED, 0)
}

func (s *KeywordContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *KeywordContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserELSE, 0)
}

func (s *KeywordContext) ENABLED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserENABLED, 0)
}

func (s *KeywordContext) END() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEND, 0)
}

func (s *KeywordContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserENGINE, 0)
}

func (s *KeywordContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserENGINES, 0)
}

func (s *KeywordContext) ESTIMATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserESTIMATE, 0)
}

func (s *KeywordContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEVENTS, 0)
}

func (s *KeywordContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXCEPT, 0)
}

func (s *KeywordContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *KeywordContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPLAIN, 0)
}

func (s *KeywordContext) EXPRESSION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPRESSION, 0)
}

func (s *KeywordContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXTENDED, 0)
}

func (s *KeywordContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXTRACT, 0)
}

func (s *KeywordContext) FETCHES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFETCHES, 0)
}

func (s *KeywordContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFIELDS, 0)
}

func (s *KeywordContext) FILESYSTEM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFILESYSTEM, 0)
}

func (s *KeywordContext) FILL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFILL, 0)
}

func (s *KeywordContext) FINAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFINAL, 0)
}

func (s *KeywordContext) FIRST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFIRST, 0)
}

func (s *KeywordContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFLUSH, 0)
}

func (s *KeywordContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFOLLOWING, 0)
}

func (s *KeywordContext) FOR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFOR, 0)
}

func (s *KeywordContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFORMAT, 0)
}

func (s *KeywordContext) FREEZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFREEZE, 0)
}

func (s *KeywordContext) FROM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFROM, 0)
}

func (s *KeywordContext) FULL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFULL, 0)
}

func (s *KeywordContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFUNCTION, 0)
}

func (s *KeywordContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFUNCTIONS, 0)
}

func (s *KeywordContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGLOBAL, 0)
}

func (s *KeywordContext) GRANULARITY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGRANULARITY, 0)
}

func (s *KeywordContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGRANTS, 0)
}

func (s *KeywordContext) GROUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGROUP, 0)
}

func (s *KeywordContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGROUPING, 0)
}

func (s *KeywordContext) HAVING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHAVING, 0)
}

func (s *KeywordContext) HIERARCHICAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHIERARCHICAL, 0)
}

func (s *KeywordContext) HOUR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHOUR, 0)
}

func (s *KeywordContext) ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserID, 0)
}

func (s *KeywordContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *KeywordContext) ILIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserILIKE, 0)
}

func (s *KeywordContext) IMPLICIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIMPLICIT, 0)
}

func (s *KeywordContext) IN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIN, 0)
}

func (s *KeywordContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *KeywordContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEXES, 0)
}

func (s *KeywordContext) INDICES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDICES, 0)
}

func (s *KeywordContext) INJECTIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINJECTIVE, 0)
}

func (s *KeywordContext) INNER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINNER, 0)
}

func (s *KeywordContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINSERT, 0)
}

func (s *KeywordContext) INTERPOLATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTERPOLATE, 0)
}

func (s *KeywordContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTERVAL, 0)
}

func (s *KeywordContext) INTO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINTO, 0)
}

func (s *KeywordContext) IS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIS, 0)
}

func (s *KeywordContext) IS_OBJECT_ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIS_OBJECT_ID, 0)
}

func (s *KeywordContext) JOIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJOIN, 0)
}

func (s *KeywordContext) JSON_FALSE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJSON_FALSE, 0)
}

func (s *KeywordContext) JSON_TRUE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserJSON_TRUE, 0)
}

func (s *KeywordContext) KEY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEY, 0)
}

func (s *KeywordContext) KEYS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEYS, 0)
}

func (s *KeywordContext) KILL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKILL, 0)
}

func (s *KeywordContext) LAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLAST, 0)
}

func (s *KeywordContext) LAYOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLAYOUT, 0)
}

func (s *KeywordContext) LEADING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEADING, 0)
}

func (s *KeywordContext) LEFT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEFT, 0)
}

func (s *KeywordContext) LIFETIME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIFETIME, 0)
}

func (s *KeywordContext) LIKE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIKE, 0)
}

func (s *KeywordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIMIT, 0)
}

func (s *KeywordContext) LIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIVE, 0)
}

func (s *KeywordContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOCAL, 0)
}

func (s *KeywordContext) LOGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOGS, 0)
}

func (s *KeywordContext) MATERIALIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZE, 0)
}

func (s *KeywordContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZED, 0)
}

func (s *KeywordContext) MAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMAX, 0)
}

func (s *KeywordContext) MERGES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMERGES, 0)
}

func (s *KeywordContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMICROSECOND, 0)
}

func (s *KeywordContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMILLISECOND, 0)
}

func (s *KeywordContext) MIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMIN, 0)
}

func (s *KeywordContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMINUTE, 0)
}

func (s *KeywordContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *KeywordContext) MOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMOVE, 0)
}

func (s *KeywordContext) MUTATION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMUTATION, 0)
}

func (s *KeywordContext) NO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNO, 0)
}

func (s *KeywordContext) NOT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNOT, 0)
}

func (s *KeywordContext) NULLS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULLS, 0)
}

func (s *KeywordContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOFFSET, 0)
}

func (s *KeywordContext) ON() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserON, 0)
}

func (s *KeywordContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOPTIMIZE, 0)
}

func (s *KeywordContext) OR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOR, 0)
}

func (s *KeywordContext) ORDER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserORDER, 0)
}

func (s *KeywordContext) OUTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTER, 0)
}

func (s *KeywordContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTFILE, 0)
}

func (s *KeywordContext) OVER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOVER, 0)
}

func (s *KeywordContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOVERRIDE, 0)
}

func (s *KeywordContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPARTITION, 0)
}

func (s *KeywordContext) PIPELINE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPIPELINE, 0)
}

func (s *KeywordContext) PLAN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPLAN, 0)
}

func (s *KeywordContext) POLICY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPOLICY, 0)
}

func (s *KeywordContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPOLICIES, 0)
}

func (s *KeywordContext) POPULATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPOPULATE, 0)
}

func (s *KeywordContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRECEDING, 0)
}

func (s *KeywordContext) PREWHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPREWHERE, 0)
}

func (s *KeywordContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRIMARY, 0)
}

func (s *KeywordContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRIVILEGES, 0)
}

func (s *KeywordContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROCESSLIST, 0)
}

func (s *KeywordContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROFILE, 0)
}

func (s *KeywordContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROFILES, 0)
}

func (s *KeywordContext) PROJECTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPROJECTION, 0)
}

func (s *KeywordContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUARTER, 0)
}

func (s *KeywordContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUOTA, 0)
}

func (s *KeywordContext) QUOTAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserQUOTAS, 0)
}

func (s *KeywordContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRANGE, 0)
}

func (s *KeywordContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRECURSIVE, 0)
}

func (s *KeywordContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRELOAD, 0)
}

func (s *KeywordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREMOVE, 0)
}

func (s *KeywordContext) RENAME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRENAME, 0)
}

func (s *KeywordContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLACE, 0)
}

func (s *KeywordContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICA, 0)
}

func (s *KeywordContext) REPLICATED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICATED, 0)
}

func (s *KeywordContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRIGHT, 0)
}

func (s *KeywordContext) ROLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLE, 0)
}

func (s *KeywordContext) ROLES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLES, 0)
}

func (s *KeywordContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLLUP, 0)
}

func (s *KeywordContext) ROW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROW, 0)
}

func (s *KeywordContext) ROWS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROWS, 0)
}

func (s *KeywordContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSAMPLE, 0)
}

func (s *KeywordContext) SECOND() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSECOND, 0)
}

func (s *KeywordContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSELECT, 0)
}

func (s *KeywordContext) SEMI() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSEMI, 0)
}

func (s *KeywordContext) SENDS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSENDS, 0)
}

func (s *KeywordContext) SET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSET, 0)
}

func (s *KeywordContext) SETTING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTING, 0)
}

func (s *KeywordContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSETTINGS, 0)
}

func (s *KeywordContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *KeywordContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSOURCE, 0)
}

func (s *KeywordContext) START() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTART, 0)
}

func (s *KeywordContext) STOP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTOP, 0)
}

func (s *KeywordContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSUBSTRING, 0)
}

func (s *KeywordContext) SYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNC, 0)
}

func (s *KeywordContext) SYNTAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNTAX, 0)
}

func (s *KeywordContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYSTEM, 0)
}

func (s *KeywordContext) STEP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTEP, 0)
}

func (s *KeywordContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *KeywordContext) TABLES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLES, 0)
}

func (s *KeywordContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *KeywordContext) TEST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEST, 0)
}

func (s *KeywordContext) THEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTHEN, 0)
}

func (s *KeywordContext) TIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIES, 0)
}

func (s *KeywordContext) TIMEOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMEOUT, 0)
}

func (s *KeywordContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMESTAMP, 0)
}

func (s *KeywordContext) TO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTO, 0)
}

func (s *KeywordContext) TOP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTOP, 0)
}

func (s *KeywordContext) TOTALS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTOTALS, 0)
}

func (s *KeywordContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRAILING, 0)
}

func (s *KeywordContext) TREE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTREE, 0)
}

func (s *KeywordContext) TRIM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRIM, 0)
}

func (s *KeywordContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRUNCATE, 0)
}

func (s *KeywordContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *KeywordContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTYPE, 0)
}

func (s *KeywordContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUNBOUNDED, 0)
}

func (s *KeywordContext) UNION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUNION, 0)
}

func (s *KeywordContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUPDATE, 0)
}

func (s *KeywordContext) USE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSE, 0)
}

func (s *KeywordContext) USER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSER, 0)
}

func (s *KeywordContext) USERS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSERS, 0)
}

func (s *KeywordContext) USING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSING, 0)
}

func (s *KeywordContext) UUID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUUID, 0)
}

func (s *KeywordContext) VALUES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVALUES, 0)
}

func (s *KeywordContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *KeywordContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVOLUME, 0)
}

func (s *KeywordContext) WATCH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWATCH, 0)
}

func (s *KeywordContext) WEEK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWEEK, 0)
}

func (s *KeywordContext) WHEN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHEN, 0)
}

func (s *KeywordContext) WHERE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWHERE, 0)
}

func (s *KeywordContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWINDOW, 0)
}

func (s *KeywordContext) WITH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWITH, 0)
}

func (s *KeywordContext) YEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserYEAR, 0)
}

func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterKeyword(s)
	}
}

func (s *KeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitKeyword(s)
	}
}

func (p *ClickHouseParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, ClickHouseParserRULE_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2439)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-137438953473) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1152921504606851873) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&35184372088831) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeywordForAliasContext is an interface to support dynamic dispatch.
type IKeywordForAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AFTER() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	AST() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	ATTACH() antlr.TerminalNode
	BOTH() antlr.TerminalNode
	CASE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CODEC() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	CONSTRAINT() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CUBE() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DEDUPLICATE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DELAY() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	DETACH() antlr.TerminalNode
	DICTIONARIES() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	DROP() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	EXPRESSION() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	FETCHES() antlr.TerminalNode
	FLUSH() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FREEZE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GRANULARITY() antlr.TerminalNode
	HIERARCHICAL() antlr.TerminalNode
	ID() antlr.TerminalNode
	IF() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INJECTIVE() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	IS_OBJECT_ID() antlr.TerminalNode
	KEY() antlr.TerminalNode
	KILL() antlr.TerminalNode
	LAYOUT() antlr.TerminalNode
	LEADING() antlr.TerminalNode
	LIFETIME() antlr.TerminalNode
	LIVE() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	MATERIALIZE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MERGES() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MOVE() antlr.TerminalNode
	MUTATION() antlr.TerminalNode
	NO() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	POPULATE() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	RELOAD() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	RENAME() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	REPLICATED() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROW() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	SENDS() antlr.TerminalNode
	SET() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	START() antlr.TerminalNode
	STOP() antlr.TerminalNode
	SUBSTRING() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYNTAX() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEST() antlr.TerminalNode
	TIES() antlr.TerminalNode
	TIMEOUT() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TOTALS() antlr.TerminalNode
	TRAILING() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TTL() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USE() antlr.TerminalNode
	UUID() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	WATCH() antlr.TerminalNode

	// IsKeywordForAliasContext differentiates from other interfaces.
	IsKeywordForAliasContext()
}

type KeywordForAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordForAliasContext() *KeywordForAliasContext {
	var p = new(KeywordForAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_keywordForAlias
	return p
}

func InitEmptyKeywordForAliasContext(p *KeywordForAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_keywordForAlias
}

func (*KeywordForAliasContext) IsKeywordForAliasContext() {}

func NewKeywordForAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordForAliasContext {
	var p = new(KeywordForAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_keywordForAlias

	return p
}

func (s *KeywordForAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordForAliasContext) AFTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAFTER, 0)
}

func (s *KeywordForAliasContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALIAS, 0)
}

func (s *KeywordForAliasContext) ALTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserALTER, 0)
}

func (s *KeywordForAliasContext) AST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserAST, 0)
}

func (s *KeywordForAliasContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserASYNC, 0)
}

func (s *KeywordForAliasContext) ATTACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserATTACH, 0)
}

func (s *KeywordForAliasContext) BOTH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserBOTH, 0)
}

func (s *KeywordForAliasContext) CASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCASE, 0)
}

func (s *KeywordForAliasContext) CAST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCAST, 0)
}

func (s *KeywordForAliasContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCHECK, 0)
}

func (s *KeywordForAliasContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLEAR, 0)
}

func (s *KeywordForAliasContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCLUSTER, 0)
}

func (s *KeywordForAliasContext) CODEC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCODEC, 0)
}

func (s *KeywordForAliasContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOLUMN, 0)
}

func (s *KeywordForAliasContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCOMMENT, 0)
}

func (s *KeywordForAliasContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCONSTRAINT, 0)
}

func (s *KeywordForAliasContext) CREATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCREATE, 0)
}

func (s *KeywordForAliasContext) CUBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCUBE, 0)
}

func (s *KeywordForAliasContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserCURRENT, 0)
}

func (s *KeywordForAliasContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASE, 0)
}

func (s *KeywordForAliasContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATABASES, 0)
}

func (s *KeywordForAliasContext) DATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDATE, 0)
}

func (s *KeywordForAliasContext) DEDUPLICATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEDUPLICATE, 0)
}

func (s *KeywordForAliasContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDEFAULT, 0)
}

func (s *KeywordForAliasContext) DELAY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDELAY, 0)
}

func (s *KeywordForAliasContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDESCRIBE, 0)
}

func (s *KeywordForAliasContext) DETACH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDETACH, 0)
}

func (s *KeywordForAliasContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARIES, 0)
}

func (s *KeywordForAliasContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDICTIONARY, 0)
}

func (s *KeywordForAliasContext) DISK() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISK, 0)
}

func (s *KeywordForAliasContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDISTRIBUTED, 0)
}

func (s *KeywordForAliasContext) DROP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserDROP, 0)
}

func (s *KeywordForAliasContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserENGINE, 0)
}

func (s *KeywordForAliasContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEVENTS, 0)
}

func (s *KeywordForAliasContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXISTS, 0)
}

func (s *KeywordForAliasContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPLAIN, 0)
}

func (s *KeywordForAliasContext) EXPRESSION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXPRESSION, 0)
}

func (s *KeywordForAliasContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEXTRACT, 0)
}

func (s *KeywordForAliasContext) FETCHES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFETCHES, 0)
}

func (s *KeywordForAliasContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFLUSH, 0)
}

func (s *KeywordForAliasContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFOLLOWING, 0)
}

func (s *KeywordForAliasContext) FREEZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFREEZE, 0)
}

func (s *KeywordForAliasContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserFUNCTION, 0)
}

func (s *KeywordForAliasContext) GRANULARITY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserGRANULARITY, 0)
}

func (s *KeywordForAliasContext) HIERARCHICAL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserHIERARCHICAL, 0)
}

func (s *KeywordForAliasContext) ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserID, 0)
}

func (s *KeywordForAliasContext) IF() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIF, 0)
}

func (s *KeywordForAliasContext) INDEX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINDEX, 0)
}

func (s *KeywordForAliasContext) INJECTIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINJECTIVE, 0)
}

func (s *KeywordForAliasContext) INSERT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserINSERT, 0)
}

func (s *KeywordForAliasContext) IS_OBJECT_ID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIS_OBJECT_ID, 0)
}

func (s *KeywordForAliasContext) KEY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKEY, 0)
}

func (s *KeywordForAliasContext) KILL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserKILL, 0)
}

func (s *KeywordForAliasContext) LAYOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLAYOUT, 0)
}

func (s *KeywordForAliasContext) LEADING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLEADING, 0)
}

func (s *KeywordForAliasContext) LIFETIME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIFETIME, 0)
}

func (s *KeywordForAliasContext) LIVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLIVE, 0)
}

func (s *KeywordForAliasContext) LOGS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserLOGS, 0)
}

func (s *KeywordForAliasContext) MATERIALIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZE, 0)
}

func (s *KeywordForAliasContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMATERIALIZED, 0)
}

func (s *KeywordForAliasContext) MAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMAX, 0)
}

func (s *KeywordForAliasContext) MERGES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMERGES, 0)
}

func (s *KeywordForAliasContext) MIN() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMIN, 0)
}

func (s *KeywordForAliasContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMODIFY, 0)
}

func (s *KeywordForAliasContext) MOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMOVE, 0)
}

func (s *KeywordForAliasContext) MUTATION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserMUTATION, 0)
}

func (s *KeywordForAliasContext) NO() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNO, 0)
}

func (s *KeywordForAliasContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOPTIMIZE, 0)
}

func (s *KeywordForAliasContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOUTFILE, 0)
}

func (s *KeywordForAliasContext) OVER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserOVER, 0)
}

func (s *KeywordForAliasContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPARTITION, 0)
}

func (s *KeywordForAliasContext) POPULATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPOPULATE, 0)
}

func (s *KeywordForAliasContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRECEDING, 0)
}

func (s *KeywordForAliasContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserPRIMARY, 0)
}

func (s *KeywordForAliasContext) RANGE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRANGE, 0)
}

func (s *KeywordForAliasContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRELOAD, 0)
}

func (s *KeywordForAliasContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREMOVE, 0)
}

func (s *KeywordForAliasContext) RENAME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserRENAME, 0)
}

func (s *KeywordForAliasContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLACE, 0)
}

func (s *KeywordForAliasContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICA, 0)
}

func (s *KeywordForAliasContext) REPLICATED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserREPLICATED, 0)
}

func (s *KeywordForAliasContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROLLUP, 0)
}

func (s *KeywordForAliasContext) ROW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserROW, 0)
}

func (s *KeywordForAliasContext) SELECT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSELECT, 0)
}

func (s *KeywordForAliasContext) SENDS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSENDS, 0)
}

func (s *KeywordForAliasContext) SET() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSET, 0)
}

func (s *KeywordForAliasContext) SHOW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSHOW, 0)
}

func (s *KeywordForAliasContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSOURCE, 0)
}

func (s *KeywordForAliasContext) START() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTART, 0)
}

func (s *KeywordForAliasContext) STOP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSTOP, 0)
}

func (s *KeywordForAliasContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSUBSTRING, 0)
}

func (s *KeywordForAliasContext) SYNC() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNC, 0)
}

func (s *KeywordForAliasContext) SYNTAX() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYNTAX, 0)
}

func (s *KeywordForAliasContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserSYSTEM, 0)
}

func (s *KeywordForAliasContext) TABLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLE, 0)
}

func (s *KeywordForAliasContext) TABLES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTABLES, 0)
}

func (s *KeywordForAliasContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEMPORARY, 0)
}

func (s *KeywordForAliasContext) TEST() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTEST, 0)
}

func (s *KeywordForAliasContext) TIES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIES, 0)
}

func (s *KeywordForAliasContext) TIMEOUT() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMEOUT, 0)
}

func (s *KeywordForAliasContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTIMESTAMP, 0)
}

func (s *KeywordForAliasContext) TOTALS() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTOTALS, 0)
}

func (s *KeywordForAliasContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRAILING, 0)
}

func (s *KeywordForAliasContext) TRIM() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRIM, 0)
}

func (s *KeywordForAliasContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTRUNCATE, 0)
}

func (s *KeywordForAliasContext) TTL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTTL, 0)
}

func (s *KeywordForAliasContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserTYPE, 0)
}

func (s *KeywordForAliasContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUNBOUNDED, 0)
}

func (s *KeywordForAliasContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUPDATE, 0)
}

func (s *KeywordForAliasContext) USE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUSE, 0)
}

func (s *KeywordForAliasContext) UUID() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserUUID, 0)
}

func (s *KeywordForAliasContext) VALUES() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVALUES, 0)
}

func (s *KeywordForAliasContext) VIEW() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVIEW, 0)
}

func (s *KeywordForAliasContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserVOLUME, 0)
}

func (s *KeywordForAliasContext) WATCH() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserWATCH, 0)
}

func (s *KeywordForAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordForAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordForAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterKeywordForAlias(s)
	}
}

func (s *KeywordForAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitKeywordForAlias(s)
	}
}

func (p *ClickHouseParser) KeywordForAlias() (localctx IKeywordForAliasContext) {
	localctx = NewKeywordForAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, ClickHouseParserRULE_keywordForAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2441)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-7944847152845045672) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&9019954286282709047) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-2069897433878609611) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&33403124703) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	KeywordForAlias() IKeywordForAliasContext

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alias
	return p
}

func InitEmptyAliasContext(p *AliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_alias
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIDENTIFIER, 0)
}

func (s *AliasContext) KeywordForAlias() IKeywordForAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordForAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordForAliasContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (p *ClickHouseParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, ClickHouseParserRULE_alias)
	p.SetState(2445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2443)
			p.Match(ClickHouseParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALTER, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBOTH, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCODEC, ClickHouseParserCOLUMN, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCUBE, ClickHouseParserCURRENT, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserENGINE, ClickHouseParserEVENTS, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFLUSH, ClickHouseParserFOLLOWING, ClickHouseParserFREEZE, ClickHouseParserFUNCTION, ClickHouseParserGRANULARITY, ClickHouseParserHIERARCHICAL, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserINDEX, ClickHouseParserINJECTIVE, ClickHouseParserINSERT, ClickHouseParserIS_OBJECT_ID, ClickHouseParserKEY, ClickHouseParserKILL, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLIFETIME, ClickHouseParserLIVE, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMIN, ClickHouseParserMODIFY, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNO, ClickHouseParserOPTIMIZE, ClickHouseParserOUTFILE, ClickHouseParserOVER, ClickHouseParserPARTITION, ClickHouseParserPOPULATE, ClickHouseParserPRECEDING, ClickHouseParserPRIMARY, ClickHouseParserRANGE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserROLLUP, ClickHouseParserROW, ClickHouseParserSELECT, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNBOUNDED, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2444)
			p.KeywordForAlias()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Interval() IIntervalContext
	Keyword() IKeywordContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserIDENTIFIER, 0)
}

func (s *IdentifierContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IdentifierContext) Keyword() IKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *ClickHouseParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, ClickHouseParserRULE_identifier)
	p.SetState(2450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2447)
			p.Match(ClickHouseParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2448)
			p.Interval()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2449)
			p.Keyword()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrNullContext is an interface to support dynamic dispatch.
type IIdentifierOrNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	NULL_SQL() antlr.TerminalNode

	// IsIdentifierOrNullContext differentiates from other interfaces.
	IsIdentifierOrNullContext()
}

type IdentifierOrNullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrNullContext() *IdentifierOrNullContext {
	var p = new(IdentifierOrNullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_identifierOrNull
	return p
}

func InitEmptyIdentifierOrNullContext(p *IdentifierOrNullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_identifierOrNull
}

func (*IdentifierOrNullContext) IsIdentifierOrNullContext() {}

func NewIdentifierOrNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrNullContext {
	var p = new(IdentifierOrNullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_identifierOrNull

	return p
}

func (s *IdentifierOrNullContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrNullContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrNullContext) NULL_SQL() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserNULL_SQL, 0)
}

func (s *IdentifierOrNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterIdentifierOrNull(s)
	}
}

func (s *IdentifierOrNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitIdentifierOrNull(s)
	}
}

func (p *ClickHouseParser) IdentifierOrNull() (localctx IIdentifierOrNullContext) {
	localctx = NewIdentifierOrNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, ClickHouseParserRULE_identifierOrNull)
	p.SetState(2454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ClickHouseParserACCESS, ClickHouseParserADD, ClickHouseParserAFTER, ClickHouseParserALIAS, ClickHouseParserALL, ClickHouseParserALTER, ClickHouseParserAND, ClickHouseParserANTI, ClickHouseParserANY, ClickHouseParserARRAY, ClickHouseParserAS, ClickHouseParserASCENDING, ClickHouseParserASOF, ClickHouseParserAST, ClickHouseParserASYNC, ClickHouseParserATTACH, ClickHouseParserBETWEEN, ClickHouseParserBOTH, ClickHouseParserBY, ClickHouseParserCACHES, ClickHouseParserCASE, ClickHouseParserCAST, ClickHouseParserCHECK, ClickHouseParserCLEAR, ClickHouseParserCLUSTER, ClickHouseParserCLUSTERS, ClickHouseParserCODEC, ClickHouseParserCOLLATE, ClickHouseParserCOLUMN, ClickHouseParserCOLUMNS, ClickHouseParserCOMMENT, ClickHouseParserCONSTRAINT, ClickHouseParserCREATE, ClickHouseParserCROSS, ClickHouseParserCUBE, ClickHouseParserCURRENT, ClickHouseParserCURRENT_USER, ClickHouseParserCHANGED, ClickHouseParserDATABASE, ClickHouseParserDATABASES, ClickHouseParserDATE, ClickHouseParserDAY, ClickHouseParserDEDUPLICATE, ClickHouseParserDEFAULT, ClickHouseParserDELAY, ClickHouseParserDELETE, ClickHouseParserDESC, ClickHouseParserDESCENDING, ClickHouseParserDESCRIBE, ClickHouseParserDETACH, ClickHouseParserDICTIONARIES, ClickHouseParserDICTIONARY, ClickHouseParserDISK, ClickHouseParserDISTINCT, ClickHouseParserDISTRIBUTED, ClickHouseParserDROP, ClickHouseParserELSE, ClickHouseParserENABLED, ClickHouseParserEND, ClickHouseParserENGINE, ClickHouseParserENGINES, ClickHouseParserESTIMATE, ClickHouseParserEVENTS, ClickHouseParserEXCEPT, ClickHouseParserEXISTS, ClickHouseParserEXPLAIN, ClickHouseParserEXPRESSION, ClickHouseParserEXTENDED, ClickHouseParserEXTRACT, ClickHouseParserFETCHES, ClickHouseParserFIELDS, ClickHouseParserFILESYSTEM, ClickHouseParserFILL, ClickHouseParserFINAL, ClickHouseParserFIRST, ClickHouseParserFLUSH, ClickHouseParserFOLLOWING, ClickHouseParserFOR, ClickHouseParserFORMAT, ClickHouseParserFREEZE, ClickHouseParserFROM, ClickHouseParserFULL, ClickHouseParserFUNCTION, ClickHouseParserFUNCTIONS, ClickHouseParserGLOBAL, ClickHouseParserGRANULARITY, ClickHouseParserGRANTS, ClickHouseParserGROUP, ClickHouseParserGROUPING, ClickHouseParserHAVING, ClickHouseParserHIERARCHICAL, ClickHouseParserHOUR, ClickHouseParserID, ClickHouseParserIF, ClickHouseParserILIKE, ClickHouseParserIMPLICIT, ClickHouseParserIN, ClickHouseParserINDEX, ClickHouseParserINDEXES, ClickHouseParserINDICES, ClickHouseParserINJECTIVE, ClickHouseParserINNER, ClickHouseParserINSERT, ClickHouseParserINTERPOLATE, ClickHouseParserINTERVAL, ClickHouseParserINTO, ClickHouseParserIS, ClickHouseParserIS_OBJECT_ID, ClickHouseParserJOIN, ClickHouseParserKEY, ClickHouseParserKEYS, ClickHouseParserKILL, ClickHouseParserLAST, ClickHouseParserLAYOUT, ClickHouseParserLEADING, ClickHouseParserLEFT, ClickHouseParserLIFETIME, ClickHouseParserLIKE, ClickHouseParserLIMIT, ClickHouseParserLIVE, ClickHouseParserLOCAL, ClickHouseParserLOGS, ClickHouseParserMATERIALIZE, ClickHouseParserMATERIALIZED, ClickHouseParserMAX, ClickHouseParserMERGES, ClickHouseParserMICROSECOND, ClickHouseParserMILLISECOND, ClickHouseParserMIN, ClickHouseParserMINUTE, ClickHouseParserMODIFY, ClickHouseParserMONTH, ClickHouseParserMOVE, ClickHouseParserMUTATION, ClickHouseParserNANOSECOND, ClickHouseParserNO, ClickHouseParserNOT, ClickHouseParserNULLS, ClickHouseParserOFFSET, ClickHouseParserON, ClickHouseParserOPTIMIZE, ClickHouseParserOR, ClickHouseParserORDER, ClickHouseParserOUTER, ClickHouseParserOUTFILE, ClickHouseParserOVER, ClickHouseParserOVERRIDE, ClickHouseParserPARTITION, ClickHouseParserPIPELINE, ClickHouseParserPLAN, ClickHouseParserPOLICY, ClickHouseParserPOLICIES, ClickHouseParserPOPULATE, ClickHouseParserPRECEDING, ClickHouseParserPREWHERE, ClickHouseParserPRIMARY, ClickHouseParserPRIVILEGES, ClickHouseParserPROCESSLIST, ClickHouseParserPROFILE, ClickHouseParserPROFILES, ClickHouseParserPROJECTION, ClickHouseParserQUARTER, ClickHouseParserQUOTA, ClickHouseParserQUOTAS, ClickHouseParserRANGE, ClickHouseParserRECURSIVE, ClickHouseParserRELOAD, ClickHouseParserREMOVE, ClickHouseParserRENAME, ClickHouseParserREPLACE, ClickHouseParserREPLICA, ClickHouseParserREPLICATED, ClickHouseParserRIGHT, ClickHouseParserROLE, ClickHouseParserROLES, ClickHouseParserROLLUP, ClickHouseParserROW, ClickHouseParserROWS, ClickHouseParserSAMPLE, ClickHouseParserSECOND, ClickHouseParserSELECT, ClickHouseParserSEMI, ClickHouseParserSENDS, ClickHouseParserSET, ClickHouseParserSETTING, ClickHouseParserSETTINGS, ClickHouseParserSHOW, ClickHouseParserSOURCE, ClickHouseParserSTART, ClickHouseParserSTOP, ClickHouseParserSUBSTRING, ClickHouseParserSYNC, ClickHouseParserSYNTAX, ClickHouseParserSYSTEM, ClickHouseParserSTEP, ClickHouseParserTABLE, ClickHouseParserTABLES, ClickHouseParserTEMPORARY, ClickHouseParserTEST, ClickHouseParserTHEN, ClickHouseParserTIES, ClickHouseParserTIMEOUT, ClickHouseParserTIMESTAMP, ClickHouseParserTO, ClickHouseParserTOP, ClickHouseParserTOTALS, ClickHouseParserTRAILING, ClickHouseParserTREE, ClickHouseParserTRIM, ClickHouseParserTRUNCATE, ClickHouseParserTTL, ClickHouseParserTYPE, ClickHouseParserUNBOUNDED, ClickHouseParserUNION, ClickHouseParserUPDATE, ClickHouseParserUSE, ClickHouseParserUSER, ClickHouseParserUSERS, ClickHouseParserUSING, ClickHouseParserUUID, ClickHouseParserVALUES, ClickHouseParserVIEW, ClickHouseParserVOLUME, ClickHouseParserWATCH, ClickHouseParserWEEK, ClickHouseParserWHEN, ClickHouseParserWHERE, ClickHouseParserWINDOW, ClickHouseParserWITH, ClickHouseParserYEAR, ClickHouseParserJSON_FALSE, ClickHouseParserJSON_TRUE, ClickHouseParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2452)
			p.Identifier()
		}

	case ClickHouseParserNULL_SQL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2453)
			p.Match(ClickHouseParserNULL_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumValueContext is an interface to support dynamic dispatch.
type IEnumValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	EQ_SINGLE() antlr.TerminalNode
	NumberLiteral() INumberLiteralContext

	// IsEnumValueContext differentiates from other interfaces.
	IsEnumValueContext()
}

type EnumValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueContext() *EnumValueContext {
	var p = new(EnumValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_enumValue
	return p
}

func InitEmptyEnumValueContext(p *EnumValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ClickHouseParserRULE_enumValue
}

func (*EnumValueContext) IsEnumValueContext() {}

func NewEnumValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueContext {
	var p = new(EnumValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ClickHouseParserRULE_enumValue

	return p
}

func (s *EnumValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *EnumValueContext) EQ_SINGLE() antlr.TerminalNode {
	return s.GetToken(ClickHouseParserEQ_SINGLE, 0)
}

func (s *EnumValueContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *EnumValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.EnterEnumValue(s)
	}
}

func (s *EnumValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ClickHouseParserListener); ok {
		listenerT.ExitEnumValue(s)
	}
}

func (p *ClickHouseParser) EnumValue() (localctx IEnumValueContext) {
	localctx = NewEnumValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, ClickHouseParserRULE_enumValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2456)
		p.StringLiteral()
	}
	{
		p.SetState(2457)
		p.Match(ClickHouseParserEQ_SINGLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2458)
		p.NumberLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *ClickHouseParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 12:
		var t *DictionaryAttrDfntContext = nil
		if localctx != nil {
			t = localctx.(*DictionaryAttrDfntContext)
		}
		return p.DictionaryAttrDfnt_Sempred(t, predIndex)

	case 13:
		var t *DictionaryEngineClauseContext = nil
		if localctx != nil {
			t = localctx.(*DictionaryEngineClauseContext)
		}
		return p.DictionaryEngineClause_Sempred(t, predIndex)

	case 26:
		var t *EngineClauseContext = nil
		if localctx != nil {
			t = localctx.(*EngineClauseContext)
		}
		return p.EngineClause_Sempred(t, predIndex)

	case 74:
		var t *JoinExprContext = nil
		if localctx != nil {
			t = localctx.(*JoinExprContext)
		}
		return p.JoinExpr_Sempred(t, predIndex)

	case 100:
		var t *ColumnExprContext = nil
		if localctx != nil {
			t = localctx.(*ColumnExprContext)
		}
		return p.ColumnExpr_Sempred(t, predIndex)

	case 107:
		var t *TableExprContext = nil
		if localctx != nil {
			t = localctx.(*TableExprContext)
		}
		return p.TableExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *ClickHouseParser) DictionaryAttrDfnt_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return !localctx.(*DictionaryAttrDfntContext).attrs["default"]

	case 1:
		return !localctx.(*DictionaryAttrDfntContext).attrs["expression"]

	case 2:
		return !localctx.(*DictionaryAttrDfntContext).attrs["hierarchical"]

	case 3:
		return !localctx.(*DictionaryAttrDfntContext).attrs["injective"]

	case 4:
		return !localctx.(*DictionaryAttrDfntContext).attrs["is_object_id"]

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) DictionaryEngineClause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return !localctx.(*DictionaryEngineClauseContext).clauses["source"]

	case 6:
		return !localctx.(*DictionaryEngineClauseContext).clauses["lifetime"]

	case 7:
		return !localctx.(*DictionaryEngineClauseContext).clauses["layout"]

	case 8:
		return !localctx.(*DictionaryEngineClauseContext).clauses["range"]

	case 9:
		return !localctx.(*DictionaryEngineClauseContext).clauses["settings"]

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) EngineClause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return !localctx.(*EngineClauseContext).clauses["orderByClause"]

	case 11:
		return !localctx.(*EngineClauseContext).clauses["partitionByClause"]

	case 12:
		return !localctx.(*EngineClauseContext).clauses["primaryKeyClause"]

	case 13:
		return !localctx.(*EngineClauseContext).clauses["sampleByClause"]

	case 14:
		return !localctx.(*EngineClauseContext).clauses["ttlClause"]

	case 15:
		return !localctx.(*EngineClauseContext).clauses["settingsClause"]

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) JoinExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) ColumnExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 30)

	case 26:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 27:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 28:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 29:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *ClickHouseParser) TableExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 30:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
